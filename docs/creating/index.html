<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Creating IO · Monix BIO</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="As always, a full and up to date list of operators is available in the API or the companion object."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Creating IO · Monix BIO"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bio.monix.io/"/><meta property="og:description" content="As always, a full and up to date list of operators is available in the API or the companion object."/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://bio.monix.io/img/monix-logo.png"/><link rel="shortcut icon" href="/img/monix-logo.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/monix-logo.svg" alt="Monix BIO"/><h2 class="headerTitleWithLogo">Monix BIO</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/api/monix/bio/index.html" target="_self">API Docs</a></li><li class="siteNavGroupActive"><a href="/docs/introduction" target="_self">Documentation</a></li><li class=""><a href="https://github.com/monix/monix-bio" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Documentation</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Documentation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/getting-started">Getting Started</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/creating">Creating IO</a></li><li class="navListItem"><a class="navItem" href="/docs/execution">Executing IO</a></li><li class="navListItem"><a class="navItem" href="/docs/error-handling">Error Handling</a></li><li class="navListItem"><a class="navItem" href="/docs/resource-safety">Resource Safety</a></li><li class="navListItem"><a class="navItem" href="/docs/cats-effect">Cats-Effect Integration</a></li><li class="navListItem"><a class="navItem" href="/docs/stack-traces">Asynchronous Stack Traces</a></li><li class="navListItem"><a class="navItem" href="/docs/comparison">Other Effects</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Creating IO</h1></header><article><div><span><p>As always, a full and up to date list of operators is available in the API or the companion object.</p>
<h2><a class="anchor" aria-hidden="true" id="simple-builders"></a><a href="#simple-builders" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simple builders</h2>
<h3><a class="anchor" aria-hidden="true" id="ionow"></a><a href="#ionow" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.now</h3>
<p><code>IO.now</code> lifts an already known value in the <code>IO</code> context, the equivalent of <code>Future.successful</code>.
Do not use it with any side effects, because they will be evaluated immediately and just once:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">IO</span>

<span class="hljs-keyword">val</span> task = <span class="hljs-type">IO</span>.now { println(<span class="hljs-string">"Effect"</span>); <span class="hljs-string">"Hello!"</span> }
<span class="hljs-comment">//=&gt; Effect</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="ioraiseerror"></a><a href="#ioraiseerror" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.raiseError</h3>
<p><code>IO.raiseError</code> lifts a typed error to the context of <code>IO</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> monix.execution.exceptions.<span class="hljs-type">DummyException</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global

<span class="hljs-keyword">val</span> error: <span class="hljs-type">IO</span>[<span class="hljs-type">DummyException</span>, <span class="hljs-type">Nothing</span>] = <span class="hljs-type">IO</span>.raiseError(<span class="hljs-type">DummyException</span>(<span class="hljs-string">"boom"</span>))

error.runAsync(result =&gt; println(result))
<span class="hljs-comment">//=&gt; Left(Cause.Error(DummyException("boom")))</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="ioterminate"></a><a href="#ioterminate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.terminate</h3>
<p><code>IO.terminate</code> lifts a terminal error to the context of <code>IO</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.{<span class="hljs-type">IO</span>, <span class="hljs-type">UIO</span>}
<span class="hljs-keyword">import</span> monix.execution.exceptions.<span class="hljs-type">DummyException</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global

<span class="hljs-keyword">val</span> error: <span class="hljs-type">UIO</span>[<span class="hljs-type">Nothing</span>] = <span class="hljs-type">IO</span>.terminate(<span class="hljs-type">DummyException</span>(<span class="hljs-string">"boom"</span>))

error.runAsync(result =&gt; println(result))
<span class="hljs-comment">//=&gt; Left(Cause.Termination(DummyException("boom")))</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="ioeval--ioapply"></a><a href="#ioeval--ioapply" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.eval / IO.apply</h3>
<p><code>IO.eval</code> is the equivalent of <code>Function0</code>, taking a function that will always be evaluated on running, possibly on the same thread (depending on the chosen execution model):</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global

<span class="hljs-keyword">val</span> task: <span class="hljs-type">IO</span>[<span class="hljs-type">Throwable</span>, <span class="hljs-type">String</span>] = <span class="hljs-type">IO</span>.eval { println(<span class="hljs-string">"Effect"</span>); <span class="hljs-string">"Hello!"</span> }

task.runToFuture.foreach(println)
<span class="hljs-comment">//=&gt; Effect</span>
<span class="hljs-comment">//=&gt; Hello!</span>

<span class="hljs-comment">// The evaluation (and thus all contained side effects)</span>
<span class="hljs-comment">// gets triggered on each runToFuture:</span>
task.runToFuture.foreach(println)
<span class="hljs-comment">//=&gt; Effect</span>
<span class="hljs-comment">//=&gt; Hello!</span>
</code></pre>
<p><code>IO.eval</code> catches errors that are thrown in the passed function:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> monix.execution.exceptions.<span class="hljs-type">DummyException</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global

<span class="hljs-keyword">val</span> task = <span class="hljs-type">IO</span>.eval { println(<span class="hljs-string">"Effect"</span>); <span class="hljs-keyword">throw</span> <span class="hljs-type">DummyException</span>(<span class="hljs-string">"Goodbye"</span>)}

task.runAsync(result =&gt; println(result))
<span class="hljs-comment">//=&gt; Effect</span>
<span class="hljs-comment">//=&gt; Left(Cause.Error(DummyException("Goodbye")))</span>

<span class="hljs-comment">// The evaluation (and thus all contained side effects)</span>
<span class="hljs-comment">// gets triggered on each runAsync:</span>
task.runAsync(result =&gt; println(result))
<span class="hljs-comment">//=&gt; Effect</span>
<span class="hljs-comment">//=&gt; Left(Cause.Error(DummyException("Goodbye")))</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="ioevaltotal--uioapply"></a><a href="#ioevaltotal--uioapply" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.evalTotal / UIO.apply</h3>
<p><code>IO.evalTotal</code> is similar to <code>eval</code> because it also suspends side effects, but it doesn't expect any errors to be thrown, so the error type is <code>Nothing</code>.
If there are any, they are considered terminal errors.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.{<span class="hljs-type">IO</span>, <span class="hljs-type">UIO</span>}
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global

<span class="hljs-keyword">val</span> task: <span class="hljs-type">UIO</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">IO</span>.evalTotal { println(<span class="hljs-string">"Effect"</span>); <span class="hljs-string">"Hello!"</span> }

task.runToFuture.foreach(println)
<span class="hljs-comment">//=&gt; Effect</span>
<span class="hljs-comment">//=&gt; Hello!</span>

<span class="hljs-comment">// The evaluation (and thus all contained side effects)</span>
<span class="hljs-comment">// gets triggered on each runToFuture:</span>
task.runToFuture.foreach(println)
<span class="hljs-comment">//=&gt; Effect</span>
<span class="hljs-comment">//=&gt; Hello!</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="ioevalonce"></a><a href="#ioevalonce" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.evalOnce</h3>
<p><code>IO.evalOnce</code> is the equivalent of a <code>lazy val</code>, a type that cannot be precisely expressed in Scala.
The <code>evalOnce</code> builder does memoization on the first run, such that the result of the evaluation will be available for subsequent runs.
It also has guaranteed idempotency and thread-safety:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global

<span class="hljs-keyword">val</span> task = <span class="hljs-type">IO</span>.evalOnce { println(<span class="hljs-string">"Effect"</span>); <span class="hljs-string">"Hello!"</span> }

task.runToFuture.foreach(println)
<span class="hljs-comment">//=&gt; Effect</span>
<span class="hljs-comment">//=&gt; Hello!</span>

<span class="hljs-comment">// Result was memoized on the first run!</span>
task.runToFuture.foreach(println)
<span class="hljs-comment">//=&gt; Hello!</span>
</code></pre>
<p>NOTE: this operation is effectively <code>IO.eval(f).memoize</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="ionever"></a><a href="#ionever" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.never</h3>
<p><code>Task.never</code> returns a Task instance that never completes:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">Task</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global
<span class="hljs-keyword">import</span> scala.concurrent.duration._
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">TimeoutException</span>

<span class="hljs-comment">// A Task instance that never completes</span>
<span class="hljs-keyword">val</span> never = <span class="hljs-type">Task</span>.never[<span class="hljs-type">Int</span>]

<span class="hljs-keyword">val</span> timedOut = never.timeoutTo(<span class="hljs-number">3.</span>seconds,
  <span class="hljs-type">Task</span>.raiseError(<span class="hljs-keyword">new</span> <span class="hljs-type">TimeoutException</span>))

timedOut.runAsync(r =&gt; println(r))
<span class="hljs-comment">// After 3 seconds:</span>
<span class="hljs-comment">// =&gt; Left(Cause.Error(java.util.concurrent.TimeoutException))</span>
</code></pre>
<p>This instance is shared so that it can relieve some stress from the garbage collector.</p>
<h2><a class="anchor" aria-hidden="true" id="asynchronous-builders"></a><a href="#asynchronous-builders" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Asynchronous builders</h2>
<h3><a class="anchor" aria-hidden="true" id="ioevalasync"></a><a href="#ioevalasync" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.evalAsync</h3>
<p>By default, <code>IO</code> prefers to execute things on the current thread.</p>
<p><code>IO.evalAsync</code> will evaluate the effect asynchronously; consider it an optimized version of <code>IO.eval.executeAsync</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global

<span class="hljs-type">IO</span>.eval(println(<span class="hljs-string">s"<span class="hljs-subst">${Thread.currentThread().getName}</span>: Executing eval"</span>)).runSyncUnsafe()
<span class="hljs-comment">// =&gt; main: Executing eval</span>

<span class="hljs-type">IO</span>.evalAsync(println(<span class="hljs-string">s"<span class="hljs-subst">${Thread.currentThread().getName}</span>: Executing evalAsync"</span>)).runSyncUnsafe()
<span class="hljs-comment">// =&gt; scala-execution-context-global-14: Executing evalAsync</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="iocreate"></a><a href="#iocreate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.create</h3>
<p><code>IO.create</code> aggregates a handful of methods that create a <code>IO</code> from a callback.</p>
<p>For example, let's create a utility that evaluates expressions with a given delay:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> scala.util.<span class="hljs-type">Try</span>
<span class="hljs-keyword">import</span> concurrent.duration._

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evalDelayed</span></span>[<span class="hljs-type">A</span>](delay: <span class="hljs-type">FiniteDuration</span>)
  (f: =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Throwable</span>, <span class="hljs-type">A</span>] = {

  <span class="hljs-comment">// On execution, we have the scheduler and</span>
  <span class="hljs-comment">// the callback injected ;-)</span>
  <span class="hljs-type">IO</span>.create { (scheduler, callback) =&gt;
    <span class="hljs-keyword">val</span> cancelable =
      scheduler.scheduleOnce(delay) {
        callback(<span class="hljs-type">Try</span>(f))
      }

    <span class="hljs-comment">// We must return something that can</span>
    <span class="hljs-comment">// cancel the async computation</span>
    cancelable
  }
}
</code></pre>
<p><code>IO.create</code> supports different cancelation tokens, such as:</p>
<ul>
<li><code>Unit</code> for non-cancelable tasks</li>
<li><code>cats.effect.IO</code></li>
<li><code>monix.bio.IO</code></li>
<li><code>monix.execution.Cancelable</code></li>
<li>And others.</li>
</ul>
<p>Some notes:</p>
<ul>
<li>Tasks created with this builder are guaranteed to execute asynchronously</li>
<li>Even if the callback is called on a different thread pool, the resulting task will continue on the default Scheduler.</li>
<li>The <a href="https://monix.io/docs/3x/execution/scheduler.html">Scheduler</a> gets injected, and with it, we can schedule things for async execution, we can delay, etc.</li>
<li>But as said, this callback will already execute asynchronously, so you don’t need to explicitly schedule things to run on the provided Scheduler unless you really need to do it.</li>
<li>The <a href="https://monix.io/docs/3x/execution/callback.html">Callback</a> gets injected on execution, and that callback has a contract. In particular, you need to execute <code>onSuccess</code>, <code>onError</code>, or <code>onTermination</code> or apply only once. The implementation does a reasonably good job to protect against contract violations, but if you do call it multiple times, then you’re doing it risking undefined and nondeterministic behavior.</li>
<li>It’s OK to return a <code>Cancelable.empty</code> in case the executed process really can’t be canceled in time. Still, you should strive to produce a cancelable that does cancel your execution, if possible.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="iofromfuture"></a><a href="#iofromfuture" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.fromFuture</h3>
<p><code>IO.fromFuture</code> can convert any Scala Future instance into a <code>IO</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">Future</span>

<span class="hljs-keyword">val</span> future = <span class="hljs-type">Future</span> { println(<span class="hljs-string">"Effect"</span>); <span class="hljs-string">"Hello!"</span> }
<span class="hljs-keyword">val</span> task = <span class="hljs-type">IO</span>.fromFuture(future)
<span class="hljs-comment">//=&gt; Effect</span>

task.runToFuture.foreach(println)
<span class="hljs-comment">//=&gt; Hello!</span>
task.runToFuture.foreach(println)
<span class="hljs-comment">//=&gt; Hello!</span>
</code></pre>
<p>Note that <code>fromFuture</code> takes a strict argument, and that may not be what you want.
When you receive a Future like this, whatever process that’s supposed to complete has probably started already.
You might want a factory of Future to be able to suspend its evaluation and reuse it.
The design of <code>IO</code> is to have fine-grained control over the evaluation model, so in case you want a factory,
you need to either combine it with <code>IO.defer</code> or use <code>IO.deferFuture</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">Future</span>

<span class="hljs-keyword">val</span> task = <span class="hljs-type">IO</span>.defer {
  <span class="hljs-keyword">val</span> future = <span class="hljs-type">Future</span> { println(<span class="hljs-string">"Effect"</span>); <span class="hljs-string">"Hello!"</span> }
  <span class="hljs-type">IO</span>.fromFuture(future)
}

task.runToFuture.foreach(println)
<span class="hljs-comment">//=&gt; Effect</span>
<span class="hljs-comment">//=&gt; Hello!</span>
task.runToFuture.foreach(println)
<span class="hljs-comment">//=&gt; Effect</span>
<span class="hljs-comment">//=&gt; Hello!</span>
</code></pre>
<p>Or use the equivalent:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> monix.execution.<span class="hljs-type">Scheduler</span>.<span class="hljs-type">Implicits</span>.global
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">Future</span>

<span class="hljs-keyword">val</span> task = <span class="hljs-type">IO</span>.deferFuture {
  <span class="hljs-type">Future</span> { println(<span class="hljs-string">"Effect"</span>); <span class="hljs-string">"Hello!"</span> }
}

task.runToFuture.foreach(println)
<span class="hljs-comment">//=&gt; Effect</span>
<span class="hljs-comment">//=&gt; Hello!</span>
task.runToFuture.foreach(println)
<span class="hljs-comment">//=&gt; Effect</span>
<span class="hljs-comment">//=&gt; Hello!</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="iodeferfutureaction"></a><a href="#iodeferfutureaction" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.deferFutureAction</h3>
<p><code>IO.deferFutureAction</code> wraps calls that generate Future results into Task,
provided a callback with an injected Scheduler to act as the necessary ExecutionContext.</p>
<p>This builder helps with wrapping Future-enabled APIs that need an implicit ExecutionContext to work.
Consider this example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.concurrent.{<span class="hljs-type">ExecutionContext</span>, <span class="hljs-type">Future</span>}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumFuture</span></span>(list: <span class="hljs-type">Seq</span>[<span class="hljs-type">Int</span>])(<span class="hljs-keyword">implicit</span> ec: <span class="hljs-type">ExecutionContext</span>): <span class="hljs-type">Future</span>[<span class="hljs-type">Int</span>] =
  <span class="hljs-type">Future</span>(list.sum)
</code></pre>
<p>We’d like to wrap this function into one that returns a lazy Task that evaluates this sum every time it is called because that’s how tasks work best. However, to invoke this function, an ExecutionContext is needed:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">Task</span>
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumTask</span></span>(list: <span class="hljs-type">Seq</span>[<span class="hljs-type">Int</span>])(<span class="hljs-keyword">implicit</span> ec: <span class="hljs-type">ExecutionContext</span>): <span class="hljs-type">Task</span>[<span class="hljs-type">Int</span>] =
  <span class="hljs-type">Task</span>.deferFuture(sumFuture(list))
</code></pre>
<p>But this is not only superfluous but against the best practices of using <code>IO</code>.
The difference is that Task takes a Scheduler (inheriting from ExecutionContext) only when the run gets called, but we don’t need it just for building a Task reference.
<code>IO</code> is aware that <code>Scheduler</code> will be supplied during execution, and it can access it any time.
With <code>deferFutureAction</code> or <code>deferAction</code> we get to have an injected Scheduler in the passed callback:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> monix.bio.<span class="hljs-type">Task</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumTask</span></span>(list: <span class="hljs-type">Seq</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">Task</span>[<span class="hljs-type">Int</span>] =
  <span class="hljs-type">Task</span>.deferFutureAction { <span class="hljs-keyword">implicit</span> scheduler =&gt;
    sumFuture(list)
  }
</code></pre>
<p>Voilà! No more implicit ExecutionContext passed around.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/getting-started"><span class="arrow-prev">← </span><span>Getting Started</span></a><a class="docs-next button" href="/docs/execution"><span>Executing IO</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#simple-builders">Simple builders</a><ul class="toc-headings"><li><a href="#ionow">IO.now</a></li><li><a href="#ioraiseerror">IO.raiseError</a></li><li><a href="#ioterminate">IO.terminate</a></li><li><a href="#ioeval--ioapply">IO.eval / IO.apply</a></li><li><a href="#ioevaltotal--uioapply">IO.evalTotal / UIO.apply</a></li><li><a href="#ioevalonce">IO.evalOnce</a></li><li><a href="#ionever">IO.never</a></li></ul></li><li><a href="#asynchronous-builders">Asynchronous builders</a><ul class="toc-headings"><li><a href="#ioevalasync">IO.evalAsync</a></li><li><a href="#iocreate">IO.create</a></li><li><a href="#iofromfuture">IO.fromFuture</a></li><li><a href="#iodeferfutureaction">IO.deferFutureAction</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><hr class="separator"/><section class="copyright">Copyright © 2019-2021 The Monix Project Developers.</section></footer></div></body></html>