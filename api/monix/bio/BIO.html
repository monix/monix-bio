<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Monix BIO 0.1.0 - monix.bio.BIO</title><meta content="Monix BIO 0.1.0 - monix.bio.BIO" name="description"/><meta content="Monix BIO 0.1.0 monix.bio.BIO" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title">Monix BIO<span id="doc-version">0.1.0</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title="This is the API documentation for the [Monix BIO](https://github.com/monix/monix-bio) library."><span class="name">root</span></a></span><p class="shortcomment cmt">This is the API documentation for the [Monix BIO](https://github.com/monix/monix-bio) library.</p><div class="fullcomment"><div class="comment cmt"><p>This is the API documentation for the [Monix BIO](https://github.com/monix/monix-bio) library.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.monix" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monix"></a><a id="monix:monix"></a> <span class="permalink"><a href="../../monix/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">monix</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="monix.bio" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bio"></a><a id="bio:bio"></a> <span class="permalink"><a href="../../monix/bio/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">bio</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="monix" id="monix" class="extype">monix</a></dd></dl></div></li><li class="indented3 " name="monix.bio.instances" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="instances"></a><a id="instances:instances"></a> <span class="permalink"><a href="../../monix/bio/instances/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="instances/index.html" title=""><span class="name">instances</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.bio" id="monix.bio" class="extype">bio</a></dd></dl></div></li><li class="current-entities indented2"><a href="BIO$.html" title="Builders for BIO." class="object"></a> <a href="" title="Task represents a specification for a possibly lazy or asynchronous computation, which when executed will produce an A as a result, along with possible side-effects." class="class"></a><a href="" title="Task represents a specification for a possibly lazy or asynchronous computation, which when executed will produce an A as a result, along with possible side-effects.">BIO</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="BIOApp.html" title="Safe App type that executes a BIO." class="trait"></a><a href="BIOApp.html" title="Safe App type that executes a BIO.">BIOApp</a></li><li class="current-entities indented2"><a href="BIOLocal$.html" title="Builders for BIOLocal" class="object"></a> <a href="BIOLocal.html" title="A BIOLocal is like a ThreadLocal that is pure and with a flexible scope, being processed in the context of the Task data type." class="class"></a><a href="BIOLocal.html" title="A BIOLocal is like a ThreadLocal that is pure and with a flexible scope, being processed in the context of the Task data type.">BIOLocal</a></li><li class="current-entities indented2"><a href="BiCallback$.html" title="" class="object"></a> <a href="BiCallback.html" title="Callback type which supports two channels of errors." class="class"></a><a href="BiCallback.html" title="Callback type which supports two channels of errors.">BiCallback</a></li><li class="current-entities indented2"><a href="Cause$.html" title="" class="object"></a> <a href="Cause.html" title="Represent a complete cause of the failed Task exposing both typed and untyped error channel." class="class"></a><a href="Cause.html" title="Represent a complete cause of the failed Task exposing both typed and untyped error channel.">Cause</a></li><li class="current-entities indented2"><a href="Fiber$.html" title="" class="object"></a> <a href="Fiber.html" title="Fiber represents the (pure) result of a BIO being started concurrently and that can be either joined or cancelled." class="trait"></a><a href="Fiber.html" title="Fiber represents the (pure) result of a BIO being started concurrently and that can be either joined or cancelled.">Fiber</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Task$.html" title="" class="object"></a><a href="Task$.html" title="">Task</a></li><li class="current-entities indented2"><a href="TaskLift$.html" title="" class="object"></a> <a href="TaskLift.html" title="A lawless type class that specifies conversions from Task to similar data types (i.e." class="trait"></a><a href="TaskLift.html" title="A lawless type class that specifies conversions from Task to similar data types (i.e.">TaskLift</a></li><li class="current-entities indented2"><a href="TaskLike$.html" title="" class="object"></a> <a href="TaskLike.html" title="A lawless type class that provides conversions into a Task." class="trait"></a><a href="TaskLike.html" title="A lawless type class that provides conversions into a Task.">TaskLike</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="UIO$.html" title="" class="object"></a><a href="UIO$.html" title="">UIO</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><a href="BIO$.html" title="See companion object"><div class="big-circle class-companion-object">c</div></a><p id="owner"><a href="../index.html" name="monix" id="monix" class="extype">monix</a>.<a href="index.html" name="monix.bio" id="monix.bio" class="extype">bio</a></p><h1><a href="BIO$.html" title="See companion object">BIO</a><span class="permalink"><a href="../../monix/bio/BIO.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"><div>Companion <a href="BIO$.html" title="See companion object">object BIO</a></div></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier">sealed abstract </span> <span class="kind">class</span></span> <span class="symbol"><span class="name">BIO</span><span class="tparams">[<span name="E">+E</span>, <span name="A">+A</span>]</span><span class="result"> extends <span name="scala.Serializable" class="extype">Serializable</span></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p><code>Task</code> represents a specification for a possibly lazy or
asynchronous computation, which when executed will produce an <code>A</code>
as a result, along with possible side-effects.</p><p>Compared with <code>Future</code> from Scala's standard library, <code>Task</code> does
not represent a running computation or a value detached from time,
as <code>Task</code> does not execute anything when working with its builders
or operators and it does not submit any work into any thread-pool,
the execution eventually taking place only after <code>runAsync</code> is
called and not before that.</p><p>Note that <code>Task</code> is conservative in how it spawns logical threads.
Transformations like <code>map</code> and <code>flatMap</code> for example will default
to being executed on the logical thread on which the asynchronous
computation was started. But one shouldn't make assumptions about
how things will end up executed, as ultimately it is the
implementation's job to decide on the best execution model. All
you are guaranteed is asynchronous execution after executing
<code>runAsync</code>.</p><h3>Getting Started</h3><p>To build a <code>BIO</code> from a by-name parameters (thunks), we can use
<a href="BIO$.html#apply[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.BIO#apply" id="monix.bio.BIO#apply" class="extmbr">BIO.apply</a> (
alias <a href="BIO$.html#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.BIO#eval" id="monix.bio.BIO#eval" class="extmbr">BIO.eval</a>),
<a href="BIO$.html#evalTotal[A](a:=&gt;A):monix.bio.UIO[A]" name="monix.bio.BIO#evalTotal" id="monix.bio.BIO#evalTotal" class="extmbr">monix.bio.BIO.evalTotal</a> if the thunk is guaranteed to not throw any exceptions, or
<a href="BIO$.html#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.BIO#evalAsync" id="monix.bio.BIO#evalAsync" class="extmbr">BIO.evalAsync</a>:</p><pre><span class="kw">val</span> hello = BIO(<span class="lit">"Hello "</span>)
<span class="kw">val</span> world = BIO.evalAsync(<span class="lit">"World!"</span>)</pre><p>Nothing gets executed yet, as <code>BIO</code> is lazy, nothing executes
until you trigger its evaluation via <a href="#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.BIO#runAsync" id="monix.bio.BIO#runAsync" class="extmbr">runAsync</a> or
<a href="#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.BIO#runToFuture" id="monix.bio.BIO#runToFuture" class="extmbr">runToFuture</a>.</p><p>To combine <code>BIO</code> values we can use <a href="#map[B](f:A=&gt;B):monix.bio.BIO[E,B]" name="monix.bio.BIO#map" id="monix.bio.BIO#map" class="extmbr">.map</a> and
<a href="#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#flatMap" id="monix.bio.BIO#flatMap" class="extmbr">.flatMap</a>, which describe sequencing and this time
it's in a very real sense because of the laziness involved:</p><pre><span class="kw">val</span> sayHello = hello
  .flatMap(h <span class="kw">=&gt;</span> world.map(w <span class="kw">=&gt;</span> h + w))
  .map(println)</pre><p>This <code>BIO</code> reference will trigger a side effect on evaluation, but
not yet. To make the above print its message:</p><pre><span class="kw">import</span> monix.execution.CancelableFuture
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="kw">val</span> f = sayHello.runToFuture
<span class="cmt">// =&gt; Hello World!</span></pre><p>The returned type is a
<a href="https://monix.io/api/3.1/monix/execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a> which
inherits from Scala's standard <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>,
a value that can be completed already or might be completed at
some point in the future, once the running asynchronous process
finishes. Such a future value can also be canceled, see below.</p><h3>Laziness, Purity and Referential Transparency</h3><p>The fact that <code>Task</code> is lazy whereas <code>Future</code> is not
has real consequences. For example with <code>Task</code> you can do this:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="kw">def</span> retryOnFailure[A](times: <span class="std">Int</span>, source: Task[A]): Task[A] =
  source.onErrorHandleWith { err <span class="kw">=&gt;</span>
    <span class="cmt">// No more retries left? Re-throw error:</span>
    <span class="kw">if</span> (times &lt;= <span class="num">0</span>) Task.raiseError(err) <span class="kw">else</span> {
      <span class="cmt">// Recursive call, yes we can!</span>
      retryOnFailure(times - <span class="num">1</span>, source)
        <span class="cmt">// Adding 500 ms delay for good measure</span>
        .delayExecution(<span class="num">500.</span>millis)
    }
  }</pre><p><code>Future</code> being a strict value-wannabe means that the actual value
gets "memoized" (means cached), however <code>Task</code> is basically a function
that can be repeated for as many times as you want.</p><p><code>Task</code> is a pure data structure that can be used to describe
pure functions, the equivalent of Haskell's <code>IO</code>.</p><h4>Memoization</h4><p><code>Task</code> can also do memoization, making it behave like a "lazy"
Scala <code>Future</code>, meaning that nothing is started yet, its
side effects being evaluated on the first <code>runAsync</code> and then
the result reused on subsequent evaluations:</p><pre>Task(println(<span class="lit">"boo"</span>)).memoize</pre><p>The difference between this and just calling <code>runAsync()</code> is that
<code>memoize()</code> still returns a <code>Task</code> and the actual memoization
happens on the first <code>runAsync()</code> (with idempotency guarantees of
course).</p><p>But here's something else that the <code>Future</code> data type cannot do,
<a href="#memoizeOnSuccess:monix.bio.BIO[E,A]" name="monix.bio.BIO#memoizeOnSuccess" id="monix.bio.BIO#memoizeOnSuccess" class="extmbr">memoizeOnSuccess</a>:</p><pre>Task.eval {
  <span class="kw">if</span> (scala.util.Random.nextDouble() &gt; <span class="num">0.33</span>)
    <span class="kw">throw</span> <span class="kw">new</span> RuntimeException(<span class="lit">"error!"</span>)
  println(<span class="lit">"moo"</span>)
}.memoizeOnSuccess</pre><p>This keeps repeating the computation for as long as the result is a
failure and caches it only on success. Yes we can!</p><p><i>WARNING:</i> as awesome as <code>memoize</code> can be, use with care
because memoization can break referential transparency!</p><h4>Parallelism</h4><p>Because of laziness, invoking
<a href="BIO$.html#sequence[E,A,M[X]&lt;:Iterable[X]](in:M[monix.bio.BIO[E,A]])(implicitbf:monix.execution.compat.BuildFrom[M[monix.bio.BIO[E,A]],A,M[A]]):monix.bio.BIO[E,M[A]]" name="monix.bio.BIO#sequence" id="monix.bio.BIO#sequence" class="extmbr">BIO.sequence</a> will not work like
it does for <code>Future.sequence</code>, the given <code>Task</code> values being
evaluated one after another, in <i>sequence</i>, not in <i>parallel</i>.
If you want parallelism, then you need to use
<a href="BIO$.html#parSequence[E,A,M[X]&lt;:Iterable[X]](in:M[monix.bio.BIO[E,A]])(implicitbf:monix.execution.compat.BuildFrom[M[monix.bio.BIO[E,A]],A,M[A]]):monix.bio.BIO[E,M[A]]" name="monix.bio.BIO#parSequence" id="monix.bio.BIO#parSequence" class="extmbr">BIO.parSequence</a> and thus be explicit about it.</p><p>This is great because it gives you the possibility of fine tuning the
execution. For example, say you want to execute things in parallel,
but with a maximum limit of 30 tasks being executed in parallel.
One way of doing that is to process your list in batches:</p><pre><span class="cmt">// Some array of tasks, you come up with something good :-)</span>
<span class="kw">val</span> list: <span class="std">Seq</span>[Task[<span class="std">Int</span>]] = <span class="std">Seq</span>.tabulate(<span class="num">100</span>)(Task(_))

<span class="cmt">// Split our list in chunks of 30 items per chunk,</span>
<span class="cmt">// this being the maximum parallelism allowed</span>
<span class="kw">val</span> chunks = list.sliding(<span class="num">30</span>, <span class="num">30</span>).toSeq

<span class="cmt">// Specify that each batch should process stuff in parallel</span>
<span class="kw">val</span> batchedTasks = chunks.map(chunk <span class="kw">=&gt;</span> Task.parSequence(chunk))
<span class="cmt">// Sequence the batches</span>
<span class="kw">val</span> allBatches = Task.sequence(batchedTasks)

<span class="cmt">// Flatten the result, within the context of Task</span>
<span class="kw">val</span> all: Task[<span class="std">Seq</span>[<span class="std">Int</span>]] = allBatches.map(_.flatten)</pre><p>Note that the built <code>Task</code> reference is just a specification at
this point, or you can view it as a function, as nothing has
executed yet, you need to call <a href="#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.BIO#runAsync" id="monix.bio.BIO#runAsync" class="extmbr">runAsync</a>
or <a href="#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.BIO#runToFuture" id="monix.bio.BIO#runToFuture" class="extmbr">runToFuture</a> explicitly.</p><h3>Cancellation</h3><p>The logic described by an <code>Task</code> task could be cancelable,
depending on how the <code>Task</code> gets built.</p><p><a href="https://monix.io/api/3.1/monix/execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a> references
can also be canceled, in case the described computation can be
canceled. When describing <code>Task</code> tasks with <code>Task.eval</code> nothing
can be cancelled, since there's nothing about a plain function
that you can cancel, but we can build cancelable tasks with
<a href="BIO$.html#cancelable0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;cats.effect.CancelToken[[β$1$]monix.bio.BIO[E,β$1$]]):monix.bio.BIO[E,A]" name="monix.bio.BIO#cancelable0" id="monix.bio.BIO#cancelable0" class="extmbr">BIO.cancelable</a>.</p><pre><span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> scala.util._

<span class="kw">val</span> delayedHello = Task.cancelable0[<span class="std">Unit</span>] { (scheduler, callback) <span class="kw">=&gt;</span>
  <span class="kw">val</span> task = scheduler.scheduleOnce(<span class="num">1.</span>second) {
    println(<span class="lit">"Delayed Hello!"</span>)
    <span class="cmt">// Signaling successful completion</span>
    callback(Success(()))
  }
  <span class="cmt">// Returning a cancel token that knows how to cancel the</span>
  <span class="cmt">// scheduled computation:</span>
  Task {
    println(<span class="lit">"Cancelling!"</span>)
    task.cancel()
  }
}</pre><p>The sample above prints a message with a delay, where the delay
itself is scheduled with the injected <code>Scheduler</code>. The <code>Scheduler</code>
is in fact an implicit parameter to <code>runAsync()</code>.</p><p>This action can be cancelled, because it specifies cancellation
logic. In case we have no cancelable logic to express, then it's
OK if we returned a
<a href="https://monix.io/api/3.1/monix/execution/Cancelable$.html#empty:monix.execution.Cancelable" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable.empty</a> reference,
in which case the resulting <code>Task</code> would not be cancelable.</p><p>But the <code>Task</code> we just described is cancelable, for one at the
edge, due to <code>runAsync</code> returning <a href="https://monix.io/api/3.1/monix/execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a>
and <a href="https://monix.io/api/3.1/monix/execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a> references:</p><pre><span class="cmt">// Triggering execution</span>
<span class="kw">val</span> cf = delayedHello.runToFuture

<span class="cmt">// If we change our mind before the timespan has passed:</span>
cf.cancel()</pre><p>But also cancellation is described on <code>Task</code> as a pure action,
which can be used for example in <a href="BIO$.html#race[E,A,B](fa:monix.bio.BIO[E,A],fb:monix.bio.BIO[E,B]):monix.bio.BIO[E,Either[A,B]]" name="monix.bio.BIO#race" id="monix.bio.BIO#race" class="extmbr">race</a> conditions:</p><pre><span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> scala.concurrent.TimeoutException

<span class="kw">val</span> ta = Task(<span class="num">1</span> + <span class="num">1</span>).delayExecution(<span class="num">4.</span>seconds)

<span class="kw">val</span> tb = Task.raiseError[<span class="std">Int</span>](<span class="kw">new</span> TimeoutException)
  .delayExecution(<span class="num">4.</span>seconds)

Task.racePair(ta, tb).flatMap {
  <span class="kw">case</span> Left((a, fiberB)) <span class="kw">=&gt;</span>
    fiberB.cancel.map(_ <span class="kw">=&gt;</span> a)
  <span class="kw">case</span> Right((fiberA, b)) <span class="kw">=&gt;</span>
    fiberA.cancel.map(_ <span class="kw">=&gt;</span> b)
}</pre><p>The returned type in <code>racePair</code> is <a href="Fiber.html" name="monix.bio.Fiber" id="monix.bio.Fiber" class="extype">Fiber</a>, which is a data
type that's meant to wrap tasks linked to an active process
and that can be <a href="Fiber.html#cancel:cats.effect.CancelToken[monix.bio.UIO]" name="monix.bio.Fiber#cancel" id="monix.bio.Fiber#cancel" class="extmbr">canceled</a> or <a href="Fiber.html#join:monix.bio.BIO[E,A]" name="monix.bio.Fiber#join" id="monix.bio.Fiber#join" class="extmbr">joined</a>.</p><p>Also, given a task, we can specify actions that need to be
triggered in case of cancellation, see
<a href="#doOnCancel(callback:monix.bio.UIO[Unit]):monix.bio.BIO[E,A]" name="monix.bio.BIO#doOnCancel" id="monix.bio.BIO#doOnCancel" class="extmbr">doOnCancel</a>:</p><pre><span class="kw">val</span> task = Task.eval(println(<span class="lit">"Hello!"</span>)).executeAsync

task doOnCancel BIO.evalTotal {
  println(<span class="lit">"A cancellation attempt was made!"</span>)
}</pre><p>Given a task, we can also create a new task from it that atomic
(non cancelable), in the sense that either all of it executes
or nothing at all, via <a href="#uncancelable:monix.bio.BIO[E,A]" name="monix.bio.BIO#uncancelable" id="monix.bio.BIO#uncancelable" class="extmbr">uncancelable</a>.</p><h3>Note on the ExecutionModel</h3><p><code>Task</code> is conservative in how it introduces async boundaries.
Transformations like <code>map</code> and <code>flatMap</code> for example will default
to being executed on the current call stack on which the
asynchronous computation was started. But one shouldn't make
assumptions about how things will end up executed, as ultimately
it is the implementation's job to decide on the best execution
model. All you are guaranteed (and can assume) is asynchronous
execution after executing <code>runAsync</code>.</p><p>Currently the default
<a href="https://monix.io/api/3.1/monix/execution/ExecutionModel.html" name="monix.execution.ExecutionModel" id="monix.execution.ExecutionModel" class="extype">ExecutionModel</a> specifies
batched execution by default and <code>Task</code> in its evaluation respects
the injected <code>ExecutionModel</code>. If you want a different behavior,
you need to execute the <code>Task</code> reference with a different scheduler.</p></div><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/monix/monix-bio/tree/v0.1.0/core/shared/src/main/scala/monix/bio/BIO.scala" target="_blank">BIO.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><span name="java.io.Serializable" class="extype">Serializable</span>, <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="monix.bio.BIO"><span>BIO</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##():Int"></a> <span class="permalink"><a href="../../monix/bio/BIO.html###():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#&gt;&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&gt;&gt;[E1&gt;:E,B](tb:=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]"></a><a id="&gt;&gt;[E1&gt;:E,B](=&gt;BIO[E1,B]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#&gt;&gt;[E1&gt;:E,B](tb:=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $greater$greater">&gt;&gt;</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="tb">tb: =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.&gt;&gt;.E1" class="extype">E1</span>, <span name="monix.bio.BIO.&gt;&gt;.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.&gt;&gt;.E1" class="extype">E1</span>, <span name="monix.bio.BIO.&gt;&gt;.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Runs this task first and then, when successful, the given task.</p><div class="fullcomment"><div class="comment cmt"><p>Runs this task first and then, when successful, the given task.
Returns the result of the given task.</p><p>Example:</p><pre><span class="kw">val</span> combined = Task{println(<span class="lit">"first"</span>); <span class="lit">"first"</span>} &gt;&gt; Task{println(<span class="lit">"second"</span>); <span class="lit">"second"</span>}
<span class="cmt">// Prints "first" and then "second"</span>
<span class="cmt">// Result value will be "second"</span></pre></div></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#asyncBoundary" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asyncBoundary(s:monix.execution.Scheduler):monix.bio.BIO[E,A]"></a><a id="asyncBoundary(Scheduler):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#asyncBoundary(s:monix.execution.Scheduler):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asyncBoundary</span><span class="params">(<span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Introduces an asynchronous boundary at the current stage in the
asynchronous processing pipeline, making processing to jump on
the given <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> (until the
next async boundary).</p><div class="fullcomment"><div class="comment cmt"><p>Introduces an asynchronous boundary at the current stage in the
asynchronous processing pipeline, making processing to jump on
the given <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> (until the
next async boundary).</p><p>Consider the following example:</p><pre><span class="kw">import</span> monix.execution.Scheduler

<span class="kw">implicit</span> <span class="kw">val</span> s = Scheduler.global
<span class="kw">val</span> io = Scheduler.io()

<span class="kw">val</span> source = BIO(<span class="num">1</span>) <span class="cmt">// s</span>
  .asyncBoundary(io)
  .flatMap(_ <span class="kw">=&gt;</span> BIO(<span class="num">2</span>)) <span class="cmt">// io</span>
  .flatMap(_ <span class="kw">=&gt;</span> BIO(<span class="num">3</span>)) <span class="cmt">// io</span>
  .asyncBoundary
  .flatMap(_ <span class="kw">=&gt;</span> BIO(<span class="num">4</span>))  <span class="cmt">// s</span></pre><p>If <code>Scheduler s</code> is passed implicitly when running the <code>BIO</code>, <code>BIO(1)</code>
will be executed there. Then it will switch to <code>io</code> for <code>BIO(2)</code> and <code>BIO(3)</code>.
<code>asyncBoundary</code> without any arguments returns to the default <code>Scheduler</code> so <code>BIO(4)</code>
will be executed there.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is the scheduler triggering the asynchronous boundary</p></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#asyncBoundary" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asyncBoundary:monix.bio.BIO[E,A]"></a><a id="asyncBoundary:BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#asyncBoundary:monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asyncBoundary</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Introduces an asynchronous boundary at the current stage in the
asynchronous processing pipeline.</p><div class="fullcomment"><div class="comment cmt"><p>Introduces an asynchronous boundary at the current stage in the
asynchronous processing pipeline.</p><p>The <code>BIO</code> will be returned to the default <code>Scheduler</code> to
reschedule the rest of its execution.</p><p>Consider the following example:</p><pre><span class="kw">import</span> monix.execution.ExecutionModel.SynchronousExecution
<span class="kw">import</span> monix.execution.Scheduler

<span class="kw">val</span> s = Scheduler.singleThread(<span class="lit">"example-scheduler"</span>).withExecutionModel(SynchronousExecution)

<span class="kw">val</span> source1 = BIO(println(<span class="lit">"task 1"</span>)).loopForever
<span class="kw">val</span> source2 = BIO(println(<span class="lit">"task 2"</span>)).loopForever

<span class="cmt">// Will keep printing only "task 1" or "task 2"</span>
<span class="cmt">// depending on which one was scheduled first</span>
<span class="cmt">// doctodo BIO.parZip2(source1, source2)</span></pre><p>We might expect that both <code>source1</code> and <code>source2</code> would execute
concurrently but since we are using only 1 thread with
<a href="https://monix.io/api/3.1/monix/execution/ExecutionModel$$SynchronousExecution$.html" name="monix.execution.ExecutionModel.SynchronousExecution" id="monix.execution.ExecutionModel.SynchronousExecution" class="extype">SynchronousExecution</a>
execution model, one of them will be scheduled first and then run forever.</p><p>To prevent this behavior we could introduce asynchronous boundary
after each iteration, i.e.:</p><pre><span class="kw">val</span> source3 = BIO(println(<span class="lit">"task 1"</span>)).asyncBoundary.loopForever
<span class="kw">val</span> source4 = BIO(println(<span class="lit">"task 2"</span>)).asyncBoundary.loopForever

<span class="cmt">// Will keep printing "task 1" and "task 2" alternately.</span>
<span class="cmt">// doctodo BIO.parZip2(source3, source4)</span></pre><p>A lot of asynchronous boundaries can lead to unnecessary overhead so in the
majority of cases it is enough to use the default <code>ExecutionModel</code> which
introduces asynchronous boundaries between <code>flatMap</code> periodically on its own.</p><p>Likelihood that different tasks are able to advance is called <code>fairness</code>.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#executeOn(s:monix.execution.Scheduler,forceAsync:Boolean):monix.bio.BIO[E,A]" name="monix.bio.BIO#executeOn" id="monix.bio.BIO#executeOn" class="extmbr">BIO.executeOn</a> for a way to override the default <code>Scheduler</code></p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#attempt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="attempt:monix.bio.UIO[Either[E,A]]"></a><a id="attempt:UIO[Either[E,A]]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#attempt:monix.bio.UIO[Either[E,A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">attempt</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Creates a new <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a> that will expose any triggered typed
errors from the source.</p></li><li class="indented0 " name="monix.bio.BIO#bimap" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="bimap[E1,B](fe:E=&gt;E1,fa:A=&gt;B):monix.bio.BIO[E1,B]"></a><a id="bimap[E1,B]((E)=&gt;E1,(A)=&gt;B):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#bimap[E1,B](fe:E=&gt;E1,fa:A=&gt;B):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bimap</span><span class="tparams">[<span name="E1">E1</span>, <span name="B">B</span>]</span><span class="params">(<span name="fe">fe: (<span name="monix.bio.BIO.E" class="extype">E</span>) =&gt; <span name="monix.bio.BIO.bimap.E1" class="extype">E1</span></span>, <span name="fa">fa: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <span name="monix.bio.BIO.bimap.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.bimap.E1" class="extype">E1</span>, <span name="monix.bio.BIO.bimap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new <code>BIO</code> that applies the mapping function <code>fa</code> to the
success channel and <code>fe</code> to the error channel.</p></li><li class="indented0 " name="monix.bio.BIO#bracket" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracket[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:A=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]"></a><a id="bracket[E1&gt;:E,B]((A)=&gt;BIO[E1,B])((A)=&gt;UIO[Unit]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#bracket[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:A=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracket</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.bracket.E1" class="extype">E1</span>, <span name="monix.bio.BIO.bracket.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.bracket.E1" class="extype">E1</span>, <span name="monix.bio.BIO.bracket.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a task that treats the source task as the acquisition of a resource,
which is then exploited by the <code>use</code> function and then <code>released</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a task that treats the source task as the acquisition of a resource,
which is then exploited by the <code>use</code> function and then <code>released</code>.</p><p>The <code>bracket</code> operation is the equivalent of the
<code>try {} catch {} finally {}</code> statements from mainstream languages.</p><p>The <code>bracket</code> operation installs the necessary exception handler to release
the resource in the event of an exception being raised during the computation,
or in case of cancellation.</p><p>If an exception is raised, then <code>bracket</code> will re-raise the exception
<i>after</i> performing the <code>release</code>. If the resulting task gets cancelled,
then <code>bracket</code> will still perform the <code>release</code>, but the yielded task
will be non-terminating (equivalent with <a href="BIO$.html#never[A]:monix.bio.UIO[A]" name="monix.bio.BIO#never" id="monix.bio.BIO#never" class="extmbr">BIO.never</a>).</p><p>Example:</p><pre><span class="kw">import</span> java.io._

<span class="kw">def</span> readFile(file: File): Task[<span class="std">String</span>] = {
  <span class="cmt">// Opening a file handle for reading text</span>
  <span class="kw">val</span> acquire = Task.eval(<span class="kw">new</span> BufferedReader(
    <span class="kw">new</span> InputStreamReader(<span class="kw">new</span> FileInputStream(file), <span class="lit">"utf-8"</span>)
  ))

  acquire.bracket { in <span class="kw">=&gt;</span>
    <span class="cmt">// Usage part</span>
    Task.eval {
      <span class="cmt">// Yes, ugly Java, non-FP loop;</span>
      <span class="cmt">// side-effects are suspended though</span>
      <span class="kw">var</span> line: <span class="std">String</span> = <span class="kw">null</span>
      <span class="kw">val</span> buff = <span class="kw">new</span> StringBuilder()
      <span class="kw">do</span> {
        line = in.readLine()
        <span class="kw">if</span> (line != <span class="kw">null</span>) buff.append(line)
      } <span class="kw">while</span> (line != <span class="kw">null</span>)
      buff.toString()
    }
  } { in <span class="kw">=&gt;</span>
    <span class="cmt">// The release part</span>
    UIO(in.close())
  }
}</pre><p>Note that in case of cancellation the underlying implementation cannot
guarantee that the computation described by <code>use</code> doesn't end up
executed concurrently with the computation from <code>release</code>. In the example
above that ugly Java loop might end up reading from a <code>BufferedReader</code>
that is already closed due to the task being cancelled, thus triggering
an error in the background with nowhere to go but in
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#reportFailure(t:Throwable):Unit" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler.reportFailure</a>.</p><p>In this particular example, given that we are just reading from a file,
it doesn't matter. But in other cases it might matter, as concurrency
on top of the JVM when dealing with I/O might lead to corrupted data.</p><p>For those cases you might want to do synchronization (e.g. usage of
locks and semaphores) and you might want to use <a href="#bracketE[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,Either[Option[monix.bio.Cause[E1]],B])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracketE" id="monix.bio.BIO#bracketE" class="extmbr">bracketE</a>, the
version that allows you to differentiate between normal termination
and cancellation.</p><p><b>NOTE on error handling</b>: one big
        difference versus <code>try {} finally {}</code> is that, in case
        both the <code>release</code> function and the <code>use</code> function throws,
        the error raised by <code>use</code> gets signaled and the error
        raised by <code>release</code> gets reported with
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#reportFailure(t:Throwable):Unit" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler.reportFailure</a>.</p><p>        For example:</p><pre>BIO.evalAsync(<span class="lit">"resource"</span>).bracket { _ <span class="kw">=&gt;</span>
  <span class="cmt">// use</span>
  BIO.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Foo"</span>))
} { _ <span class="kw">=&gt;</span>
  <span class="cmt">// release</span>
  BIO.terminate(<span class="kw">new</span> RuntimeException(<span class="lit">"Bar"</span>))
}</pre><p>        In this case the error signaled downstream is <code>"Foo"</code>,
        while the <code>"Bar"</code> error gets reported. This is consistent
        with the behavior of Haskell's <code>bracket</code> operation and NOT
        with <code>try {} finally {}</code> from Scala, Java or JavaScript.</p></div><dl class="paramcmts block"><dt class="param">use</dt><dd class="cmt"><p>is a function that evaluates the resource yielded by the source,
       yielding a result that will get generated by the task returned
       by this <code>bracket</code> function</p></dd><dt class="param">release</dt><dd class="cmt"><p>is a function that gets called after <code>use</code> terminates,
       either normally or in error, or if it gets cancelled, receiving
       as input the resource that needs to be released</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#bracketCase[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,cats.effect.ExitCase[monix.bio.Cause[E1]])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracketCase" id="monix.bio.BIO#bracketCase" class="extmbr">bracketCase</a> and <a href="#bracketE[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,Either[Option[monix.bio.Cause[E1]],B])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracketE" id="monix.bio.BIO#bracketE" class="extmbr">bracketE</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#bracketCase" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracketCase[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,cats.effect.ExitCase[monix.bio.Cause[E1]])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]"></a><a id="bracketCase[E1&gt;:E,B]((A)=&gt;BIO[E1,B])((A,ExitCase[Cause[E1]])=&gt;UIO[Unit]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#bracketCase[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,cats.effect.ExitCase[monix.bio.Cause[E1]])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracketCase</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.bracketCase.E1" class="extype">E1</span>, <span name="monix.bio.BIO.bracketCase.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.bio.BIO.A" class="extype">A</span>, <a href="https://typelevel.org/cats-effect/api/cats/effect/ExitCase.html#cats.effect.ExitCase" name="cats.effect.ExitCase" id="cats.effect.ExitCase" class="extype">ExitCase</a>[<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BIO.bracketCase.E1" class="extype">E1</span>]]) =&gt; <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.bracketCase.E1" class="extype">E1</span>, <span name="monix.bio.BIO.bracketCase.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new task that treats the source task as the
acquisition of a resource, which is then exploited by the <code>use</code>
function and then <code>released</code>, with the possibility of
distinguishing between normal termination and cancelation, such
that an appropriate release of resources can be executed.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new task that treats the source task as the
acquisition of a resource, which is then exploited by the <code>use</code>
function and then <code>released</code>, with the possibility of
distinguishing between normal termination and cancelation, such
that an appropriate release of resources can be executed.</p><p>The <code>bracketCase</code> operation is the equivalent of
<code>try {} catch {} finally {}</code> statements from mainstream languages
when used for the acquisition and release of resources.</p><p>The <code>bracketCase</code> operation installs the necessary exception handler
to release the resource in the event of an exception being raised
during the computation, or in case of cancelation.</p><p>In comparison with the simpler <a href="#bracket[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:A=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracket" id="monix.bio.BIO#bracket" class="extmbr">bracket</a> version, this one
allows the caller to differentiate between normal termination,
termination in error and cancelation via an <code>ExitCase</code>
parameter.
</p></div><dl class="paramcmts block"><dt class="param">use</dt><dd class="cmt"><p>is a function that evaluates the resource yielded by
       the source, yielding a result that will get generated by
       this function on evaluation</p></dd><dt class="param">release</dt><dd class="cmt"><p>is a function that gets called after <code>use</code>
       terminates, either normally or in error, or if it gets
       canceled, receiving as input the resource that needs that
       needs release, along with the result of <code>use</code>
       (cancelation, error or successful result)</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#bracket[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:A=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracket" id="monix.bio.BIO#bracket" class="extmbr">bracket</a> and <a href="#bracketE[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,Either[Option[monix.bio.Cause[E1]],B])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracketE" id="monix.bio.BIO#bracketE" class="extmbr">bracketE</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#bracketE" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracketE[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,Either[Option[monix.bio.Cause[E1]],B])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]"></a><a id="bracketE[E1&gt;:E,B]((A)=&gt;BIO[E1,B])((A,Either[Option[Cause[E1]],B])=&gt;UIO[Unit]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#bracketE[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,Either[Option[monix.bio.Cause[E1]],B])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracketE</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.bracketE.E1" class="extype">E1</span>, <span name="monix.bio.BIO.bracketE.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.bio.BIO.A" class="extype">A</span>, <span name="scala.Either" class="extype">Either</span>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BIO.bracketE.E1" class="extype">E1</span>]], <span name="monix.bio.BIO.bracketE.B" class="extype">B</span>]) =&gt; <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.bracketE.E1" class="extype">E1</span>, <span name="monix.bio.BIO.bracketE.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a task that treats the source task as the acquisition of a resource,
which is then exploited by the <code>use</code> function and then <code>released</code>, with
the possibility of distinguishing between normal termination and cancellation,
such that an appropriate release of resources can be executed.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a task that treats the source task as the acquisition of a resource,
which is then exploited by the <code>use</code> function and then <code>released</code>, with
the possibility of distinguishing between normal termination and cancellation,
such that an appropriate release of resources can be executed.</p><p>The <code>bracketE</code> operation is the equivalent of <code>try {} catch {} finally {}</code>
statements from mainstream languages.</p><p>The <code>bracketE</code> operation installs the necessary exception handler to release
the resource in the event of an exception being raised during the computation,
or in case of cancellation.</p><p>In comparison with the simpler <a href="#bracket[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:A=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracket" id="monix.bio.BIO#bracket" class="extmbr">bracket</a> version, this one allows the
caller to differentiate between normal termination and cancellation.</p><p>The <code>release</code> function receives as input:</p><ul><li><code>Left(None)</code> in case of cancellation</li><li><code>Left(Some(error))</code> in case <code>use</code> terminated with an error</li><li><code>Right(b)</code> in case of success</li></ul><p><b>NOTE on error handling</b>: one big
        difference versus <code>try {} finally {}</code> is that, in case
        both the <code>release</code> function and the <code>use</code> function throws,
        the error raised by <code>use</code> gets signaled and the error
        raised by <code>release</code> gets reported with
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#reportFailure(t:Throwable):Unit" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler.reportFailure</a>.</p><p>        For example:</p><pre>BIO.evalAsync(<span class="lit">"resource"</span>).bracket { _ <span class="kw">=&gt;</span>
  <span class="cmt">// use</span>
  BIO.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Foo"</span>))
} { _ <span class="kw">=&gt;</span>
  <span class="cmt">// release</span>
  BIO.terminate(<span class="kw">new</span> RuntimeException(<span class="lit">"Bar"</span>))
}</pre><p>        In this case the error signaled downstream is <code>"Foo"</code>,
        while the <code>"Bar"</code> error gets reported. This is consistent
        with the behavior of Haskell's <code>bracket</code> operation and NOT
        with <code>try {} finally {}</code> from Scala, Java or JavaScript.</p></div><dl class="paramcmts block"><dt class="param">use</dt><dd class="cmt"><p>is a function that evaluates the resource yielded by the source,
       yielding a result that will get generated by this function on
       evaluation</p></dd><dt class="param">release</dt><dd class="cmt"><p>is a function that gets called after <code>use</code> terminates,
       either normally or in error, or if it gets cancelled, receiving
       as input the resource that needs that needs release, along with
       the result of <code>use</code> (cancellation, error or successful result)</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#bracket[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:A=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracket" id="monix.bio.BIO#bracket" class="extmbr">bracket</a> and <a href="#bracketCase[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,cats.effect.ExitCase[monix.bio.Cause[E1]])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracketCase" id="monix.bio.BIO#bracketCase" class="extmbr">bracketCase</a></p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#delayExecution" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="delayExecution(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.BIO[E,A]"></a><a id="delayExecution(FiniteDuration):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#delayExecution(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">delayExecution</span><span class="params">(<span name="timespan">timespan: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a task that waits for the specified <code>timespan</code> before
executing and mirroring the result of the source.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a task that waits for the specified <code>timespan</code> before
executing and mirroring the result of the source.</p><p>In this example we're printing to standard output, but before
doing that we're introducing a 3 seconds delay:</p><pre><span class="kw">import</span> scala.concurrent.duration._

Task(println(<span class="lit">"Hello!"</span>))
  .delayExecution(<span class="num">3.</span>seconds)</pre><p>This operation is also equivalent with:</p><pre>Task.sleep(<span class="num">3.</span>seconds).flatMap(_ <span class="kw">=&gt;</span> Task(println(<span class="lit">"Hello!"</span>)))</pre><p>See <a href="BIO$.html#sleep(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.UIO[Unit]" name="monix.bio.BIO#sleep" id="monix.bio.BIO#sleep" class="extmbr">BIO.sleep</a> for the operation that describes the effect
and <a href="#delayResult(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.BIO[E,A]" name="monix.bio.BIO#delayResult" id="monix.bio.BIO#delayResult" class="extmbr">BIO.delayResult</a> for the version that evaluates the
task on time, but delays the signaling of the result.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>is the time span to wait before triggering
       the evaluation of the task</p></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#delayResult" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="delayResult(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.BIO[E,A]"></a><a id="delayResult(FiniteDuration):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#delayResult(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">delayResult</span><span class="params">(<span name="timespan">timespan: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a task that executes the source immediately on <code>runAsync</code>,
but before emitting the <code>onSuccess</code> result for the specified
duration.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a task that executes the source immediately on <code>runAsync</code>,
but before emitting the <code>onSuccess</code> result for the specified
duration.</p><p>Note that if an error happens, then it is streamed immediately
with no delay.</p><p>See <a href="#delayExecution(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.BIO[E,A]" name="monix.bio.BIO#delayExecution" id="monix.bio.BIO#delayExecution" class="extmbr">delayExecution</a> for delaying the evaluation of the
task with the specified duration. The <a href="#delayResult(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.BIO[E,A]" name="monix.bio.BIO#delayResult" id="monix.bio.BIO#delayResult" class="extmbr">delayResult</a> operation
is effectively equivalent with:</p><pre><span class="kw">import</span> scala.concurrent.duration._

Task(<span class="num">1</span> + <span class="num">1</span>)
  .flatMap(a <span class="kw">=&gt;</span> Task.now(a).delayExecution(<span class="num">3.</span>seconds))</pre><p>Or if we are to use the <a href="BIO$.html#sleep(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.UIO[Unit]" name="monix.bio.BIO#sleep" id="monix.bio.BIO#sleep" class="extmbr">BIO.sleep</a> describing just the
effect, this operation is equivalent with:</p><pre>Task(<span class="num">1</span> + <span class="num">1</span>).flatMap(a <span class="kw">=&gt;</span> Task.sleep(<span class="num">3.</span>seconds).map(_ <span class="kw">=&gt;</span> a))</pre><p>Thus in this example 3 seconds will pass before the result
is being generated by the source, plus another 5 seconds
before it is finally emitted:</p><pre>Task(<span class="num">1</span> + <span class="num">1</span>)
  .delayExecution(<span class="num">3.</span>seconds)
  .delayResult(<span class="num">5.</span>seconds)</pre></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>is the time span to sleep before signaling
       the result, but after the evaluation of the source</p></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#dematerialize" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="dematerialize[B](implicitevE:E&lt;:&lt;Nothing,implicitevA:A&lt;:&lt;scala.util.Try[B]):monix.bio.Task[B]"></a><a id="dematerialize[B](&lt;:&lt;[E,Nothing],&lt;:&lt;[A,Try[B]]):Task[B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#dematerialize[B](implicitevE:E&lt;:&lt;Nothing,implicitevA:A&lt;:&lt;scala.util.Try[B]):monix.bio.Task[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dematerialize</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="evE">evE: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Nothing.html#scala.Nothing" name="scala.Nothing" id="scala.Nothing" class="extype">Nothing</a>]</span>, <span name="evA">evA: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.A" class="extype">A</span>, <a href="https://www.scala-lang.org/api/2.13.1/scala/util/Try.html#scala.util.Try" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="monix.bio.BIO.dematerialize.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.BIO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.BIO.dematerialize.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Dematerializes the source's result from a <code>Try</code>.</p></li><li class="indented0 " name="monix.bio.BIO#doOnCancel" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnCancel(callback:monix.bio.UIO[Unit]):monix.bio.BIO[E,A]"></a><a id="doOnCancel(UIO[Unit]):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#doOnCancel(callback:monix.bio.UIO[Unit]):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnCancel</span><span class="params">(<span name="callback">callback: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new <code>Task</code> that will mirror the source, but that will
execute the given <code>callback</code> if the task gets canceled before
completion.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new <code>Task</code> that will mirror the source, but that will
execute the given <code>callback</code> if the task gets canceled before
completion.</p><p>This only works for premature cancellation. See <a href="#doOnFinish(f:Option[monix.bio.Cause[E]]=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E,A]" name="monix.bio.BIO#doOnFinish" id="monix.bio.BIO#doOnFinish" class="extmbr">doOnFinish</a>
for triggering callbacks when the source finishes.
</p></div><dl class="paramcmts block"><dt class="param">callback</dt><dd class="cmt"><p>is the callback to execute if the task gets
       canceled prematurely</p></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#doOnFinish" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnFinish(f:Option[monix.bio.Cause[E]]=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E,A]"></a><a id="doOnFinish((Option[Cause[E]])=&gt;UIO[Unit]):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#doOnFinish(f:Option[monix.bio.Cause[E]]=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnFinish</span><span class="params">(<span name="f">f: (<a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BIO.E" class="extype">E</span>]]) =&gt; <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new <code>BIO</code> in which <code>f</code> is scheduled to be run on
completion.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new <code>BIO</code> in which <code>f</code> is scheduled to be run on
completion. This would typically be used to release any
resources acquired by this <code>BIO</code>.</p><p>The returned <code>BIO</code> completes when both the source and the task
returned by <code>f</code> complete.</p><p>NOTE: The given function is only called when the task is
complete.  However the function does not get called if the task
gets canceled.  Cancellation is a process that's concurrent with
the execution of a task and hence needs special handling.</p><p>See <a href="#doOnCancel(callback:monix.bio.UIO[Unit]):monix.bio.BIO[E,A]" name="monix.bio.BIO#doOnCancel" id="monix.bio.BIO#doOnCancel" class="extmbr">doOnCancel</a> for specifying a callback to call on
canceling a task.
</p></div></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean"></a><a id="equals(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#executeAsync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="executeAsync:monix.bio.BIO[E,A]"></a><a id="executeAsync:BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#executeAsync:monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">executeAsync</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Mirrors the given source <code>Task</code>, but upon execution ensure
that evaluation forks into a separate (logical) thread.</p><div class="fullcomment"><div class="comment cmt"><p>Mirrors the given source <code>Task</code>, but upon execution ensure
that evaluation forks into a separate (logical) thread.</p><p>The <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> used will be
the one that is used to start the run-loop in
<a href="#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.BIO#runAsync" id="monix.bio.BIO#runAsync" class="extmbr">BIO.runAsync</a> or <a href="#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.BIO#runToFuture" id="monix.bio.BIO#runToFuture" class="extmbr">BIO.runToFuture</a>.</p><p>This operation is equivalent with:</p><pre>Task.shift.flatMap(_ <span class="kw">=&gt;</span> Task(<span class="num">1</span> + <span class="num">1</span>))

<span class="cmt">// ... or ...</span>

<span class="kw">import</span> cats.syntax.all._

Task.shift *&gt; Task(<span class="num">1</span> + <span class="num">1</span>)</pre><p>The <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> used for scheduling
the async boundary will be the default, meaning the one used to
start the run-loop in <code>runAsync</code>.
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#executeOn" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="executeOn(s:monix.execution.Scheduler,forceAsync:Boolean):monix.bio.BIO[E,A]"></a><a id="executeOn(Scheduler,Boolean):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#executeOn(s:monix.execution.Scheduler,forceAsync:Boolean):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">executeOn</span><span class="params">(<span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="forceAsync">forceAsync: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">true</span></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Overrides the default <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>,
possibly forcing an asynchronous boundary before execution
(if <code>forceAsync</code> is set to <code>true</code>, the default).</p><div class="fullcomment"><div class="comment cmt"><p>Overrides the default <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>,
possibly forcing an asynchronous boundary before execution
(if <code>forceAsync</code> is set to <code>true</code>, the default).</p><p>When a <code>Task</code> is executed with <a href="#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.BIO#runAsync" id="monix.bio.BIO#runAsync" class="extmbr">BIO.runAsync</a> or <a href="#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.BIO#runToFuture" id="monix.bio.BIO#runToFuture" class="extmbr">BIO.runToFuture</a>,
it needs a <code>Scheduler</code>, which is going to be injected in all
asynchronous tasks processed within the <code>flatMap</code> chain,
a <code>Scheduler</code> that is used to manage asynchronous boundaries
and delayed execution.</p><p>This scheduler passed in <code>runAsync</code> is said to be the "default"
and <code>executeOn</code> overrides that default.</p><pre><span class="kw">import</span> monix.execution.Scheduler
<span class="kw">import</span> java.io.{BufferedReader, FileInputStream, InputStreamReader}

<span class="cmt">/** Reads the contents of a file using blocking I/O. */</span>
<span class="kw">def</span> readFile(path: <span class="std">String</span>): Task[<span class="std">String</span>] = Task.eval {
  <span class="kw">val</span> in = <span class="kw">new</span> BufferedReader(
    <span class="kw">new</span> InputStreamReader(<span class="kw">new</span> FileInputStream(path), <span class="lit">"utf-8"</span>))

  <span class="kw">val</span> buffer = <span class="kw">new</span> StringBuffer()
  <span class="kw">var</span> line: <span class="std">String</span> = <span class="kw">null</span>
  <span class="kw">do</span> {
    line = in.readLine()
    <span class="kw">if</span> (line != <span class="kw">null</span>) buffer.append(line)
  } <span class="kw">while</span> (line != <span class="kw">null</span>)

  buffer.toString
}

<span class="cmt">// Building a Scheduler meant for blocking I/O</span>
<span class="kw">val</span> io = Scheduler.io()

<span class="cmt">// Building the Task reference, specifying that `io` should be</span>
<span class="cmt">// injected as the Scheduler for managing async boundaries</span>
readFile(<span class="lit">"path/to/file"</span>).executeOn(io, forceAsync = <span class="kw">true</span>)</pre><p>In this example we are using <a href="BIO$.html#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.BIO#eval" id="monix.bio.BIO#eval" class="extmbr">BIO.eval</a>, which executes the
given <code>thunk</code> immediately (on the current thread and call stack).</p><p>By calling <code>executeOn(io)</code>, we are ensuring that the used
<code>Scheduler</code> (injected in <a href="BIO$.html#cancelable0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;cats.effect.CancelToken[[β$1$]monix.bio.BIO[E,β$1$]]):monix.bio.BIO[E,A]" name="monix.bio.BIO#cancelable0" id="monix.bio.BIO#cancelable0" class="extmbr">BIO.cancelable0</a>)
will be <code>io</code>, a <code>Scheduler</code> that we intend to use for blocking
I/O actions. And we are also forcing an asynchronous boundary
right before execution, by passing the <code>forceAsync</code> parameter as
<code>true</code> (which happens to be the default value).</p><p>Thus, for our described function that reads files using Java's
blocking I/O APIs, we are ensuring that execution is entirely
managed by an <code>io</code> scheduler, executing that logic on a thread
pool meant for blocking I/O actions.</p><p>Note that in case <code>forceAsync = false</code>, then the invocation will
not introduce any async boundaries of its own and will not
ensure that execution will actually happen on the given
<code>Scheduler</code>, that depending of the implementation of the <code>Task</code>.
For example:</p><pre>Task.eval(<span class="lit">"Hello, "</span> + <span class="lit">"World!"</span>)
  .executeOn(io, forceAsync = <span class="kw">false</span>)</pre><p>The evaluation of this task will probably happen immediately
(depending on the configured
<a href="https://monix.io/api/3.1/monix/execution/ExecutionModel.html" name="monix.execution.ExecutionModel" id="monix.execution.ExecutionModel" class="extype">ExecutionModel</a>) and the
given scheduler will probably not be used at all.</p><p>However in case we would use <a href="BIO$.html#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.BIO#evalAsync" id="monix.bio.BIO#evalAsync" class="extmbr">BIO.evalAsync</a>, which ensures
that execution of the provided thunk will be async, then
by using <code>executeOn</code> we'll indeed get a logical fork on
the <code>io</code> scheduler:</p><pre>BIO.evalAsync(<span class="lit">"Hello, "</span> + <span class="lit">"World!"</span>).executeOn(io, forceAsync = <span class="kw">false</span>)</pre><p>Also note that overriding the "default" scheduler can only
happen once, because it's only the "default" that can be
overridden.</p><p>Something like this won't have the desired effect:</p><pre><span class="kw">val</span> io1 = Scheduler.io()
<span class="kw">val</span> io2 = Scheduler.io()

Task(<span class="num">1</span> + <span class="num">1</span>).executeOn(io1).executeOn(io2)</pre><p>In this example the implementation of <code>task</code> will receive
the reference to <code>io1</code> and will use it on evaluation, while
the second invocation of <code>executeOn</code> will create an unnecessary
async boundary (if <code>forceAsync = true</code>) or be basically a
costly no-op. This might be confusing but consider the
equivalence to these functions:</p><pre><span class="kw">import</span> scala.concurrent.ExecutionContext

<span class="kw">val</span> io11 = Scheduler.io()
<span class="kw">val</span> io22 = Scheduler.io()

<span class="kw">def</span> sayHello(ec: ExecutionContext): <span class="std">Unit</span> =
  ec.execute(<span class="kw">new</span> Runnable {
    <span class="kw">def</span> run() = println(<span class="lit">"Hello!"</span>)
  })

<span class="kw">def</span> sayHello2(ec: ExecutionContext): <span class="std">Unit</span> =
  <span class="cmt">// Overriding the default `ec`!</span>
  sayHello(io11)

<span class="kw">def</span> sayHello3(ec: ExecutionContext): <span class="std">Unit</span> =
  <span class="cmt">// Overriding the default no longer has the desired effect</span>
  <span class="cmt">// because sayHello2 is ignoring it!</span>
  sayHello2(io22)</pre></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is the <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> to use
       for overriding the default scheduler and for forcing
       an asynchronous boundary if <code>forceAsync</code> is <code>true</code></p></dd><dt class="param">forceAsync</dt><dd class="cmt"><p>indicates whether an asynchronous boundary
       should be forced right before the evaluation of the
       <code>Task</code>, managed by the provided <code>Scheduler</code></p></dd><dt>returns</dt><dd class="cmt"><p>a new <code>Task</code> that mirrors the source on evaluation,
        but that uses the provided scheduler for overriding
        the default and possibly force an extra asynchronous
        boundary on execution</p></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#executeWithModel" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="executeWithModel(em:monix.execution.ExecutionModel):monix.bio.BIO[E,A]"></a><a id="executeWithModel(ExecutionModel):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#executeWithModel(em:monix.execution.ExecutionModel):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">executeWithModel</span><span class="params">(<span name="em">em: <a href="https://monix.io/api/3.1/monix/execution/ExecutionModel.html#monix.execution.ExecutionModel" name="monix.execution.ExecutionModel" id="monix.execution.ExecutionModel" class="extype">ExecutionModel</a></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new task that will execute the source with a different
<a href="https://monix.io/api/3.1/monix/execution/ExecutionModel.html" name="monix.execution.ExecutionModel" id="monix.execution.ExecutionModel" class="extype">ExecutionModel</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new task that will execute the source with a different
<a href="https://monix.io/api/3.1/monix/execution/ExecutionModel.html" name="monix.execution.ExecutionModel" id="monix.execution.ExecutionModel" class="extype">ExecutionModel</a>.</p><p>This allows fine-tuning the options injected by the scheduler
locally. Example:</p><pre><span class="kw">import</span> monix.execution.ExecutionModel.AlwaysAsyncExecution
Task(<span class="num">1</span> + <span class="num">1</span>).executeWithModel(AlwaysAsyncExecution)</pre></div><dl class="paramcmts block"><dt class="param">em</dt><dd class="cmt"><p>is the
       <a href="https://monix.io/api/3.1/monix/execution/ExecutionModel.html" name="monix.execution.ExecutionModel" id="monix.execution.ExecutionModel" class="extype">ExecutionModel</a>
       with which the source will get evaluated on <code>runAsync</code></p></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#executeWithOptions" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="executeWithOptions(f:monix.bio.BIO.Options=&gt;monix.bio.BIO.Options):monix.bio.BIO[E,A]"></a><a id="executeWithOptions((Options)=&gt;Options):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#executeWithOptions(f:monix.bio.BIO.Options=&gt;monix.bio.BIO.Options):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">executeWithOptions</span><span class="params">(<span name="f">f: (<a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a>) =&gt; <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new task that will execute the source with a different
set of <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new task that will execute the source with a different
set of <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a>.</p><p>This allows fine-tuning the default options. Example:</p><pre>Task(<span class="num">1</span> + <span class="num">1</span>).executeWithOptions(_.enableAutoCancelableRunLoops)</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a function that takes the source's current set of
         <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">options</a> and returns a modified set of
         options that will be used to execute the source
         upon <code>runAsync</code></p></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#failed" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="failed:monix.bio.UIO[E]"></a><a id="failed:UIO[E]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#failed:monix.bio.UIO[E]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">failed</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>]</span></span><p class="shortcomment cmt">Returns a failed projection of this task.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a failed projection of this task.</p><p>The failed projection is a <code>BIO</code> holding a value of type <code>E</code>,
emitting the error yielded by the source, in case the source fails,
otherwise if the source succeeds the result will fail with a
<code>NoSuchElementException</code>.
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#flatMap" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]"></a><a id="flatMap[E1&gt;:E,B]((A)=&gt;BIO[E1,B]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatMap</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.flatMap.E1" class="extype">E1</span>, <span name="monix.bio.BIO.flatMap.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.flatMap.E1" class="extype">E1</span>, <span name="monix.bio.BIO.flatMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new Task by applying a function to the successful result
of the source Task, and returns a task equivalent to the result
of the function.</p></li><li class="indented0 " name="monix.bio.BIO#flatten" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="flatten[E1&gt;:E,B](implicitev:A&lt;:&lt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]"></a><a id="flatten[E1&gt;:E,B](&lt;:&lt;[A,BIO[E1,B]]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#flatten[E1&gt;:E,B](implicitev:A&lt;:&lt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatten</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.A" class="extype">A</span>, <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.flatten.E1" class="extype">E1</span>, <span name="monix.bio.BIO.flatten.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.flatten.E1" class="extype">E1</span>, <span name="monix.bio.BIO.flatten.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given a source Task that emits another Task, this function
flattens the result, returning a Task equivalent to the emitted
Task by the source.</p></li><li class="indented0 " name="monix.bio.BIO#foreach" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foreach(f:Either[E,A]=&gt;Unit)(implicits:monix.execution.Scheduler):Unit"></a><a id="foreach((Either[E,A])=&gt;Unit)(Scheduler):Unit"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#foreach(f:Either[E,A]=&gt;Unit)(implicits:monix.execution.Scheduler):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foreach</span><span class="params">(<span name="f">f: (<span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]) =&gt; <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><p class="shortcomment cmt">Triggers the evaluation of the source, executing the given
function for the generated element.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the evaluation of the source, executing the given
function for the generated element.</p><p>The application of this function has strict behavior, as the
task is immediately executed.</p><p>Exceptions in <code>f</code> are reported using provided (implicit) Scheduler
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#foreachL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foreachL(f:A=&gt;Unit):monix.bio.BIO[E,Unit]"></a><a id="foreachL((A)=&gt;Unit):BIO[E,Unit]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#foreachL(f:A=&gt;Unit):monix.bio.BIO[E,Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foreachL</span><span class="params">(<span name="f">f: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Returns a new task that upon evaluation will execute the given
function for the generated element, transforming the source into
a <code>BIO[E, Unit]</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new task that upon evaluation will execute the given
function for the generated element, transforming the source into
a <code>BIO[E, Unit]</code>.</p><p>Similar in spirit with normal <a href="#foreach(f:Either[E,A]=&gt;Unit)(implicits:monix.execution.Scheduler):Unit" name="monix.bio.BIO#foreach" id="monix.bio.BIO#foreach" class="extmbr">foreach</a>, but lazy, as
obviously nothing gets executed at this point.
</p></div></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <span name="java.lang.Class" class="extype">Class</span>[_ &lt;: <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#guarantee" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guarantee(finalizer:monix.bio.UIO[Unit]):monix.bio.BIO[E,A]"></a><a id="guarantee(UIO[Unit]):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#guarantee(finalizer:monix.bio.UIO[Unit]):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guarantee</span><span class="params">(<span name="finalizer">finalizer: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given <code>finalizer</code> when the source is finished,
either in success or in error, or if canceled.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given <code>finalizer</code> when the source is finished,
either in success or in error, or if canceled.</p><p>This variant of <a href="#guaranteeCase(finalizer:cats.effect.ExitCase[monix.bio.Cause[E]]=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E,A]" name="monix.bio.BIO#guaranteeCase" id="monix.bio.BIO#guaranteeCase" class="extmbr">guaranteeCase</a> evaluates the given <code>finalizer</code>
regardless of how the source gets terminated:</p><ul><li>normal completion</li><li>completion in error</li><li>cancellation</li></ul><p>As best practice, it's not a good idea to release resources
via <code>guaranteeCase</code> in polymorphic code. Prefer <a href="#bracket[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:A=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracket" id="monix.bio.BIO#bracket" class="extmbr">bracket</a>
for the acquisition and release of resources.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#guaranteeCase(finalizer:cats.effect.ExitCase[monix.bio.Cause[E]]=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E,A]" name="monix.bio.BIO#guaranteeCase" id="monix.bio.BIO#guaranteeCase" class="extmbr">guaranteeCase</a> for the version that can discriminate
     between termination conditions</p></span><span class="cmt"><p><a href="#bracket[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:A=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracket" id="monix.bio.BIO#bracket" class="extmbr">bracket</a> for the more general operation</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#guaranteeCase" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guaranteeCase(finalizer:cats.effect.ExitCase[monix.bio.Cause[E]]=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E,A]"></a><a id="guaranteeCase((ExitCase[Cause[E]])=&gt;UIO[Unit]):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#guaranteeCase(finalizer:cats.effect.ExitCase[monix.bio.Cause[E]]=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guaranteeCase</span><span class="params">(<span name="finalizer">finalizer: (<a href="https://typelevel.org/cats-effect/api/cats/effect/ExitCase.html#cats.effect.ExitCase" name="cats.effect.ExitCase" id="cats.effect.ExitCase" class="extype">ExitCase</a>[<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BIO.E" class="extype">E</span>]]) =&gt; <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given <code>finalizer</code> when the source is finished,
either in success or in error, or if canceled, allowing
for differentiating between exit conditions.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given <code>finalizer</code> when the source is finished,
either in success or in error, or if canceled, allowing
for differentiating between exit conditions.</p><p>This variant of <a href="#guarantee(finalizer:monix.bio.UIO[Unit]):monix.bio.BIO[E,A]" name="monix.bio.BIO#guarantee" id="monix.bio.BIO#guarantee" class="extmbr">guarantee</a> injects an ExitCase in
the provided function, allowing one to make a difference
between:</p><ul><li>normal completion</li><li>completion in error</li><li>cancellation</li></ul><p>As best practice, it's not a good idea to release resources
via <code>guaranteeCase</code> in polymorphic code. Prefer <a href="#bracketCase[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,cats.effect.ExitCase[monix.bio.Cause[E1]])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracketCase" id="monix.bio.BIO#bracketCase" class="extmbr">bracketCase</a>
for the acquisition and release of resources.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#guarantee(finalizer:monix.bio.UIO[Unit]):monix.bio.BIO[E,A]" name="monix.bio.BIO#guarantee" id="monix.bio.BIO#guarantee" class="extmbr">guarantee</a> for the simpler version</p></span><span class="cmt"><p><a href="#bracketCase[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,cats.effect.ExitCase[monix.bio.Cause[E1]])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracketCase" id="monix.bio.BIO#bracketCase" class="extmbr">bracketCase</a> for the more general operation</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#hideErrors" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hideErrors(implicitE:E&lt;:&lt;Throwable):monix.bio.UIO[A]"></a><a id="hideErrors(&lt;:&lt;[E,Throwable]):UIO[A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#hideErrors(implicitE:E&lt;:&lt;Throwable):monix.bio.UIO[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hideErrors</span><span class="params">(<span class="implicit">implicit </span><span name="E">E: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="scala.Throwable" class="extype">Throwable</span>]</span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Hides all errors from the return type and raises them in the internal channel.</p><div class="fullcomment"><div class="comment cmt"><p>Hides all errors from the return type and raises them in the internal channel.</p><p>Use if you have a method that returns a possible error but you can't recover
from it anyway and do not want to drag it everywhere.</p><pre><span class="kw">import</span> monix.execution.exceptions.DummyException
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="kw">val</span> task: UIO[<span class="std">Int</span>] = BIO
  .raiseError(DummyException(<span class="lit">"boom!"</span>))
  .hideErrors
  .map(_ <span class="kw">=&gt;</span> <span class="num">10</span>)

<span class="cmt">// Some(Failure(DummyException(boom!)))</span>
task.runToFuture.value</pre></div></div></li><li class="indented0 " name="monix.bio.BIO#hideErrorsWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hideErrorsWith(f:E=&gt;Throwable):monix.bio.UIO[A]"></a><a id="hideErrorsWith((E)=&gt;Throwable):UIO[A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#hideErrorsWith(f:E=&gt;Throwable):monix.bio.UIO[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hideErrorsWith</span><span class="params">(<span name="f">f: (<span name="monix.bio.BIO.E" class="extype">E</span>) =&gt; <span name="scala.Throwable" class="extype">Throwable</span></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Hides all errors from the return type and raises them in the internal channel,
using supplied function to transform <code>E</code> into <code>Throwable</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Hides all errors from the return type and raises them in the internal channel,
using supplied function to transform <code>E</code> into <code>Throwable</code>.</p><p>Use if you have a method that returns a possible error but you can't recover
from it anyway and do not want to drag it everywhere.</p><pre><span class="kw">import</span> monix.execution.exceptions.DummyException
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="kw">val</span> task: UIO[<span class="std">Int</span>] = BIO
  .raiseError(<span class="lit">"boom!"</span>)
  .hideErrorsWith(e <span class="kw">=&gt;</span> DummyException(e))
  .map(_ <span class="kw">=&gt;</span> <span class="num">10</span>)

<span class="cmt">// Some(Failure(DummyException(boom!)))</span>
task.runToFuture.value</pre></div></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#loopForever" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="loopForever:monix.bio.BIO[E,Nothing]"></a><a id="loopForever:BIO[E,Nothing]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#loopForever:monix.bio.BIO[E,Nothing]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">loopForever</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Nothing.html#scala.Nothing" name="scala.Nothing" id="scala.Nothing" class="extype">Nothing</a>]</span></span><p class="shortcomment cmt">Returns a new <code>Task</code> that repeatedly executes the source as long
as it continues to succeed.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new <code>Task</code> that repeatedly executes the source as long
as it continues to succeed. It never produces a terminal value.</p><p>Example:</p><pre><span class="kw">import</span> scala.concurrent.duration._

Task.eval(println(<span class="lit">"Tick!"</span>))
  .delayExecution(<span class="num">1.</span>second)
  .loopForever</pre></div></div></li><li class="indented0 " name="monix.bio.BIO#map" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="map[B](f:A=&gt;B):monix.bio.BIO[E,B]"></a><a id="map[B]((A)=&gt;B):BIO[E,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#map[B](f:A=&gt;B):monix.bio.BIO[E,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <span name="monix.bio.BIO.map.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.map.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new <code>Task</code> that applies the mapping function to
the element emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new <code>Task</code> that applies the mapping function to
the element emitted by the source.</p><p>Can be used for specifying a (lazy) transformation to the result
of the source.</p><p>This equivalence with <a href="#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#flatMap" id="monix.bio.BIO#flatMap" class="extmbr">flatMap</a> always holds:</p><p><code>fa.map(f) &lt;-&gt; fa.flatMap(x =&gt; Task.pure(f(x)))</code>
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#mapError" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapError[E1](f:E=&gt;E1):monix.bio.BIO[E1,A]"></a><a id="mapError[E1]((E)=&gt;E1):BIO[E1,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#mapError[E1](f:E=&gt;E1):monix.bio.BIO[E1,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mapError</span><span class="tparams">[<span name="E1">E1</span>]</span><span class="params">(<span name="f">f: (<span name="monix.bio.BIO.E" class="extype">E</span>) =&gt; <span name="monix.bio.BIO.mapError.E1" class="extype">E1</span></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.mapError.E1" class="extype">E1</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new task that will will transform errors
using supplied function <code>f</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new task that will will transform errors
using supplied function <code>f</code>.</p><p>Example:</p><pre><span class="kw">import</span> java.time.Instant

<span class="kw">case</span> <span class="kw">class</span> ErrorA(i: <span class="std">Int</span>)
<span class="kw">case</span> <span class="kw">class</span> ErrorB(errA: ErrorA, createdAt: Instant)

<span class="kw">val</span> task1: BIO[ErrorA, <span class="std">String</span>] = BIO.raiseError(ErrorA(<span class="num">10</span>))
<span class="kw">val</span> task2: BIO[ErrorB, <span class="std">String</span>] = task1.mapError(errA <span class="kw">=&gt;</span> ErrorB(errA, Instant.now()))</pre></div></div></li><li class="indented0 " name="monix.bio.BIO#materialize" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="materialize(implicitev:E&lt;:&lt;Throwable):monix.bio.UIO[scala.util.Try[A]]"></a><a id="materialize(&lt;:&lt;[E,Throwable]):UIO[Try[A]]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#materialize(implicitev:E&lt;:&lt;Throwable):monix.bio.UIO[scala.util.Try[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">materialize</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="scala.Throwable" class="extype">Throwable</span>]</span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/util/Try.html#scala.util.Try" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="monix.bio.BIO.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Creates a new <a href="index.html#Task[+A]=monix.bio.BIO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a> that will expose any triggered error from
the source.</p></li><li class="indented0 " name="monix.bio.BIO#memoize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="memoize:monix.bio.BIO[E,A]"></a><a id="memoize:BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#memoize:monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">memoize</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Memoizes (caches) the result of the source task and reuses it on
subsequent invocations of <code>runAsync</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Memoizes (caches) the result of the source task and reuses it on
subsequent invocations of <code>runAsync</code>.</p><p>The resulting task will be idempotent, meaning that
evaluating the resulting task multiple times will have the
same effect as evaluating it once.</p><p><b>Cancellation</b> — a memoized task will mirror
        the behavior of the source on cancellation. This means that:</p><ul><li>if the source isn't cancellable, then the resulting memoized
           task won't be cancellable either</li><li>if the source is cancellable, then the memoized task can be
           cancelled, which can take unprepared users by surprise</li></ul><p>        Depending on use-case, there are two ways to ensure no surprises:</p><ul><li>usage of <a href="#onCancelRaiseError[E1&gt;:E](e:E1):monix.bio.BIO[E1,A]" name="monix.bio.BIO#onCancelRaiseError" id="monix.bio.BIO#onCancelRaiseError" class="extmbr">onCancelRaiseError</a>, before applying memoization, to
           ensure that on cancellation an error is triggered and then noticed
           by the memoization logic</li><li>usage of <a href="#uncancelable:monix.bio.BIO[E,A]" name="monix.bio.BIO#uncancelable" id="monix.bio.BIO#uncancelable" class="extmbr">uncancelable</a>, either before or after applying
           memoization, to ensure that the memoized task cannot be cancelled</li></ul><p>Example:</p><pre><span class="kw">import</span> scala.concurrent.CancellationException
<span class="kw">import</span> scala.concurrent.duration._

<span class="kw">val</span> source = Task(<span class="num">1</span>).delayExecution(<span class="num">5.</span>seconds)

<span class="cmt">// Option 1: trigger error on cancellation</span>
<span class="kw">val</span> err = <span class="kw">new</span> CancellationException
<span class="kw">val</span> cached1 = source.onCancelRaiseError(err).memoize

<span class="cmt">// Option 2: make it uninterruptible</span>
<span class="kw">val</span> cached2 = source.uncancelable.memoize</pre><p>When using <a href="#onCancelRaiseError[E1&gt;:E](e:E1):monix.bio.BIO[E1,A]" name="monix.bio.BIO#onCancelRaiseError" id="monix.bio.BIO#onCancelRaiseError" class="extmbr">onCancelRaiseError</a> like in the example above, the
behavior of <code>memoize</code> is to cache the error. If you want the ability
to retry errors until a successful value happens, see <a href="#memoizeOnSuccess:monix.bio.BIO[E,A]" name="monix.bio.BIO#memoizeOnSuccess" id="monix.bio.BIO#memoizeOnSuccess" class="extmbr">memoizeOnSuccess</a>.</p><p><b>UNSAFE</b> — this operation allocates a shared,
        mutable reference, which can break in certain cases
        referential transparency, even if this operation guarantees
        idempotency (i.e. referential transparency implies idempotency,
        but idempotency does not imply referential transparency).</p><p>        The allocation of a mutable reference is known to be a
        side effect, thus breaking referential transparency,
        even if calling this method does not trigger the evaluation
        of side effects suspended by the source.</p><p>        Use with care. Sometimes it's easier to just keep a shared,
        memoized reference to some connection, but keep in mind
        it might be better to pass such a reference around as
        a parameter.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a <code>Task</code> that can be used to wait for the memoized value</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#memoizeOnSuccess:monix.bio.BIO[E,A]" name="monix.bio.BIO#memoizeOnSuccess" id="monix.bio.BIO#memoizeOnSuccess" class="extmbr">memoizeOnSuccess</a> for a version that only caches
    successful results</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#memoizeOnSuccess" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="memoizeOnSuccess:monix.bio.BIO[E,A]"></a><a id="memoizeOnSuccess:BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#memoizeOnSuccess:monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">memoizeOnSuccess</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Memoizes (cache) the successful result of the source task
and reuses it on subsequent invocations of <code>runAsync</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Memoizes (cache) the successful result of the source task
and reuses it on subsequent invocations of <code>runAsync</code>.
Thrown exceptions are not cached.</p><p>The resulting task will be idempotent, but only if the
result is successful.</p><p><b>Cancellation</b> — a memoized task will mirror
        the behavior of the source on cancellation. This means that:</p><ul><li>if the source isn't cancellable, then the resulting memoized
           task won't be cancellable either</li><li>if the source is cancellable, then the memoized task can be
           cancelled, which can take unprepared users by surprise</li></ul><p>        Depending on use-case, there are two ways to ensure no surprises:</p><ul><li>usage of <a href="#onCancelRaiseError[E1&gt;:E](e:E1):monix.bio.BIO[E1,A]" name="monix.bio.BIO#onCancelRaiseError" id="monix.bio.BIO#onCancelRaiseError" class="extmbr">onCancelRaiseError</a>, before applying memoization, to
           ensure that on cancellation an error is triggered and then noticed
           by the memoization logic</li><li>usage of <a href="#uncancelable:monix.bio.BIO[E,A]" name="monix.bio.BIO#uncancelable" id="monix.bio.BIO#uncancelable" class="extmbr">uncancelable</a>, either before or after applying
           memoization, to ensure that the memoized task cannot be cancelled</li></ul><p>Example:</p><pre><span class="kw">import</span> scala.concurrent.CancellationException
<span class="kw">import</span> scala.concurrent.duration._

<span class="kw">val</span> source = Task(<span class="num">1</span>).delayExecution(<span class="num">5.</span>seconds)

<span class="cmt">// Option 1: trigger error on cancellation</span>
<span class="kw">val</span> err = <span class="kw">new</span> CancellationException
<span class="kw">val</span> cached1 = source.onCancelRaiseError(err).memoizeOnSuccess

<span class="cmt">// Option 2: make it uninterruptible</span>
<span class="kw">val</span> cached2 = source.uncancelable.memoizeOnSuccess</pre><p>When using <a href="#onCancelRaiseError[E1&gt;:E](e:E1):monix.bio.BIO[E1,A]" name="monix.bio.BIO#onCancelRaiseError" id="monix.bio.BIO#onCancelRaiseError" class="extmbr">onCancelRaiseError</a> like in the example above, the
behavior of <code>memoizeOnSuccess</code> is to retry the source on subsequent
invocations. Use <a href="#memoize:monix.bio.BIO[E,A]" name="monix.bio.BIO#memoize" id="monix.bio.BIO#memoize" class="extmbr">memoize</a> if that's not the desired behavior.</p><p><b>UNSAFE</b> — this operation allocates a shared,
        mutable reference, which can break in certain cases
        referential transparency, even if this operation guarantees
        idempotency (i.e. referential transparency implies idempotency,
        but idempotency does not imply referential transparency).</p><p>        The allocation of a mutable reference is known to be a
        side effect, thus breaking referential transparency,
        even if calling this method does not trigger the evaluation
        of side effects suspended by the source.</p><p>        Use with care. Sometimes it's easier to just keep a shared,
        memoized reference to some connection, but keep in mind
        it might be better to pass such a reference around as
        a parameter.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a <code>Task</code> that can be used to wait for the memoized value</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#memoize:monix.bio.BIO[E,A]" name="monix.bio.BIO#memoize" id="monix.bio.BIO#memoize" class="extmbr">memoize</a> for a version that caches both successful
    results and failures</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#onCancelRaiseError" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onCancelRaiseError[E1&gt;:E](e:E1):monix.bio.BIO[E1,A]"></a><a id="onCancelRaiseError[E1&gt;:E](E1):BIO[E1,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#onCancelRaiseError[E1&gt;:E](e:E1):monix.bio.BIO[E1,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onCancelRaiseError</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>]</span><span class="params">(<span name="e">e: <span name="monix.bio.BIO.onCancelRaiseError.E1" class="extype">E1</span></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.onCancelRaiseError.E1" class="extype">E1</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new task that mirrors the source task for normal termination,
but that triggers the given error on cancellation.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new task that mirrors the source task for normal termination,
but that triggers the given error on cancellation.</p><p>Normally tasks that are cancelled become non-terminating.
Here's an example of a cancelable task:</p><pre><span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> java.util.concurrent.TimeoutException

<span class="kw">val</span> tenSecs = BIO.sleep(<span class="num">10.</span>seconds)
<span class="kw">val</span> task1 = tenSecs.start.flatMap { fa <span class="kw">=&gt;</span>
  <span class="cmt">// Triggering pure cancellation, then trying to get its result</span>
  fa.cancel.flatMap(_ <span class="kw">=&gt;</span> tenSecs)
}

task1.timeoutWith(<span class="num">10.</span>seconds, <span class="kw">new</span> TimeoutException())
<span class="cmt">//=&gt; TimeoutException</span></pre><p>In general you can expect cancelable tasks to become non-terminating on
cancellation.</p><p>This <code>onCancelRaiseError</code> operator transforms a task that would yield
<a href="BIO$.html#never[A]:monix.bio.UIO[A]" name="monix.bio.BIO#never" id="monix.bio.BIO#never" class="extmbr">BIO.never</a> on cancellation into one that yields <a href="BIO$.html#raiseError[E](ex:E):monix.bio.BIO[E,Nothing]" name="monix.bio.BIO#raiseError" id="monix.bio.BIO#raiseError" class="extmbr">BIO.raiseError</a>.</p><p>Example:</p><pre><span class="kw">import</span> java.util.concurrent.CancellationException

<span class="kw">val</span> anotherTenSecs = BIO.sleep(<span class="num">10.</span>seconds)
  .onCancelRaiseError(<span class="kw">new</span> CancellationException)

<span class="kw">val</span> task2 = anotherTenSecs.start.flatMap { fa <span class="kw">=&gt;</span>
  <span class="cmt">// Triggering pure cancellation, then trying to get its result</span>
  fa.cancel.flatMap(_ <span class="kw">=&gt;</span> anotherTenSecs)
}

task2
<span class="cmt">// =&gt; CancellationException</span></pre></div></div></li><li class="indented0 " name="monix.bio.BIO#onErrorFallbackTo" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="onErrorFallbackTo[E1,B&gt;:A](that:monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]"></a><a id="onErrorFallbackTo[E1,B&gt;:A](BIO[E1,B]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#onErrorFallbackTo[E1,B&gt;:A](that:monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorFallbackTo</span><span class="tparams">[<span name="E1">E1</span>, <span name="B">B &gt;: <span name="monix.bio.BIO.A" class="extype">A</span></span>]</span><span class="params">(<span name="that">that: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.onErrorFallbackTo.E1" class="extype">E1</span>, <span name="monix.bio.BIO.onErrorFallbackTo.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.onErrorFallbackTo.E1" class="extype">E1</span>, <span name="monix.bio.BIO.onErrorFallbackTo.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new task that in case of error will fallback to the
given backup task.</p></li><li class="indented0 " name="monix.bio.BIO#onErrorHandle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorHandle[U&gt;:A](f:E=&gt;U):monix.bio.UIO[U]"></a><a id="onErrorHandle[U&gt;:A]((E)=&gt;U):UIO[U]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#onErrorHandle[U&gt;:A](f:E=&gt;U):monix.bio.UIO[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorHandle</span><span class="tparams">[<span name="U">U &gt;: <span name="monix.bio.BIO.A" class="extype">A</span></span>]</span><span class="params">(<span name="f">f: (<span name="monix.bio.BIO.E" class="extype">E</span>) =&gt; <span name="monix.bio.BIO.onErrorHandle.U" class="extype">U</span></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="monix.bio.BIO.onErrorHandle.U" class="extype">U</span>]</span></span><p class="shortcomment cmt">Creates a new task that will handle any matching throwable that
this task might emit.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new task that will handle any matching throwable that
this task might emit.</p><p>See <a href="#onErrorRecover[E1&gt;:E,U&gt;:A](pf:PartialFunction[E,U]):monix.bio.BIO[E1,U]" name="monix.bio.BIO#onErrorRecover" id="monix.bio.BIO#onErrorRecover" class="extmbr">onErrorRecover</a> for the version that takes a partial function.
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#onErrorHandleWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorHandleWith[E1,B&gt;:A](f:E=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]"></a><a id="onErrorHandleWith[E1,B&gt;:A]((E)=&gt;BIO[E1,B]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#onErrorHandleWith[E1,B&gt;:A](f:E=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorHandleWith</span><span class="tparams">[<span name="E1">E1</span>, <span name="B">B &gt;: <span name="monix.bio.BIO.A" class="extype">A</span></span>]</span><span class="params">(<span name="f">f: (<span name="monix.bio.BIO.E" class="extype">E</span>) =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.onErrorHandleWith.E1" class="extype">E1</span>, <span name="monix.bio.BIO.onErrorHandleWith.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.onErrorHandleWith.E1" class="extype">E1</span>, <span name="monix.bio.BIO.onErrorHandleWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new task that will handle any matching throwable that
this task might emit by executing another task.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new task that will handle any matching throwable that
this task might emit by executing another task.</p><p>See <a href="#onErrorRecoverWith[E1&gt;:E,B&gt;:A](pf:PartialFunction[E,monix.bio.BIO[E1,B]]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#onErrorRecoverWith" id="monix.bio.BIO#onErrorRecoverWith" class="extmbr">onErrorRecoverWith</a> for the version that takes a partial function.
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#onErrorRecover" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRecover[E1&gt;:E,U&gt;:A](pf:PartialFunction[E,U]):monix.bio.BIO[E1,U]"></a><a id="onErrorRecover[E1&gt;:E,U&gt;:A](PartialFunction[E,U]):BIO[E1,U]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#onErrorRecover[E1&gt;:E,U&gt;:A](pf:PartialFunction[E,U]):monix.bio.BIO[E1,U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRecover</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="U">U &gt;: <span name="monix.bio.BIO.A" class="extype">A</span></span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.1/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.onErrorRecover.U" class="extype">U</span>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.onErrorRecover.E1" class="extype">E1</span>, <span name="monix.bio.BIO.onErrorRecover.U" class="extype">U</span>]</span></span><p class="shortcomment cmt">Creates a new task that on error will try to map the error
to another value using the provided partial function.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new task that on error will try to map the error
to another value using the provided partial function.</p><p>See <a href="#onErrorHandle[U&gt;:A](f:E=&gt;U):monix.bio.UIO[U]" name="monix.bio.BIO#onErrorHandle" id="monix.bio.BIO#onErrorHandle" class="extmbr">onErrorHandle</a> for the version that takes a total function.
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#onErrorRecoverWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRecoverWith[E1&gt;:E,B&gt;:A](pf:PartialFunction[E,monix.bio.BIO[E1,B]]):monix.bio.BIO[E1,B]"></a><a id="onErrorRecoverWith[E1&gt;:E,B&gt;:A](PartialFunction[E,BIO[E1,B]]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#onErrorRecoverWith[E1&gt;:E,B&gt;:A](pf:PartialFunction[E,monix.bio.BIO[E1,B]]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRecoverWith</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B &gt;: <span name="monix.bio.BIO.A" class="extype">A</span></span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.1/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.onErrorRecoverWith.E1" class="extype">E1</span>, <span name="monix.bio.BIO.onErrorRecoverWith.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.onErrorRecoverWith.E1" class="extype">E1</span>, <span name="monix.bio.BIO.onErrorRecoverWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new task that will try recovering from an error by
matching it with another task using the given partial function.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new task that will try recovering from an error by
matching it with another task using the given partial function.</p><p>See <a href="#onErrorHandleWith[E1,B&gt;:A](f:E=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#onErrorHandleWith" id="monix.bio.BIO#onErrorHandleWith" class="extmbr">onErrorHandleWith</a> for the version that takes a total function.
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#onErrorRestart" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRestart(maxRetries:Long):monix.bio.BIO[E,A]"></a><a id="onErrorRestart(Long):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#onErrorRestart(maxRetries:Long):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRestart</span><span class="params">(<span name="maxRetries">maxRetries: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new task that in case of error will retry executing the
source again and again, until it succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new task that in case of error will retry executing the
source again and again, until it succeeds.</p><p>In case of continuous failure the total number of executions
will be maxRetries + 1.
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#onErrorRestartIf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRestartIf(p:E=&gt;Boolean):monix.bio.BIO[E,A]"></a><a id="onErrorRestartIf((E)=&gt;Boolean):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#onErrorRestartIf(p:E=&gt;Boolean):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRestartIf</span><span class="params">(<span name="p">p: (<span name="monix.bio.BIO.E" class="extype">E</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new task that in case of error will retry executing the
source again and again, until it succeeds, or until the given
predicate returns <code>false</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new task that in case of error will retry executing the
source again and again, until it succeeds, or until the given
predicate returns <code>false</code>.</p><p>In this sample we retry for as long as the error is a <code>TimeoutException</code>:</p><pre><span class="kw">import</span> scala.concurrent.TimeoutException

Task(<span class="lit">"some long call that may timeout"</span>).onErrorRestartIf {
  <span class="kw">case</span> _: TimeoutException <span class="kw">=&gt;</span> <span class="kw">true</span>
  <span class="kw">case</span> _ <span class="kw">=&gt;</span> <span class="kw">false</span>
}</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is the predicate that is executed if an error is thrown and
       that keeps restarting the source for as long as it returns <code>true</code></p></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#onErrorRestartLoop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRestartLoop[S,E1&gt;:E,B&gt;:A](initial:S)(f:(E1,S,S=&gt;monix.bio.BIO[E1,B])=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]"></a><a id="onErrorRestartLoop[S,E1&gt;:E,B&gt;:A](S)((E1,S,(S)=&gt;BIO[E1,B])=&gt;BIO[E1,B]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#onErrorRestartLoop[S,E1&gt;:E,B&gt;:A](initial:S)(f:(E1,S,S=&gt;monix.bio.BIO[E1,B])=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRestartLoop</span><span class="tparams">[<span name="S">S</span>, <span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B &gt;: <span name="monix.bio.BIO.A" class="extype">A</span></span>]</span><span class="params">(<span name="initial">initial: <span name="monix.bio.BIO.onErrorRestartLoop.S" class="extype">S</span></span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.BIO.onErrorRestartLoop.E1" class="extype">E1</span>, <span name="monix.bio.BIO.onErrorRestartLoop.S" class="extype">S</span>, (<span name="monix.bio.BIO.onErrorRestartLoop.S" class="extype">S</span>) =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.onErrorRestartLoop.E1" class="extype">E1</span>, <span name="monix.bio.BIO.onErrorRestartLoop.B" class="extype">B</span>]) =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.onErrorRestartLoop.E1" class="extype">E1</span>, <span name="monix.bio.BIO.onErrorRestartLoop.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.onErrorRestartLoop.E1" class="extype">E1</span>, <span name="monix.bio.BIO.onErrorRestartLoop.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">On error restarts the source with a customizable restart loop.</p><div class="fullcomment"><div class="comment cmt"><p>On error restarts the source with a customizable restart loop.</p><p>This operation keeps an internal <code>state</code>, with a start value, an internal
state that gets evolved and based on which the next step gets decided,
e.g. should it restart, maybe with a delay, or should it give up and
re-throw the current error.</p><p>Example that implements a simple retry policy that retries for a maximum
of 10 times before giving up; also introduce a 1 second delay before
each retry is executed:</p><pre><span class="kw">import</span> scala.util.Random
<span class="kw">import</span> scala.concurrent.duration._

<span class="kw">val</span> task = Task {
  <span class="kw">if</span> (Random.nextInt(<span class="num">20</span>) &gt; <span class="num">10</span>)
    <span class="kw">throw</span> <span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>)
  <span class="kw">else</span> <span class="num">78</span>
}

task.onErrorRestartLoop(<span class="num">10</span>) { (err, maxRetries, retry) <span class="kw">=&gt;</span>
  <span class="kw">if</span> (maxRetries &gt; <span class="num">0</span>)
    <span class="cmt">// Next retry please; but do a 1 second delay</span>
    retry(maxRetries - <span class="num">1</span>).delayExecution(<span class="num">1.</span>second)
  <span class="kw">else</span>
    <span class="cmt">// No retries left, rethrow the error</span>
    Task.raiseError(err)
}</pre><p>A more complex exponential back-off sample:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="cmt">// Keeps the current state, indicating the restart delay and the</span>
<span class="cmt">// maximum number of retries left</span>
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Backoff(maxRetries: <span class="std">Int</span>, delay: FiniteDuration)

<span class="cmt">// Restarts for a maximum of 10 times, with an initial delay of 1 second,</span>
<span class="cmt">// a delay that keeps being multiplied by 2</span>
task.onErrorRestartLoop(Backoff(<span class="num">10</span>, <span class="num">1.</span>second)) { (err, state, retry) <span class="kw">=&gt;</span>
  <span class="kw">val</span> Backoff(maxRetries, delay) = state
  <span class="kw">if</span> (maxRetries &gt; <span class="num">0</span>)
    retry(Backoff(maxRetries - <span class="num">1</span>, delay * <span class="num">2</span>)).delayExecution(delay)
  <span class="kw">else</span>
    <span class="cmt">// No retries left, rethrow the error</span>
    Task.raiseError(err)
}</pre><p>The given function injects the following parameters:</p><ol class="decimal"><li><code>error</code> reference that was thrown
 2. the current <code>state</code>, based on which a decision for the retry is made
 3. <code>retry: S =&gt; BIO[E, B]</code> function that schedules the next retry
</li></ol></div><dl class="paramcmts block"><dt class="param">initial</dt><dd class="cmt"><p>is the initial state used to determine the next on error
       retry cycle</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a function that injects the current error, state, a
       function that can signal a retry is to be made and returns
       the next task</p></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#redeem" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="redeem[B](recover:E=&gt;B,map:A=&gt;B):monix.bio.UIO[B]"></a><a id="redeem[B]((E)=&gt;B,(A)=&gt;B):UIO[B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#redeem[B](recover:E=&gt;B,map:A=&gt;B):monix.bio.UIO[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">redeem</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="recover">recover: (<span name="monix.bio.BIO.E" class="extype">E</span>) =&gt; <span name="monix.bio.BIO.redeem.B" class="extype">B</span></span>, <span name="map">map: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <span name="monix.bio.BIO.redeem.B" class="extype">B</span></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="monix.bio.BIO.redeem.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>map</code> functions, which get executed depending
on whether the result is successful or if it ends in error.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>map</code> functions, which get executed depending
on whether the result is successful or if it ends in error.</p><p>This is an optimization on usage of <a href="#attempt:monix.bio.UIO[Either[E,A]]" name="monix.bio.BIO#attempt" id="monix.bio.BIO#attempt" class="extmbr">attempt</a> and <a href="#map[B](f:A=&gt;B):monix.bio.BIO[E,B]" name="monix.bio.BIO#map" id="monix.bio.BIO#map" class="extmbr">map</a>,
this equivalence being true:</p><p><code>task.redeem(recover, map) &lt;-&gt; task.attempt.map(_.fold(recover, map))</code></p><p>Usage of <code>redeem</code> subsumes <a href="#onErrorHandle[U&gt;:A](f:E=&gt;U):monix.bio.UIO[U]" name="monix.bio.BIO#onErrorHandle" id="monix.bio.BIO#onErrorHandle" class="extmbr">onErrorHandle</a> because:</p><p><code>task.redeem(fe, id) &lt;-&gt; task.onErrorHandle(fe)</code>
</p></div><dl class="paramcmts block"><dt class="param">recover</dt><dd class="cmt"><p>is a function used for error recover in case the
       source ends in error</p></dd><dt class="param">map</dt><dd class="cmt"><p>is a function used for mapping the result of the source
       in case it ends in success</p></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#redeemCause" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="redeemCause[B](recover:monix.bio.Cause[E]=&gt;B,map:A=&gt;B):monix.bio.UIO[B]"></a><a id="redeemCause[B]((Cause[E])=&gt;B,(A)=&gt;B):UIO[B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#redeemCause[B](recover:monix.bio.Cause[E]=&gt;B,map:A=&gt;B):monix.bio.UIO[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">redeemCause</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="recover">recover: (<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BIO.E" class="extype">E</span>]) =&gt; <span name="monix.bio.BIO.redeemCause.B" class="extype">B</span></span>, <span name="map">map: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <span name="monix.bio.BIO.redeemCause.B" class="extype">B</span></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="monix.bio.BIO.redeemCause.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>map</code> functions, which get executed depending
on whether the result is successful or if it ends in a fatal (untyped) error.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>map</code> functions, which get executed depending
on whether the result is successful or if it ends in a fatal (untyped) error.
</p></div><dl class="paramcmts block"><dt class="param">recover</dt><dd class="cmt"><p>is a function used for error recover in case the
       source ends in error</p></dd><dt class="param">map</dt><dd class="cmt"><p>is a function used for mapping the result of the source
       in case it ends in success</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#redeem[B](recover:E=&gt;B,map:A=&gt;B):monix.bio.UIO[B]" name="monix.bio.BIO#redeem" id="monix.bio.BIO#redeem" class="extmbr">BIO.redeem</a> for a version which works on typed errors</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#redeemCauseWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="redeemCauseWith[E1,B](recover:monix.bio.Cause[E]=&gt;monix.bio.BIO[E1,B],bind:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]"></a><a id="redeemCauseWith[E1,B]((Cause[E])=&gt;BIO[E1,B],(A)=&gt;BIO[E1,B]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#redeemCauseWith[E1,B](recover:monix.bio.Cause[E]=&gt;monix.bio.BIO[E1,B],bind:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">redeemCauseWith</span><span class="tparams">[<span name="E1">E1</span>, <span name="B">B</span>]</span><span class="params">(<span name="recover">recover: (<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BIO.E" class="extype">E</span>]) =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.redeemCauseWith.E1" class="extype">E1</span>, <span name="monix.bio.BIO.redeemCauseWith.B" class="extype">B</span>]</span>, <span name="bind">bind: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.redeemCauseWith.E1" class="extype">E1</span>, <span name="monix.bio.BIO.redeemCauseWith.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.redeemCauseWith.E1" class="extype">E1</span>, <span name="monix.bio.BIO.redeemCauseWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>bind</code> functions, which get executed depending
on whether the result is successful or if it ends in a fatal (untyped) error.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>bind</code> functions, which get executed depending
on whether the result is successful or if it ends in a fatal (untyped) error.</p><p>Usage of <code>redeemWith</code> also subsumes <a href="#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#flatMap" id="monix.bio.BIO#flatMap" class="extmbr">flatMap</a> because:</p><p><code>task.redeemCauseWith(BIO.raiseError, fs) &lt;-&gt; task.flatMap(fs)</code>
</p></div><dl class="paramcmts block"><dt class="param">recover</dt><dd class="cmt"><p>is the function that gets called to recover the source
       in case of error</p></dd><dt class="param">bind</dt><dd class="cmt"><p>is the function that gets to transform the source
       in case of success</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#redeemWith[E1,B](recover:E=&gt;monix.bio.BIO[E1,B],bind:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#redeemWith" id="monix.bio.BIO#redeemWith" class="extmbr">BIO.redeemWith</a> for a version which only works on typed errors</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#redeemWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="redeemWith[E1,B](recover:E=&gt;monix.bio.BIO[E1,B],bind:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]"></a><a id="redeemWith[E1,B]((E)=&gt;BIO[E1,B],(A)=&gt;BIO[E1,B]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#redeemWith[E1,B](recover:E=&gt;monix.bio.BIO[E1,B],bind:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">redeemWith</span><span class="tparams">[<span name="E1">E1</span>, <span name="B">B</span>]</span><span class="params">(<span name="recover">recover: (<span name="monix.bio.BIO.E" class="extype">E</span>) =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.redeemWith.E1" class="extype">E1</span>, <span name="monix.bio.BIO.redeemWith.B" class="extype">B</span>]</span>, <span name="bind">bind: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.redeemWith.E1" class="extype">E1</span>, <span name="monix.bio.BIO.redeemWith.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.redeemWith.E1" class="extype">E1</span>, <span name="monix.bio.BIO.redeemWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>bind</code> functions, which get executed depending
on whether the result is successful or if it ends in error.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>bind</code> functions, which get executed depending
on whether the result is successful or if it ends in error.</p><p>This is an optimization on usage of <a href="#attempt:monix.bio.UIO[Either[E,A]]" name="monix.bio.BIO#attempt" id="monix.bio.BIO#attempt" class="extmbr">attempt</a> and <a href="#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#flatMap" id="monix.bio.BIO#flatMap" class="extmbr">flatMap</a>,
this equivalence being available:</p><p><code>task.redeemWith(recover, bind) &lt;-&gt; task.attempt.flatMap(_.fold(recover, bind))</code></p><p>Usage of <code>redeemWith</code> subsumes <a href="#onErrorHandleWith[E1,B&gt;:A](f:E=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#onErrorHandleWith" id="monix.bio.BIO#onErrorHandleWith" class="extmbr">onErrorHandleWith</a> because:</p><p><code>task.redeemWith(fe, F.pure) &lt;-&gt; task.onErrorHandleWith(fe)</code></p><p>Usage of <code>redeemWith</code> also subsumes <a href="#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#flatMap" id="monix.bio.BIO#flatMap" class="extmbr">flatMap</a> because:</p><p><code>task.redeemWith(Task.raiseError, fs) &lt;-&gt; task.flatMap(fs)</code>
</p></div><dl class="paramcmts block"><dt class="param">recover</dt><dd class="cmt"><p>is the function that gets called to recover the source
       in case of error</p></dd><dt class="param">bind</dt><dd class="cmt"><p>is the function that gets to transform the source
       in case of success</p></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#restartUntil" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="restartUntil(p:A=&gt;Boolean):monix.bio.BIO[E,A]"></a><a id="restartUntil((A)=&gt;Boolean):BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#restartUntil(p:A=&gt;Boolean):monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">restartUntil</span><span class="params">(<span name="p">p: (<span name="monix.bio.BIO.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.1/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Given a predicate function, keep retrying the
BIO until the function returns true.</p></li><li class="indented0 " name="monix.bio.BIO#rethrow" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="rethrow[E1&gt;:E,B](implicitev:A&lt;:&lt;Either[E1,B]):monix.bio.BIO[E1,B]"></a><a id="rethrow[E1&gt;:E,B](&lt;:&lt;[A,Either[E1,B]]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#rethrow[E1&gt;:E,B](implicitev:A&lt;:&lt;Either[E1,B]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">rethrow</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.A" class="extype">A</span>, <span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.BIO.rethrow.E1" class="extype">E1</span>, <span name="monix.bio.BIO.rethrow.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.rethrow.E1" class="extype">E1</span>, <span name="monix.bio.BIO.rethrow.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Inverse of <code>attempt</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Inverse of <code>attempt</code>. Creates a new <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a> that absorbs <code>Either</code>.</p><p><code>BIO.now(Right(42)).rethrow &lt;-&gt; BIO.now(42)</code></p><p><code>BIO.now(Left("error")).rethrow &lt;-&gt; BIO.raiseError("error")</code>
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#runAsync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable"></a><a id="runAsync((Either[Cause[E],A])=&gt;Unit)(Scheduler):Cancelable"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runAsync</span><span class="params">(<span name="cb">cb: (<span name="scala.Either" class="extype">Either</span>[<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BIO.E" class="extype">E</span>], <span name="monix.bio.BIO.A" class="extype">A</span>]) =&gt; <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="https://monix.io/api/3.1/monix/execution/Cancelable.html#monix.execution.Cancelable" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a></span></span><p class="shortcomment cmt">Triggers the asynchronous execution, with a provided callback
that's going to be called at some point in the future with
the final result.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the asynchronous execution, with a provided callback
that's going to be called at some point in the future with
the final result.</p><p>Note that without invoking <code>runAsync</code> on a <code>BIO</code>, nothing
gets evaluated, as a <code>BIO</code> has lazy behavior.</p><pre><span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> monix.bio.Cause
<span class="cmt">// A Scheduler is needed for executing tasks via `runAsync`</span>
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="cmt">// Nothing executes yet</span>
<span class="kw">val</span> task: BIO[<span class="std">String</span>, <span class="std">String</span>] =
  <span class="kw">for</span> {
    _ <span class="kw">&lt;-</span> BIO.sleep(<span class="num">3.</span>seconds)
    r <span class="kw">&lt;-</span> BIO.evalTotal { println(<span class="lit">"Executing..."</span>); <span class="lit">"Hello!"</span> }
  } <span class="kw">yield</span> r


<span class="cmt">// Triggering the task's execution:</span>
<span class="kw">val</span> f = task.runAsync {
  <span class="kw">case</span> Right(str: <span class="std">String</span>) <span class="kw">=&gt;</span>
    println(s<span class="lit">"Received: $$str"</span>)
  <span class="kw">case</span> Left(Cause.Termination(e)) <span class="kw">=&gt;</span>
    global.reportFailure(e)
  <span class="kw">case</span> Left(Cause.Error(str: <span class="std">String</span>)) <span class="kw">=&gt;</span>
    println(s<span class="lit">"Received expected error: $$str"</span>)
}

<span class="cmt">// Or in case we change our mind</span>
f.cancel()</pre><h4>BiCallback</h4><p>        When executing the task via this method, the user is
        required to supply a side effecting callback with the
        signature: <code>Either[Cause[E], A] =&gt; Unit</code>.</p><p>        This will be used by the implementation to signal completion,
        signaling either a <code>Right(value)</code> or a <code>Left(error)</code>.</p><p>        <code>BIO</code> however uses <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a>
        internally, so you can supply a <code>BiCallback</code> instance instead
        and it will be used to avoid unnecessary boxing. It also has
        handy utilities.</p><p>        Note that with <code>Callback</code> you can:</p><ul><li>convert from a plain function using <code>Either[Cause[E], A]</code> as input via
           <a href="BiCallback$.html#fromAttempt[E,A](cb:Either[monix.bio.Cause[E],A]=&gt;Unit):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#fromAttempt" id="monix.bio.BiCallback#fromAttempt" class="extmbr">BiCallback.fromAttempt</a></li><li>wrap a standard Scala <code>Promise</code> via
           <a href="BiCallback$.html#fromPromise[E,A](p:scala.concurrent.Promise[Either[E,A]]):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#fromPromise" id="monix.bio.BiCallback#fromPromise" class="extmbr">BiCallback.fromPromise</a></li><li>pass an empty callback that just reports errors via
           <a href="BiCallback$.html#empty[E,A](implicitr:monix.execution.UncaughtExceptionReporter):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#empty" id="monix.bio.BiCallback#empty" class="extmbr">BiCallback.empty</a></li></ul><p>Example, equivalent to the above:
doctodo</p><pre><span class="kw">import</span> monix.bio.BiCallback

task.runAsync(<span class="kw">new</span> BiCallback[<span class="std">String</span>, <span class="std">String</span>] {
  <span class="kw">def</span> onSuccess(str: <span class="std">String</span>) =
    println(s<span class="lit">"Received: $$str"</span>)
  <span class="kw">def</span> onError(e: <span class="std">String</span>) =
    println(s<span class="lit">"Received expected error: $$e"</span>)
  <span class="kw">def</span> onTermination(e: Throwable) =
    global.reportFailure(e)
})</pre><p>Example equivalent with <a href="#runAsyncAndForget(implicits:monix.execution.Scheduler):Unit" name="monix.bio.BIO#runAsyncAndForget" id="monix.bio.BIO#runAsyncAndForget" class="extmbr">runAsyncAndForget</a>:</p><pre>task.runAsync(BiCallback.empty)</pre><p>Completing a <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Promise.html" name="scala.concurrent.Promise" id="scala.concurrent.Promise" class="extype">scala.concurrent.Promise</a>:</p><pre><span class="kw">import</span> scala.concurrent.Promise

<span class="kw">val</span> p = Promise[Either[<span class="std">String</span>, <span class="std">String</span>]]()
task.runAsync(BiCallback.fromPromise(p))</pre><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p></div><dl class="paramcmts block"><dt class="param">cb</dt><dd class="cmt"><p>is a callback that will be invoked upon
        completion, either with a successful result, or with an error;
        note that you can use <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">monix.bio.BiCallback</a>
        for extra performance (avoids the boxing in <a href="https://www.scala-lang.org/api/2.13.1/scala/index.html#Either[+A,+B]=scala.util.Either[A,B]" name="scala" id="scala" class="extype">scala.Either</a>)</p></dd><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd><dt>returns</dt><dd class="cmt"><p>a <a href="https://monix.io/api/3.1/monix/execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a>
        that can be used to cancel a running task</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runAsyncAndForget" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runAsyncAndForget(implicits:monix.execution.Scheduler):Unit"></a><a id="runAsyncAndForget(Scheduler):Unit"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runAsyncAndForget(implicits:monix.execution.Scheduler):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runAsyncAndForget</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><p class="shortcomment cmt">Triggers the asynchronous execution of the source task
in a "fire and forget" fashion.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the asynchronous execution of the source task
in a "fire and forget" fashion.</p><p>Starts the execution of the task, but discards any result
generated asynchronously and doesn't return any cancelable
tokens either. This affords some optimizations — for example
the underlying run-loop doesn't need to worry about
cancelation. Also the call-site is more clear in intent.</p><p>Example:</p><pre><span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="kw">val</span> task = Task(println(<span class="lit">"Hello!"</span>))

<span class="cmt">// We don't care about the result, we don't care about the</span>
<span class="cmt">// cancellation token, we just want this thing to run:</span>
task.runAsyncAndForget</pre><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runAsyncAndForgetOpt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runAsyncAndForgetOpt(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):Unit"></a><a id="runAsyncAndForgetOpt(Scheduler,Options):Unit"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runAsyncAndForgetOpt(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runAsyncAndForgetOpt</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="opts">opts: <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><p class="shortcomment cmt">Triggers the asynchronous execution in a "fire and forget"
fashion, like normal <a href="#runAsyncAndForget(implicits:monix.execution.Scheduler):Unit" name="monix.bio.BIO#runAsyncAndForget" id="monix.bio.BIO#runAsyncAndForget" class="extmbr">runAsyncAndForget</a>, but includes the
ability to specify <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a> that
can modify the behavior of the run-loop.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the asynchronous execution in a "fire and forget"
fashion, like normal <a href="#runAsyncAndForget(implicits:monix.execution.Scheduler):Unit" name="monix.bio.BIO#runAsyncAndForget" id="monix.bio.BIO#runAsyncAndForget" class="extmbr">runAsyncAndForget</a>, but includes the
ability to specify <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a> that
can modify the behavior of the run-loop.</p><p>This allows you to specify options such as:</p><ul><li>enabling support for <a href="BIOLocal.html" name="monix.bio.BIOLocal" id="monix.bio.BIOLocal" class="extype">BIOLocal</a></li><li>disabling auto-cancelable run-loops</li></ul><p>See the description of <a href="#runAsyncOpt(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):monix.execution.Cancelable" name="monix.bio.BIO#runAsyncOpt" id="monix.bio.BIO#runAsyncOpt" class="extmbr">runAsyncOpt</a> for an example of customizing the
default <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a>.</p><p>See the description of <a href="#runAsyncAndForget(implicits:monix.execution.Scheduler):Unit" name="monix.bio.BIO#runAsyncAndForget" id="monix.bio.BIO#runAsyncAndForget" class="extmbr">runAsyncAndForget</a> for an example
of running as a "fire and forget".</p><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd><dt class="param">opts</dt><dd class="cmt"><p>a set of <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a>
        that determine the behavior of Task's run-loop.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runAsyncF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runAsyncF[E1&gt;:E](cb:Either[monix.bio.Cause[E1],A]=&gt;Unit)(implicits:monix.execution.Scheduler):cats.effect.CancelToken[monix.bio.UIO]"></a><a id="runAsyncF[E1&gt;:E]((Either[Cause[E1],A])=&gt;Unit)(Scheduler):CancelToken[UIO]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runAsyncF[E1&gt;:E](cb:Either[monix.bio.Cause[E1],A]=&gt;Unit)(implicits:monix.execution.Scheduler):cats.effect.CancelToken[monix.bio.UIO]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runAsyncF</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>]</span><span class="params">(<span name="cb">cb: (<span name="scala.Either" class="extype">Either</span>[<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BIO.runAsyncF.E1" class="extype">E1</span>], <span name="monix.bio.BIO.A" class="extype">A</span>]) =&gt; <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <span name="cats.effect.CancelToken" class="extype">CancelToken</span>[<a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>]</span></span><p class="shortcomment cmt">Triggers the asynchronous execution, returning a <code>Task[Unit]</code>
(aliased to <code>CancelToken[Task]</code> in Cats-Effect) which can
cancel the running computation.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the asynchronous execution, returning a <code>Task[Unit]</code>
(aliased to <code>CancelToken[Task]</code> in Cats-Effect) which can
cancel the running computation.</p><p>This is the more potent version of <a href="#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.BIO#runAsync" id="monix.bio.BIO#runAsync" class="extmbr">runAsync</a>,
because the returned cancelation token is a <code>Task[Unit]</code> that
can be used to back-pressure on the result of the cancellation
token, in case the finalizers are specified as asynchronous
actions that are expensive to complete.</p><p>Example:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="kw">val</span> task = Task(<span class="lit">"Hello!"</span>).bracketCase { str <span class="kw">=&gt;</span>
  Task(println(str))
} { (_, exitCode) <span class="kw">=&gt;</span>
  <span class="cmt">// Finalization</span>
  UIO(println(s<span class="lit">"Finished via exit code: $$exitCode"</span>))
    .delayExecution(<span class="num">3.</span>seconds)
}</pre><p>In this example we have a task with a registered finalizer
(via <a href="#bracketCase[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,cats.effect.ExitCase[monix.bio.Cause[E1]])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracketCase" id="monix.bio.BIO#bracketCase" class="extmbr">bracketCase</a>) that takes 3 whole seconds to finish.
Via normal <code>runAsync</code> the returned cancelation token has no
capability to wait for its completion.</p><pre><span class="kw">import</span> monix.execution.Callback
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="kw">val</span> cancel = task.runAsyncF(Callback.empty)

<span class="cmt">// Triggering `cancel` and we can wait for its completion</span>
<span class="kw">for</span> (_ <span class="kw">&lt;-</span> cancel.runToFuture) {
  <span class="cmt">// Takes 3 seconds to print</span>
  println(<span class="lit">"Resources were released!"</span>)
}</pre><p>WARN: back-pressuring on the completion of finalizers is not
always a good idea. Avoid it if you can.</p><h4>BiCallback</h4><p>        When executing the task via this method, the user is
        required to supply a side effecting callback with the
        signature: <code>Either[Cause[E], A] =&gt; Unit</code>.</p><p>        This will be used by the implementation to signal completion,
        signaling either a <code>Right(value)</code> or a <code>Left(error)</code>.</p><p>        <code>BIO</code> however uses <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a>
        internally, so you can supply a <code>BiCallback</code> instance instead
        and it will be used to avoid unnecessary boxing. It also has
        handy utilities.</p><p>        Note that with <code>Callback</code> you can:</p><ul><li>convert from a plain function using <code>Either[Cause[E], A]</code> as input via
           <a href="BiCallback$.html#fromAttempt[E,A](cb:Either[monix.bio.Cause[E],A]=&gt;Unit):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#fromAttempt" id="monix.bio.BiCallback#fromAttempt" class="extmbr">BiCallback.fromAttempt</a></li><li>wrap a standard Scala <code>Promise</code> via
           <a href="BiCallback$.html#fromPromise[E,A](p:scala.concurrent.Promise[Either[E,A]]):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#fromPromise" id="monix.bio.BiCallback#fromPromise" class="extmbr">BiCallback.fromPromise</a></li><li>pass an empty callback that just reports errors via
           <a href="BiCallback$.html#empty[E,A](implicitr:monix.execution.UncaughtExceptionReporter):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#empty" id="monix.bio.BiCallback#empty" class="extmbr">BiCallback.empty</a></li></ul><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p><p>NOTE: the <code>F</code> suffix comes from <code>F[_]</code>, highlighting our usage
of <code>CancelToken[F]</code> to return a <code>Task[Unit]</code>, instead of a
plain and side effectful <code>Cancelable</code> object.
</p></div><dl class="paramcmts block"><dt class="param">cb</dt><dd class="cmt"><p>is a callback that will be invoked upon
        completion, either with a successful result, or with an error;
        note that you can use <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">monix.bio.BiCallback</a>
        for extra performance (avoids the boxing in <a href="https://www.scala-lang.org/api/2.13.1/scala/index.html#Either[+A,+B]=scala.util.Either[A,B]" name="scala" id="scala" class="extype">scala.Either</a>)</p></dd><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd><dt>returns</dt><dd class="cmt"><p>a <code>Task[Unit]</code>, aliased via Cats-Effect
        as a <code>CancelToken[Task]</code>, that can be used to cancel the
        running task. Given that this is a <code>Task</code>, it can describe
        asynchronous finalizers (if the source had any), therefore
        users can apply back-pressure on the completion of such
        finalizers.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runAsyncOpt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runAsyncOpt(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):monix.execution.Cancelable"></a><a id="runAsyncOpt((Either[Cause[E],A])=&gt;Unit)(Scheduler,Options):Cancelable"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runAsyncOpt(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):monix.execution.Cancelable" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runAsyncOpt</span><span class="params">(<span name="cb">cb: (<span name="scala.Either" class="extype">Either</span>[<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BIO.E" class="extype">E</span>], <span name="monix.bio.BIO.A" class="extype">A</span>]) =&gt; <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="opts">opts: <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a></span>)</span><span class="result">: <a href="https://monix.io/api/3.1/monix/execution/Cancelable.html#monix.execution.Cancelable" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a></span></span><p class="shortcomment cmt">Triggers the asynchronous execution, much like normal <a href="#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.BIO#runAsync" id="monix.bio.BIO#runAsync" class="extmbr">runAsync</a>, but
includes the ability to specify <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a>
that can modify the behavior of the run-loop.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the asynchronous execution, much like normal <a href="#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.BIO#runAsync" id="monix.bio.BIO#runAsync" class="extmbr">runAsync</a>, but
includes the ability to specify <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a>
that can modify the behavior of the run-loop.</p><p>This allows you to specify options such as:</p><ul><li>enabling support for <a href="BIOLocal.html" name="monix.bio.BIOLocal" id="monix.bio.BIOLocal" class="extype">BIOLocal</a></li><li>disabling auto-cancelable run-loops</li></ul><p>Example:</p><pre><span class="kw">import</span> monix.bio.Cause
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="kw">val</span> task =
  <span class="kw">for</span> {
    local <span class="kw">&lt;-</span> BIOLocal(<span class="num">0</span>)
    _     <span class="kw">&lt;-</span> local.write(<span class="num">100</span>)
    _     <span class="kw">&lt;-</span> BIO.shift
    value <span class="kw">&lt;-</span> local.read
  } <span class="kw">yield</span> value

<span class="cmt">// We need to activate support of BIOLocal via:</span>
<span class="kw">implicit</span> <span class="kw">val</span> opts = BIO.defaultOptions.enableLocalContextPropagation

<span class="cmt">// Actual execution that depends on these custom options:</span>
task.runAsyncOpt {
  <span class="kw">case</span> Right(value) <span class="kw">=&gt;</span>
    println(s<span class="lit">"Received: $$value"</span>)
  <span class="kw">case</span> Left(Cause.Termination(e)) <span class="kw">=&gt;</span>
    global.reportFailure(e)
  <span class="kw">case</span> Left(Cause.Error(str)) <span class="kw">=&gt;</span>
    println(s<span class="lit">"Received typed error: $$str"</span>)
}</pre><p>See <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a>.</p><h4>BiCallback</h4><p>        When executing the task via this method, the user is
        required to supply a side effecting callback with the
        signature: <code>Either[Cause[E], A] =&gt; Unit</code>.</p><p>        This will be used by the implementation to signal completion,
        signaling either a <code>Right(value)</code> or a <code>Left(error)</code>.</p><p>        <code>BIO</code> however uses <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a>
        internally, so you can supply a <code>BiCallback</code> instance instead
        and it will be used to avoid unnecessary boxing. It also has
        handy utilities.</p><p>        Note that with <code>Callback</code> you can:</p><ul><li>convert from a plain function using <code>Either[Cause[E], A]</code> as input via
           <a href="BiCallback$.html#fromAttempt[E,A](cb:Either[monix.bio.Cause[E],A]=&gt;Unit):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#fromAttempt" id="monix.bio.BiCallback#fromAttempt" class="extmbr">BiCallback.fromAttempt</a></li><li>wrap a standard Scala <code>Promise</code> via
           <a href="BiCallback$.html#fromPromise[E,A](p:scala.concurrent.Promise[Either[E,A]]):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#fromPromise" id="monix.bio.BiCallback#fromPromise" class="extmbr">BiCallback.fromPromise</a></li><li>pass an empty callback that just reports errors via
           <a href="BiCallback$.html#empty[E,A](implicitr:monix.execution.UncaughtExceptionReporter):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#empty" id="monix.bio.BiCallback#empty" class="extmbr">BiCallback.empty</a></li></ul><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p></div><dl class="paramcmts block"><dt class="param">cb</dt><dd class="cmt"><p>is a callback that will be invoked upon
        completion, either with a successful result, or with an error;
        note that you can use <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">monix.bio.BiCallback</a>
        for extra performance (avoids the boxing in <a href="https://www.scala-lang.org/api/2.13.1/scala/index.html#Either[+A,+B]=scala.util.Either[A,B]" name="scala" id="scala" class="extype">scala.Either</a>)</p></dd><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd><dt class="param">opts</dt><dd class="cmt"><p>a set of <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a>
        that determine the behavior of Task's run-loop.</p></dd><dt>returns</dt><dd class="cmt"><p>a <a href="https://monix.io/api/3.1/monix/execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a>
        that can be used to cancel a running task</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runAsyncOptF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runAsyncOptF[E1&gt;:E](cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):cats.effect.CancelToken[monix.bio.UIO]"></a><a id="runAsyncOptF[E1&gt;:E]((Either[Cause[E],A])=&gt;Unit)(Scheduler,Options):CancelToken[UIO]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runAsyncOptF[E1&gt;:E](cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):cats.effect.CancelToken[monix.bio.UIO]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runAsyncOptF</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>]</span><span class="params">(<span name="cb">cb: (<span name="scala.Either" class="extype">Either</span>[<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BIO.E" class="extype">E</span>], <span name="monix.bio.BIO.A" class="extype">A</span>]) =&gt; <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="opts">opts: <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a></span>)</span><span class="result">: <span name="cats.effect.CancelToken" class="extype">CancelToken</span>[<a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>]</span></span><p class="shortcomment cmt">Triggers the asynchronous execution, much like normal <a href="#runAsyncF[E1&gt;:E](cb:Either[monix.bio.Cause[E1],A]=&gt;Unit)(implicits:monix.execution.Scheduler):cats.effect.CancelToken[monix.bio.UIO]" name="monix.bio.BIO#runAsyncF" id="monix.bio.BIO#runAsyncF" class="extmbr">runAsyncF</a>, but
includes the ability to specify <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a>
that can modify the behavior of the run-loop.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the asynchronous execution, much like normal <a href="#runAsyncF[E1&gt;:E](cb:Either[monix.bio.Cause[E1],A]=&gt;Unit)(implicits:monix.execution.Scheduler):cats.effect.CancelToken[monix.bio.UIO]" name="monix.bio.BIO#runAsyncF" id="monix.bio.BIO#runAsyncF" class="extmbr">runAsyncF</a>, but
includes the ability to specify <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a>
that can modify the behavior of the run-loop.</p><p>This allows you to specify options such as:</p><ul><li>enabling support for <a href="BIOLocal.html" name="monix.bio.BIOLocal" id="monix.bio.BIOLocal" class="extype">BIOLocal</a></li><li>disabling auto-cancelable run-loops</li></ul><p>See the description of <a href="#runToFutureOpt(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.BIO#runToFutureOpt" id="monix.bio.BIO#runToFutureOpt" class="extmbr">runToFutureOpt</a> for an example.</p><p>The returned cancelation token is a <code>Task[Unit]</code> that
can be used to back-pressure on the result of the cancellation
token, in case the finalizers are specified as asynchronous
actions that are expensive to complete.</p><p>See the description of <a href="#runAsyncF[E1&gt;:E](cb:Either[monix.bio.Cause[E1],A]=&gt;Unit)(implicits:monix.execution.Scheduler):cats.effect.CancelToken[monix.bio.UIO]" name="monix.bio.BIO#runAsyncF" id="monix.bio.BIO#runAsyncF" class="extmbr">runAsyncF</a> for an example.</p><p>WARN: back-pressuring on the completion of finalizers is not
always a good idea. Avoid it if you can.</p><h4>BiCallback</h4><p>        When executing the task via this method, the user is
        required to supply a side effecting callback with the
        signature: <code>Either[Cause[E], A] =&gt; Unit</code>.</p><p>        This will be used by the implementation to signal completion,
        signaling either a <code>Right(value)</code> or a <code>Left(error)</code>.</p><p>        <code>BIO</code> however uses <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a>
        internally, so you can supply a <code>BiCallback</code> instance instead
        and it will be used to avoid unnecessary boxing. It also has
        handy utilities.</p><p>        Note that with <code>Callback</code> you can:</p><ul><li>convert from a plain function using <code>Either[Cause[E], A]</code> as input via
           <a href="BiCallback$.html#fromAttempt[E,A](cb:Either[monix.bio.Cause[E],A]=&gt;Unit):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#fromAttempt" id="monix.bio.BiCallback#fromAttempt" class="extmbr">BiCallback.fromAttempt</a></li><li>wrap a standard Scala <code>Promise</code> via
           <a href="BiCallback$.html#fromPromise[E,A](p:scala.concurrent.Promise[Either[E,A]]):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#fromPromise" id="monix.bio.BiCallback#fromPromise" class="extmbr">BiCallback.fromPromise</a></li><li>pass an empty callback that just reports errors via
           <a href="BiCallback$.html#empty[E,A](implicitr:monix.execution.UncaughtExceptionReporter):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#empty" id="monix.bio.BiCallback#empty" class="extmbr">BiCallback.empty</a></li></ul><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p><p>NOTE: the <code>F</code> suffix comes from <code>F[_]</code>, highlighting our usage
of <code>CancelToken[F]</code> to return a <code>Task[Unit]</code>, instead of a
plain and side effectful <code>Cancelable</code> object.
</p></div><dl class="paramcmts block"><dt class="param">cb</dt><dd class="cmt"><p>is a callback that will be invoked upon
        completion, either with a successful result, or with an error;
        note that you can use <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">monix.bio.BiCallback</a>
        for extra performance (avoids the boxing in <a href="https://www.scala-lang.org/api/2.13.1/scala/index.html#Either[+A,+B]=scala.util.Either[A,B]" name="scala" id="scala" class="extype">scala.Either</a>)</p></dd><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd><dt class="param">opts</dt><dd class="cmt"><p>a set of <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a>
        that determine the behavior of Task's run-loop.</p></dd><dt>returns</dt><dd class="cmt"><p>a <code>Task[Unit]</code>, aliased via Cats-Effect
        as a <code>CancelToken[Task]</code>, that can be used to cancel the
        running task. Given that this is a <code>Task</code>, it can describe
        asynchronous finalizers (if the source had any), therefore
        users can apply back-pressure on the completion of such
        finalizers.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runAsyncUncancelable" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runAsyncUncancelable(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):Unit"></a><a id="runAsyncUncancelable((Either[Cause[E],A])=&gt;Unit)(Scheduler):Unit"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runAsyncUncancelable(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runAsyncUncancelable</span><span class="params">(<span name="cb">cb: (<span name="scala.Either" class="extype">Either</span>[<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BIO.E" class="extype">E</span>], <span name="monix.bio.BIO.A" class="extype">A</span>]) =&gt; <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><p class="shortcomment cmt">Triggers the asynchronous execution of the source task,
but runs it in uncancelable mode.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the asynchronous execution of the source task,
but runs it in uncancelable mode.</p><p>This is an optimization over plain <a href="#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.BIO#runAsync" id="monix.bio.BIO#runAsync" class="extmbr">runAsync</a> or <a href="#runAsyncF[E1&gt;:E](cb:Either[monix.bio.Cause[E1],A]=&gt;Unit)(implicits:monix.execution.Scheduler):cats.effect.CancelToken[monix.bio.UIO]" name="monix.bio.BIO#runAsyncF" id="monix.bio.BIO#runAsyncF" class="extmbr">runAsyncF</a> that
doesn't give you a cancellation token for cancelling the task. The runtime
can thus not worry about keeping state related to cancellation when
evaluating it.</p><pre><span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> monix.bio.Cause
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="kw">val</span> task: BIO[<span class="std">String</span>, <span class="std">String</span>] =
  <span class="kw">for</span> {
    _ <span class="kw">&lt;-</span> BIO.sleep(<span class="num">3.</span>seconds)
    r <span class="kw">&lt;-</span> UIO { println(<span class="lit">"Executing..."</span>); <span class="lit">"Hello!"</span> }
  } <span class="kw">yield</span> r

<span class="cmt">// Triggering the task's execution, without receiving any</span>
<span class="cmt">// cancelation tokens</span>
task.runAsyncUncancelable {
  <span class="kw">case</span> Right(str) <span class="kw">=&gt;</span>
    println(s<span class="lit">"Received: $$str"</span>)
  <span class="kw">case</span> Left(Cause.Termination(e)) <span class="kw">=&gt;</span>
    global.reportFailure(e)
  <span class="kw">case</span> Left(Cause.Error(str)) <span class="kw">=&gt;</span>
    println(s<span class="lit">"Received typed error: $$str"</span>)
}</pre><h4>BiCallback</h4><p>        When executing the task via this method, the user is
        required to supply a side effecting callback with the
        signature: <code>Either[Cause[E], A] =&gt; Unit</code>.</p><p>        This will be used by the implementation to signal completion,
        signaling either a <code>Right(value)</code> or a <code>Left(error)</code>.</p><p>        <code>BIO</code> however uses <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a>
        internally, so you can supply a <code>BiCallback</code> instance instead
        and it will be used to avoid unnecessary boxing. It also has
        handy utilities.</p><p>        Note that with <code>Callback</code> you can:</p><ul><li>convert from a plain function using <code>Either[Cause[E], A]</code> as input via
           <a href="BiCallback$.html#fromAttempt[E,A](cb:Either[monix.bio.Cause[E],A]=&gt;Unit):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#fromAttempt" id="monix.bio.BiCallback#fromAttempt" class="extmbr">BiCallback.fromAttempt</a></li><li>wrap a standard Scala <code>Promise</code> via
           <a href="BiCallback$.html#fromPromise[E,A](p:scala.concurrent.Promise[Either[E,A]]):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#fromPromise" id="monix.bio.BiCallback#fromPromise" class="extmbr">BiCallback.fromPromise</a></li><li>pass an empty callback that just reports errors via
           <a href="BiCallback$.html#empty[E,A](implicitr:monix.execution.UncaughtExceptionReporter):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#empty" id="monix.bio.BiCallback#empty" class="extmbr">BiCallback.empty</a></li></ul><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runAsyncUncancelableOpt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runAsyncUncancelableOpt(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):Unit"></a><a id="runAsyncUncancelableOpt((Either[Cause[E],A])=&gt;Unit)(Scheduler,Options):Unit"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runAsyncUncancelableOpt(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runAsyncUncancelableOpt</span><span class="params">(<span name="cb">cb: (<span name="scala.Either" class="extype">Either</span>[<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BIO.E" class="extype">E</span>], <span name="monix.bio.BIO.A" class="extype">A</span>]) =&gt; <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="opts">opts: <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><p class="shortcomment cmt">Triggers the asynchronous execution in uncancelable mode,
like <a href="#runAsyncUncancelable(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):Unit" name="monix.bio.BIO#runAsyncUncancelable" id="monix.bio.BIO#runAsyncUncancelable" class="extmbr">runAsyncUncancelable</a>, but includes the ability to
specify <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a> that can modify
the behavior of the run-loop.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the asynchronous execution in uncancelable mode,
like <a href="#runAsyncUncancelable(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):Unit" name="monix.bio.BIO#runAsyncUncancelable" id="monix.bio.BIO#runAsyncUncancelable" class="extmbr">runAsyncUncancelable</a>, but includes the ability to
specify <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a> that can modify
the behavior of the run-loop.</p><p>This allows you to specify options such as:</p><ul><li>enabling support for <a href="BIOLocal.html" name="monix.bio.BIOLocal" id="monix.bio.BIOLocal" class="extype">BIOLocal</a></li><li>disabling auto-cancelable run-loops</li></ul><p>See the description of <a href="#runAsyncOpt(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):monix.execution.Cancelable" name="monix.bio.BIO#runAsyncOpt" id="monix.bio.BIO#runAsyncOpt" class="extmbr">runAsyncOpt</a> for an example of customizing the
default <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a>.</p><p>This is an optimization over plain <a href="#runAsyncOpt(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):monix.execution.Cancelable" name="monix.bio.BIO#runAsyncOpt" id="monix.bio.BIO#runAsyncOpt" class="extmbr">runAsyncOpt</a> or
<a href="#runAsyncOptF[E1&gt;:E](cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):cats.effect.CancelToken[monix.bio.UIO]" name="monix.bio.BIO#runAsyncOptF" id="monix.bio.BIO#runAsyncOptF" class="extmbr">runAsyncOptF</a> that doesn't give you a cancellation token for
cancelling the task. The runtime can thus not worry about
keeping state related to cancellation when evaluating it.</p><h4>BiCallback</h4><p>        When executing the task via this method, the user is
        required to supply a side effecting callback with the
        signature: <code>Either[Cause[E], A] =&gt; Unit</code>.</p><p>        This will be used by the implementation to signal completion,
        signaling either a <code>Right(value)</code> or a <code>Left(error)</code>.</p><p>        <code>BIO</code> however uses <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a>
        internally, so you can supply a <code>BiCallback</code> instance instead
        and it will be used to avoid unnecessary boxing. It also has
        handy utilities.</p><p>        Note that with <code>Callback</code> you can:</p><ul><li>convert from a plain function using <code>Either[Cause[E], A]</code> as input via
           <a href="BiCallback$.html#fromAttempt[E,A](cb:Either[monix.bio.Cause[E],A]=&gt;Unit):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#fromAttempt" id="monix.bio.BiCallback#fromAttempt" class="extmbr">BiCallback.fromAttempt</a></li><li>wrap a standard Scala <code>Promise</code> via
           <a href="BiCallback$.html#fromPromise[E,A](p:scala.concurrent.Promise[Either[E,A]]):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#fromPromise" id="monix.bio.BiCallback#fromPromise" class="extmbr">BiCallback.fromPromise</a></li><li>pass an empty callback that just reports errors via
           <a href="BiCallback$.html#empty[E,A](implicitr:monix.execution.UncaughtExceptionReporter):monix.bio.BiCallback[E,A]" name="monix.bio.BiCallback#empty" id="monix.bio.BiCallback#empty" class="extmbr">BiCallback.empty</a></li></ul></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd><dt class="param">opts</dt><dd class="cmt"><p>a set of <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a>
        that determine the behavior of Task's run-loop.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runSyncStep" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runSyncStep(implicits:monix.execution.Scheduler):Either[monix.bio.BIO[E,A],A]"></a><a id="runSyncStep(Scheduler):Either[BIO[E,A],A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runSyncStep(implicits:monix.execution.Scheduler):Either[monix.bio.BIO[E,A],A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runSyncStep</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <span name="scala.Either" class="extype">Either</span>[<a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>], <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the source until completion, or until the first async
boundary, whichever comes first.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the source until completion, or until the first async
boundary, whichever comes first.</p><p>This operation is mean to be compliant with
<code>cats.effect.Effect.runSyncStep</code>, but without suspending the
evaluation in <code>IO</code>.</p><p>WARNING: This method is a partial function, throwing exceptions
in case errors happen immediately (synchronously).</p><p>Usage sample:</p><pre><span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">import</span> scala.util._
<span class="kw">import</span> scala.util.control.NonFatal

<span class="kw">try</span> Task(<span class="num">42</span>).runSyncStep <span class="kw">match</span> {
  <span class="kw">case</span> Right(a) <span class="kw">=&gt;</span> println(<span class="lit">"Success: "</span> + a)
  <span class="kw">case</span> Left(task) <span class="kw">=&gt;</span>
    task.runToFuture.onComplete {
      <span class="kw">case</span> Success(a) <span class="kw">=&gt;</span> println(<span class="lit">"Async success: "</span> + a)
      <span class="kw">case</span> Failure(e) <span class="kw">=&gt;</span> println(<span class="lit">"Async error: "</span> + e)
    }
} <span class="kw">catch</span> {
  <span class="kw">case</span> NonFatal(e) <span class="kw">=&gt;</span>
    println(<span class="lit">"Error: "</span> + e)
}</pre><p>Obviously the purpose of this method is to be used for
optimizations.</p><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd><dt>returns</dt><dd class="cmt"><p><code>Right(result)</code> in case a result was processed,
        or <code>Left(task)</code> in case an asynchronous boundary
        was hit and further async execution is needed</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#runSyncUnsafe(timeout:scala.concurrent.duration.Duration)(implicits:monix.execution.Scheduler,implicitpermit:monix.execution.schedulers.CanBlock,implicitev:E&lt;:&lt;Throwable):A" name="monix.bio.BIO#runSyncUnsafe" id="monix.bio.BIO#runSyncUnsafe" class="extmbr">runSyncUnsafe</a>, the blocking execution mode that can
     only work on top of the JVM.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runSyncStepOpt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runSyncStepOpt(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):Either[monix.bio.BIO[E,A],A]"></a><a id="runSyncStepOpt(Scheduler,Options):Either[BIO[E,A],A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runSyncStepOpt(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):Either[monix.bio.BIO[E,A],A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runSyncStepOpt</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="opts">opts: <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a></span>)</span><span class="result">: <span name="scala.Either" class="extype">Either</span>[<a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>], <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">A variant of <a href="#runSyncStep(implicits:monix.execution.Scheduler):Either[monix.bio.BIO[E,A],A]" name="monix.bio.BIO#runSyncStep" id="monix.bio.BIO#runSyncStep" class="extmbr">runSyncStep</a> that takes an implicit
<a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a> from the current scope.</p><div class="fullcomment"><div class="comment cmt"><p>A variant of <a href="#runSyncStep(implicits:monix.execution.Scheduler):Either[monix.bio.BIO[E,A],A]" name="monix.bio.BIO#runSyncStep" id="monix.bio.BIO#runSyncStep" class="extmbr">runSyncStep</a> that takes an implicit
<a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a> from the current scope.</p><p>This helps in tuning the evaluation model of task.</p><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd><dt class="param">opts</dt><dd class="cmt"><p>a set of <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a>
        that determine the behavior of Task's run-loop.</p></dd><dt>returns</dt><dd class="cmt"><p><code>Right(result)</code> in case a result was processed,
        or <code>Left(task)</code> in case an asynchronous boundary
        was hit and further async execution is needed</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#runSyncStep(implicits:monix.execution.Scheduler):Either[monix.bio.BIO[E,A],A]" name="monix.bio.BIO#runSyncStep" id="monix.bio.BIO#runSyncStep" class="extmbr">runSyncStep</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runSyncUnsafe" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runSyncUnsafe(timeout:scala.concurrent.duration.Duration)(implicits:monix.execution.Scheduler,implicitpermit:monix.execution.schedulers.CanBlock,implicitev:E&lt;:&lt;Throwable):A"></a><a id="runSyncUnsafe(Duration)(Scheduler,CanBlock,&lt;:&lt;[E,Throwable]):A"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runSyncUnsafe(timeout:scala.concurrent.duration.Duration)(implicits:monix.execution.Scheduler,implicitpermit:monix.execution.schedulers.CanBlock,implicitev:E&lt;:&lt;Throwable):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runSyncUnsafe</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/Duration.html#scala.concurrent.duration.Duration" name="scala.concurrent.duration.Duration" id="scala.concurrent.duration.Duration" class="extype">Duration</a> = <span class="symbol">Duration.Inf</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="permit">permit: <a href="https://monix.io/api/3.1/monix/execution/schedulers/CanBlock.html#monix.execution.schedulers.CanBlock" name="monix.execution.schedulers.CanBlock" id="monix.execution.schedulers.CanBlock" class="extype">CanBlock</a></span>, <span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="scala.Throwable" class="extype">Throwable</span>]</span>)</span><span class="result">: <span name="monix.bio.BIO.A" class="extype">A</span></span></span><p class="shortcomment cmt">Evaluates the source task synchronously and returns the result
immediately or blocks the underlying thread until the result is
ready.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the source task synchronously and returns the result
immediately or blocks the underlying thread until the result is
ready.</p><p>The method requires error type to be <code>Throwable</code>. Note that it will work for
<code>Nothing</code> (<code>UIO</code>) as well so if you have a different type then you can use
<code>task.attempt.runSyncUnsafe</code> to receive <code>Either[E, A]</code> or any other error handling operator.</p><p><b>WARNING:</b> blocking operations are unsafe and incredibly
error prone on top of the JVM. It's a good practice to not block
any threads and use the asynchronous <code>runAsync</code> methods instead.</p><p>In general prefer to use the asynchronous <a href="#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.BIO#runAsync" id="monix.bio.BIO#runAsync" class="extmbr">BIO.runAsync</a> or
<a href="#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.BIO#runToFuture" id="monix.bio.BIO#runToFuture" class="extmbr">BIO.runToFuture</a> and to structure your logic around asynchronous
actions in a non-blocking way. But in case you're blocking only once, in
<code>main</code>, at the "edge of the world" so to speak, then it's OK.</p><p>Sample:</p><pre><span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">import</span> scala.concurrent.duration._

Task(<span class="num">42</span>).runSyncUnsafe(<span class="num">3.</span>seconds)</pre><p>This is equivalent with:</p><pre><span class="kw">import</span> scala.concurrent.Await

Await.result[<span class="std">Int</span>](Task(<span class="num">42</span>).runToFuture, <span class="num">3.</span>seconds)</pre><p>Some implementation details:</p><ul><li>blocking the underlying thread is done by triggering Scala's
   <code>BlockingContext</code> (<code>scala.concurrent.blocking</code>), just like
   Scala's <code>Await.result</code></li><li>the <code>timeout</code> is mandatory, just like when using Scala's
   <code>Await.result</code>, in order to make the caller aware that the
   operation is dangerous and that setting a <code>timeout</code> is good
   practice</li><li>the loop starts in an execution mode that ignores
   <a href="https://monix.io/api/3.1/monix/execution/ExecutionModel$$BatchedExecution.html" name="monix.execution.ExecutionModel.BatchedExecution" id="monix.execution.ExecutionModel.BatchedExecution" class="extype">BatchedExecution</a> or
   <a href="https://monix.io/api/3.1/monix/execution/ExecutionModel$$AlwaysAsyncExecution$.html" name="monix.execution.ExecutionModel.AlwaysAsyncExecution" id="monix.execution.ExecutionModel.AlwaysAsyncExecution" class="extype">AlwaysAsyncExecution</a>,
   until the first asynchronous boundary. This is because we want to block
   the underlying thread for the result, in which case preserving
   fairness by forcing (batched) async boundaries doesn't do us any good,
   quite the contrary, the underlying thread being stuck until the result
   is available or until the timeout exception gets triggered.</li></ul><p>Not supported on top of JavaScript engines and trying to use it
with Scala.js will trigger a compile time error.</p><p>For optimizations on top of JavaScript you can use
<a href="#runSyncStep(implicits:monix.execution.Scheduler):Either[monix.bio.BIO[E,A],A]" name="monix.bio.BIO#runSyncStep" id="monix.bio.BIO#runSyncStep" class="extmbr">runSyncStep</a> instead.</p><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>is a duration that specifies the
        maximum amount of time that this operation is allowed to block the
        underlying thread. If the timeout expires before the result is ready,
        a <code>TimeoutException</code> gets thrown. Note that you're allowed to
        pass an infinite duration (with <code>Duration.Inf</code>), but unless
        it's <code>main</code> that you're blocking and unless you're doing it only
        once, then this is definitely not recommended — provide a finite
        timeout in order to avoid deadlocks.</p></dd><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd><dt class="param">permit</dt><dd class="cmt"><p>is an implicit value that's only available for
        the JVM and not for JavaScript, its purpose being to stop usage of
        this operation on top of engines that do not support blocking threads.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> <span class="name">@UnsafeBecauseBlocking</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runSyncUnsafeOpt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runSyncUnsafeOpt(timeout:scala.concurrent.duration.Duration)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options,implicitpermit:monix.execution.schedulers.CanBlock,implicitev:E&lt;:&lt;Throwable):A"></a><a id="runSyncUnsafeOpt(Duration)(Scheduler,Options,CanBlock,&lt;:&lt;[E,Throwable]):A"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runSyncUnsafeOpt(timeout:scala.concurrent.duration.Duration)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options,implicitpermit:monix.execution.schedulers.CanBlock,implicitev:E&lt;:&lt;Throwable):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runSyncUnsafeOpt</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/Duration.html#scala.concurrent.duration.Duration" name="scala.concurrent.duration.Duration" id="scala.concurrent.duration.Duration" class="extype">Duration</a> = <span class="symbol">Duration.Inf</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="opts">opts: <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a></span>, <span name="permit">permit: <a href="https://monix.io/api/3.1/monix/execution/schedulers/CanBlock.html#monix.execution.schedulers.CanBlock" name="monix.execution.schedulers.CanBlock" id="monix.execution.schedulers.CanBlock" class="extype">CanBlock</a></span>, <span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="scala.Throwable" class="extype">Throwable</span>]</span>)</span><span class="result">: <span name="monix.bio.BIO.A" class="extype">A</span></span></span><p class="shortcomment cmt">Variant of <a href="#runSyncUnsafe(timeout:scala.concurrent.duration.Duration)(implicits:monix.execution.Scheduler,implicitpermit:monix.execution.schedulers.CanBlock,implicitev:E&lt;:&lt;Throwable):A" name="monix.bio.BIO#runSyncUnsafe" id="monix.bio.BIO#runSyncUnsafe" class="extmbr">runSyncUnsafe</a> that takes a <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a>
implicitly from the scope in order to tune the evaluation model
of the task.</p><div class="fullcomment"><div class="comment cmt"><p>Variant of <a href="#runSyncUnsafe(timeout:scala.concurrent.duration.Duration)(implicits:monix.execution.Scheduler,implicitpermit:monix.execution.schedulers.CanBlock,implicitev:E&lt;:&lt;Throwable):A" name="monix.bio.BIO#runSyncUnsafe" id="monix.bio.BIO#runSyncUnsafe" class="extmbr">runSyncUnsafe</a> that takes a <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a>
implicitly from the scope in order to tune the evaluation model
of the task.</p><p>This allows you to specify options such as:</p><ul><li>enabling support for <a href="BIOLocal.html" name="monix.bio.BIOLocal" id="monix.bio.BIOLocal" class="extype">BIOLocal</a></li><li>disabling auto-cancelable run-loops</li></ul><p>See the description of <a href="#runAsyncOpt(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options):monix.execution.Cancelable" name="monix.bio.BIO#runAsyncOpt" id="monix.bio.BIO#runAsyncOpt" class="extmbr">runAsyncOpt</a> for an example of
customizing the default <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a>.</p><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>is a duration that specifies the
        maximum amount of time that this operation is allowed to block the
        underlying thread. If the timeout expires before the result is ready,
        a <code>TimeoutException</code> gets thrown. Note that you're allowed to
        pass an infinite duration (with <code>Duration.Inf</code>), but unless
        it's <code>main</code> that you're blocking and unless you're doing it only
        once, then this is definitely not recommended — provide a finite
        timeout in order to avoid deadlocks.</p></dd><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd><dt class="param">opts</dt><dd class="cmt"><p>a set of <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a>
        that determine the behavior of Task's run-loop.</p></dd><dt class="param">permit</dt><dd class="cmt"><p>is an implicit value that's only available for
        the JVM and not for JavaScript, its purpose being to stop usage of
        this operation on top of engines that do not support blocking threads.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> <span class="name">@UnsafeBecauseBlocking</span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#runSyncUnsafe(timeout:scala.concurrent.duration.Duration)(implicits:monix.execution.Scheduler,implicitpermit:monix.execution.schedulers.CanBlock,implicitev:E&lt;:&lt;Throwable):A" name="monix.bio.BIO#runSyncUnsafe" id="monix.bio.BIO#runSyncUnsafe" class="extmbr">runSyncUnsafe</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runToFuture" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]"></a><a id="runToFuture(Scheduler,&lt;:&lt;[E,Throwable]):CancelableFuture[A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runToFuture</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="scala.Throwable" class="extype">Throwable</span>]</span>)</span><span class="result">: <a href="https://monix.io/api/3.1/monix/execution/CancelableFuture.html#monix.execution.CancelableFuture" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a>[<span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Triggers the asynchronous execution, returning a cancelable
<a href="https://monix.io/api/3.1/monix/execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a> that can
be awaited for the final result or canceled.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the asynchronous execution, returning a cancelable
<a href="https://monix.io/api/3.1/monix/execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a> that can
be awaited for the final result or canceled.</p><p>Note that without invoking <code>runAsync</code> on a <code>Task</code>, nothing
gets evaluated, as a <code>Task</code> has lazy behavior.</p><pre><span class="kw">import</span> scala.concurrent.duration._
<span class="cmt">// A Scheduler is needed for executing tasks via `runAsync`</span>
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="cmt">// Nothing executes yet</span>
<span class="kw">val</span> task: Task[<span class="std">String</span>] =
  <span class="kw">for</span> {
    _ <span class="kw">&lt;-</span> Task.sleep(<span class="num">3.</span>seconds)
    r <span class="kw">&lt;-</span> Task { println(<span class="lit">"Executing..."</span>); <span class="lit">"Hello!"</span> }
  } <span class="kw">yield</span> r


<span class="cmt">// Triggering the task's execution:</span>
<span class="kw">val</span> f = task.runToFuture

<span class="cmt">// Or in case we change our mind</span>
f.cancel()</pre><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p><p>BAD CODE:</p><pre><span class="kw">import</span> monix.execution.CancelableFuture
<span class="kw">import</span> scala.concurrent.Await

<span class="cmt">// ANTI-PATTERN 1: Unnecessary side effects</span>
<span class="kw">def</span> increment1(sample: UIO[<span class="std">Int</span>]): CancelableFuture[<span class="std">Int</span>] = {
  <span class="cmt">// No reason to trigger `runAsync` for this operation</span>
  sample.runToFuture.map(_ + <span class="num">1</span>)
}

<span class="cmt">// ANTI-PATTERN 2: blocking threads makes it worse than (1)</span>
<span class="kw">def</span> increment2(sample: UIO[<span class="std">Int</span>]): <span class="std">Int</span> = {
  <span class="cmt">// Blocking threads is totally unnecessary</span>
  <span class="kw">val</span> x = Await.result(sample.runToFuture, <span class="num">5.</span>seconds)
  x + <span class="num">1</span>
}

<span class="cmt">// ANTI-PATTERN 3: this is even WORSE than (2)!</span>
<span class="kw">def</span> increment3(sample: Task[<span class="std">Int</span>]): Task[<span class="std">Int</span>] = {
  <span class="cmt">// Triggering side-effects, but misleading users/readers</span>
  <span class="cmt">// into thinking this function is pure via the return type</span>
  BIO.fromFuture(sample.runToFuture.map(_ + <span class="num">1</span>))
}</pre><p>Instead prefer the pure versions. <code>BIO</code> has its own <a href="#map[B](f:A=&gt;B):monix.bio.BIO[E,B]" name="monix.bio.BIO#map" id="monix.bio.BIO#map" class="extmbr">map</a>,
<a href="#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#flatMap" id="monix.bio.BIO#flatMap" class="extmbr">flatMap</a>, <a href="#onErrorHandleWith[E1,B&gt;:A](f:E=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#onErrorHandleWith" id="monix.bio.BIO#onErrorHandleWith" class="extmbr">onErrorHandleWith</a> or <a href="#bracketCase[E1&gt;:E,B](use:A=&gt;monix.bio.BIO[E1,B])(release:(A,cats.effect.ExitCase[monix.bio.Cause[E1]])=&gt;monix.bio.UIO[Unit]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#bracketCase" id="monix.bio.BIO#bracketCase" class="extmbr">bracketCase</a>, which
are really powerful and can allow you to operate on a task
in however way you like without escaping BIO's context and
triggering unwanted side-effects.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd><dt>returns</dt><dd class="cmt"><p>a
        <a href="https://monix.io/api/3.1/monix/execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a>
        that can be used to extract the result or to cancel
        a running task.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#runToFutureOpt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runToFutureOpt(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]"></a><a id="runToFutureOpt(Scheduler,Options,&lt;:&lt;[E,Throwable]):CancelableFuture[A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#runToFutureOpt(implicits:monix.execution.Scheduler,implicitopts:monix.bio.BIO.Options,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runToFutureOpt</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="opts">opts: <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a></span>, <span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="scala.Throwable" class="extype">Throwable</span>]</span>)</span><span class="result">: <a href="https://monix.io/api/3.1/monix/execution/CancelableFuture.html#monix.execution.CancelableFuture" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a>[<span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Triggers the asynchronous execution, much like normal <a href="#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.BIO#runToFuture" id="monix.bio.BIO#runToFuture" class="extmbr">runToFuture</a>,
but includes the ability to specify <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a>
that can modify the behavior of the run-loop.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the asynchronous execution, much like normal <a href="#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.BIO#runToFuture" id="monix.bio.BIO#runToFuture" class="extmbr">runToFuture</a>,
but includes the ability to specify <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a>
that can modify the behavior of the run-loop.</p><p>This is the configurable version of <a href="#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.BIO#runToFuture" id="monix.bio.BIO#runToFuture" class="extmbr">runToFuture</a>.
It allows you to specify options such as:</p><ul><li>enabling support for <a href="BIOLocal.html" name="monix.bio.BIOLocal" id="monix.bio.BIOLocal" class="extype">BIOLocal</a></li><li>disabling auto-cancelable run-loops</li></ul><p>See <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">BIO.Options</a>. Example:</p><pre><span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="kw">val</span> task =
  <span class="kw">for</span> {
    local <span class="kw">&lt;-</span> BIOLocal(<span class="num">0</span>)
    _     <span class="kw">&lt;-</span> local.write(<span class="num">100</span>)
    _     <span class="kw">&lt;-</span> BIO.shift
    value <span class="kw">&lt;-</span> local.read
  } <span class="kw">yield</span> value

<span class="cmt">// We need to activate support of BIOLocal via:</span>
<span class="kw">implicit</span> <span class="kw">val</span> opts = BIO.defaultOptions.enableLocalContextPropagation
<span class="cmt">// Actual execution that depends on these custom options:</span>
<span class="cmt">// task.runToFutureOpt</span></pre><p><b>UNSAFE (referential transparency)</b> —
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        Normally these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request (in case you're working with a web framework or
        toolkit that doesn't provide good integration with Monix's
        <code>Task</code> via Cats-Effect).</p><p>        Otherwise for modifying or operating on tasks, prefer
        its pure functions like <code>map</code> and <code>flatMap</code>.
        In FP code don't use <code>runAsync</code>. Remember that <code>Task</code>
        is not a 1:1 replacement for <code>Future</code>, <code>Task</code> being
        a very different abstraction.</p><p>PLEASE READ the advice on anti-patterns at <a href="#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.BIO#runToFuture" id="monix.bio.BIO#runToFuture" class="extmbr">runToFuture</a>.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is an injected
        <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that gets used
        whenever asynchronous boundaries are needed when
        evaluating the task; a <code>Scheduler</code> is in general needed
        when the <code>Task</code> needs to be evaluated via <code>runAsync</code></p></dd><dt class="param">opts</dt><dd class="cmt"><p>a set of <a href="BIO$$Options.html" name="monix.bio.BIO.Options" id="monix.bio.BIO.Options" class="extype">Options</a>
        that determine the behavior of Task's run-loop.</p></dd><dt>returns</dt><dd class="cmt"><p>a
        <a href="https://monix.io/api/3.1/monix/execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a>
        that can be used to extract the result or to cancel
        a running task.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@UnsafeBecauseImpure</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#start" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="start:monix.bio.UIO[monix.bio.Fiber[E@scala.annotation.unchecked.uncheckedVariance,A@scala.annotation.unchecked.uncheckedVariance]]"></a><a id="start:UIO[Fiber[E,A]]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#start:monix.bio.UIO[monix.bio.Fiber[E@scala.annotation.unchecked.uncheckedVariance,A@scala.annotation.unchecked.uncheckedVariance]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">start</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="Fiber.html" name="monix.bio.Fiber" id="monix.bio.Fiber" class="extype">Fiber</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Start execution of the source suspended in the <code>Task</code> context.</p><div class="fullcomment"><div class="comment cmt"><p>Start execution of the source suspended in the <code>Task</code> context.</p><p>This can be used for non-deterministic / concurrent execution.
The following code is more or less equivalent with
doctodo Task.parMap2 (minus the behavior on error handling and
cancellation):</p><pre><span class="kw">def</span> par2[A, B](ta: Task[A], tb: Task[B]): Task[(A, B)] =
  <span class="kw">for</span> {
    fa <span class="kw">&lt;-</span> ta.start
    fb <span class="kw">&lt;-</span> tb.start
     a <span class="kw">&lt;-</span> fa.join
     b <span class="kw">&lt;-</span> fb.join
  } <span class="kw">yield</span> (a, b)</pre><p>Note in such a case usage of doctodo Task.parMap2 parMap2
(and doctodo Task.parMap3 parMap3, etc.) is still recommended
because of behavior on error and cancellation — consider that
in the example above, if the first task finishes in error,
the second task doesn't get cancelled.</p><p>This operation forces an asynchronous boundary before execution
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#startAndForget" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="startAndForget:monix.bio.UIO[Unit]"></a><a id="startAndForget:UIO[Unit]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#startAndForget:monix.bio.UIO[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">startAndForget</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Start asynchronous execution of the source suspended in the <code>BIO</code> context,
running it in the background and discarding the result.</p><div class="fullcomment"><div class="comment cmt"><p>Start asynchronous execution of the source suspended in the <code>BIO</code> context,
running it in the background and discarding the result.</p><p>Similar to <a href="#start:monix.bio.UIO[monix.bio.Fiber[E@scala.annotation.unchecked.uncheckedVariance,A@scala.annotation.unchecked.uncheckedVariance]]" name="monix.bio.BIO#start" id="monix.bio.BIO#start" class="extmbr">start</a> after mapping result to Unit. Below law holds:</p><p><code>bio.startAndForget &lt;-&gt; bio.start.map(_ =&gt; ())</code></p></div></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#tapError" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="tapError[E1&gt;:E,B](f:E=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,A]"></a><a id="tapError[E1&gt;:E,B]((E)=&gt;BIO[E1,B]):BIO[E1,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#tapError[E1&gt;:E,B](f:E=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">tapError</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.bio.BIO.E" class="extype">E</span>) =&gt; <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.tapError.E1" class="extype">E1</span>, <span name="monix.bio.BIO.tapError.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.tapError.E1" class="extype">E1</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new task that will run a provided effect in case of a typed error
and raise the original error in case the provided function is successful.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new task that will run a provided effect in case of a typed error
and raise the original error in case the provided function is successful.</p><p>Example:</p><pre><span class="kw">import</span> monix.bio.{BIO, UIO}

<span class="cmt">// will result in Left("Error") and print the error to console</span>
BIO.raiseError(<span class="lit">"Error1"</span>).tapError(err <span class="kw">=&gt;</span> BIO.evalTotal(println(err)))</pre><p>If provided function returns an error then the resulting task will raise that error instead.</p><p>Example:</p><pre><span class="cmt">// will result in Left("Error2")</span>
BIO.raiseError(<span class="lit">"Error1"</span>).tapError(err <span class="kw">=&gt;</span> BIO.raiseError(<span class="lit">"Error2"</span>))</pre></div></div></li><li class="indented0 " name="monix.bio.BIO#timed" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="timed:monix.bio.BIO[E,(scala.concurrent.duration.FiniteDuration,A)]"></a><a id="timed:BIO[E,(FiniteDuration,A)]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#timed:monix.bio.BIO[E,(scala.concurrent.duration.FiniteDuration,A)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">timed</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, (<a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a>, <span name="monix.bio.BIO.A" class="extype">A</span>)]</span></span><p class="shortcomment cmt">Measures execution time of the source task and returns both its duration
and the computed value.</p><div class="fullcomment"><div class="comment cmt"><p>Measures execution time of the source task and returns both its duration
and the computed value.</p><p>Example:</p><pre><span class="kw">for</span> {
  result <span class="kw">&lt;-</span> BIO(<span class="num">1</span> + <span class="num">1</span>).timed
  (duration, value) = result
  _ <span class="kw">&lt;-</span> BIO(println(<span class="lit">"Executed in "</span> + duration.toMillis + <span class="lit">" ms"</span>))
} <span class="kw">yield</span> value</pre></div></div></li><li class="indented0 " name="monix.bio.BIO#timeout" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="timeout(after:scala.concurrent.duration.FiniteDuration):monix.bio.BIO[E,Option[A]]"></a><a id="timeout(FiniteDuration):BIO[E,Option[A]]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#timeout(after:scala.concurrent.duration.FiniteDuration):monix.bio.BIO[E,Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">timeout</span><span class="params">(<span name="after">after: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.bio.BIO.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Returns a Task that mirrors the source Task but returns <code>None</code>
in case the given duration passes without the
task emitting any item.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a Task that mirrors the source Task but returns <code>None</code>
in case the given duration passes without the
task emitting any item. Otherwise, returns <code>Some</code> of the resulting value.
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#timeoutL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="timeoutL(after:monix.bio.UIO[scala.concurrent.duration.FiniteDuration]):monix.bio.BIO[E,Option[A]]"></a><a id="timeoutL(UIO[FiniteDuration]):BIO[E,Option[A]]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#timeoutL(after:monix.bio.UIO[scala.concurrent.duration.FiniteDuration]):monix.bio.BIO[E,Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">timeoutL</span><span class="params">(<span name="after">after: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.bio.BIO.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Returns a Task that mirrors the source Task but returns <code>None</code>
in case the given duration passes without the
task emitting any item.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a Task that mirrors the source Task but returns <code>None</code>
in case the given duration passes without the
task emitting any item. Otherwise, returns <code>Some</code> of the resulting value.
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#timeoutTo" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="timeoutTo[E1&gt;:E,B&gt;:A](after:scala.concurrent.duration.FiniteDuration,backup:monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]"></a><a id="timeoutTo[E1&gt;:E,B&gt;:A](FiniteDuration,BIO[E1,B]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#timeoutTo[E1&gt;:E,B&gt;:A](after:scala.concurrent.duration.FiniteDuration,backup:monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">timeoutTo</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B &gt;: <span name="monix.bio.BIO.A" class="extype">A</span></span>]</span><span class="params">(<span name="after">after: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="backup">backup: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.timeoutTo.E1" class="extype">E1</span>, <span name="monix.bio.BIO.timeoutTo.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.timeoutTo.E1" class="extype">E1</span>, <span name="monix.bio.BIO.timeoutTo.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a Task that mirrors the source Task but switches to the
given backup Task in case the given duration passes without the
source emitting any item.</p></li><li class="indented0 " name="monix.bio.BIO#timeoutToL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="timeoutToL[E1&gt;:E,B&gt;:A](after:monix.bio.UIO[scala.concurrent.duration.FiniteDuration],backup:monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]"></a><a id="timeoutToL[E1&gt;:E,B&gt;:A](UIO[FiniteDuration],BIO[E1,B]):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#timeoutToL[E1&gt;:E,B&gt;:A](after:monix.bio.UIO[scala.concurrent.duration.FiniteDuration],backup:monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">timeoutToL</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B &gt;: <span name="monix.bio.BIO.A" class="extype">A</span></span>]</span><span class="params">(<span name="after">after: <a href="index.html#UIO[+A]=monix.bio.BIO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a>]</span>, <span name="backup">backup: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.timeoutToL.E1" class="extype">E1</span>, <span name="monix.bio.BIO.timeoutToL.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.timeoutToL.E1" class="extype">E1</span>, <span name="monix.bio.BIO.timeoutToL.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a Task that mirrors the source Task but switches to the
given backup Task in case the given duration passes without the
source emitting any item.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a Task that mirrors the source Task but switches to the
given backup Task in case the given duration passes without the
source emitting any item.</p><p>Useful when timeout is variable, e.g. when task is running in a loop
with deadline semantics.</p><p>Example:</p><pre><span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> java.util.concurrent.TimeoutException

<span class="kw">val</span> deadline = <span class="num">10.</span>seconds.fromNow

<span class="kw">val</span> singleCallTimeout = <span class="num">2.</span>seconds

<span class="cmt">// re-evaluate deadline time on every request</span>
<span class="kw">val</span> actualTimeout = UIO(singleCallTimeout.min(deadline.timeLeft))
<span class="kw">val</span> error = BIO.raiseError(<span class="kw">new</span> TimeoutException(<span class="lit">"Task timed-out"</span>))

<span class="cmt">// expensive remote call</span>
<span class="kw">def</span> call(): <span class="std">Unit</span> = ()

<span class="kw">val</span> remoteCall = BIO(call())
  .timeoutToL(actualTimeout, error)
  .onErrorRestart(<span class="num">100</span>)
  .timeout(deadline.time)</pre><p>Note that this method respects the timeout task evaluation duration,
e.g. if it took 3 seconds to evaluate <code>after</code>
to a value of <code>5 seconds</code>, then this task will timeout
in exactly 5 seconds from the moment computation started,
which means in 2 seconds after the timeout task has been evaluated.</p></div></div></li><li class="indented0 " name="monix.bio.BIO#timeoutWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="timeoutWith[E1&gt;:E,B&gt;:A](after:scala.concurrent.duration.FiniteDuration,error:E1):monix.bio.BIO[E1,B]"></a><a id="timeoutWith[E1&gt;:E,B&gt;:A](FiniteDuration,E1):BIO[E1,B]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#timeoutWith[E1&gt;:E,B&gt;:A](after:scala.concurrent.duration.FiniteDuration,error:E1):monix.bio.BIO[E1,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">timeoutWith</span><span class="tparams">[<span name="E1">E1 &gt;: <span name="monix.bio.BIO.E" class="extype">E</span></span>, <span name="B">B &gt;: <span name="monix.bio.BIO.A" class="extype">A</span></span>]</span><span class="params">(<span name="after">after: <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="error">error: <span name="monix.bio.BIO.timeoutWith.E1" class="extype">E1</span></span>)</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.timeoutWith.E1" class="extype">E1</span>, <span name="monix.bio.BIO.timeoutWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a Task that mirrors the source Task but that triggers a
specified error in case the given duration passes
without the task emitting any item.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a Task that mirrors the source Task but that triggers a
specified error in case the given duration passes
without the task emitting any item.</p></div><dl class="paramcmts block"><dt class="param">error</dt><dd class="cmt"><p><code>Error</code> raised after given duration passes</p></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#to" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="to[F[_]](implicitF:monix.bio.TaskLift[F],implicitev:E&lt;:&lt;Throwable):F[A@scala.annotation.unchecked.uncheckedVariance]"></a><a id="to[F[_]](TaskLift[F],&lt;:&lt;[E,Throwable]):F[A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#to[F[_]](implicitF:monix.bio.TaskLift[F],implicitev:E&lt;:&lt;Throwable):F[A@scala.annotation.unchecked.uncheckedVariance]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">to</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="TaskLift.html" name="monix.bio.TaskLift" id="monix.bio.TaskLift" class="extype">TaskLift</a>[<span name="monix.bio.BIO.to.F" class="extype">F</span>]</span>, <span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="scala.Throwable" class="extype">Throwable</span>]</span>)</span><span class="result">: <span name="monix.bio.BIO.to.F" class="extype">F</span>[<span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Generic conversion of <code>Task</code> to any data type for which there's
a <a href="TaskLift.html" name="monix.bio.TaskLift" id="monix.bio.TaskLift" class="extype">TaskLift</a> implementation available.</p><div class="fullcomment"><div class="comment cmt"><p>Generic conversion of <code>Task</code> to any data type for which there's
a <a href="TaskLift.html" name="monix.bio.TaskLift" id="monix.bio.TaskLift" class="extype">TaskLift</a> implementation available.</p><p>Supported data types:</p><ul><li><a href="https://typelevel.org/cats-effect/datatypes/io.html" target="_blank">cats.effect.IO</a></li><li>any data type implementing <a href="https://typelevel.org/cats-effect/typeclasses/concurrent.html" target="_blank">cats.effect.Concurrent</a></li><li>any data type implementing <a href="https://typelevel.org/cats-effect/typeclasses/async.html" target="_blank">cats.effect.Async</a></li><li>any data type implementing <a href="https://typelevel.org/cats-effect/typeclasses/liftio.html" target="_blank">cats.effect.LiftIO</a></li><li><code>monix.reactive.Observable</code></li><li><code>monix.tail.Iterant</code></li></ul><p>This conversion guarantees:</p><ul><li>referential transparency</li><li>similar runtime characteristics (e.g. if the source doesn't
   block threads on evaluation, then the result shouldn't block
   threads either)</li><li>interruptibility, if the target data type is cancelable</li></ul><p>Note that this method is only applicable when the typed error <code>E</code>
is also a <code>Throwable</code>, or when the source task is an unexceptional
one (i.e. it is a <code>UIO</code>). If you need a conversion from <code>E</code> into
a <code>Throwable</code>, take a look at <a href="#mapError[E1](f:E=&gt;E1):monix.bio.BIO[E1,A]" name="monix.bio.BIO#mapError" id="monix.bio.BIO#mapError" class="extmbr">mapError</a> or <a href="#onErrorHandleWith[E1,B&gt;:A](f:E=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#onErrorHandleWith" id="monix.bio.BIO#onErrorHandleWith" class="extmbr">onErrorHandleWith</a>.
If you need a conversion into a <code>UIO</code>, take a look at <a href="#attempt:monix.bio.UIO[Either[E,A]]" name="monix.bio.BIO#attempt" id="monix.bio.BIO#attempt" class="extmbr">attempt</a>,
<a href="#materialize(implicitev:E&lt;:&lt;Throwable):monix.bio.UIO[scala.util.Try[A]]" name="monix.bio.BIO#materialize" id="monix.bio.BIO#materialize" class="extmbr">materialize</a> or <a href="#onErrorHandle[U&gt;:A](f:E=&gt;U):monix.bio.UIO[U]" name="monix.bio.BIO#onErrorHandle" id="monix.bio.BIO#onErrorHandle" class="extmbr">onErrorHandle</a>.</p><p>Sample:</p><pre><span class="kw">import</span> cats.effect.IO
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">import</span> scala.concurrent.duration._

BIO.eval(println(<span class="lit">"Hello!"</span>))
  .delayExecution(<span class="num">5.</span>seconds)
  .to[IO]</pre></div></div></li><li class="indented0 " name="monix.bio.BIO#toAsync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toAsync[F[_]](implicitF:cats.effect.Async[F],impliciteff:cats.effect.Effect[monix.bio.Task],implicitev:E&lt;:&lt;Throwable):F[A@scala.annotation.unchecked.uncheckedVariance]"></a><a id="toAsync[F[_]](Async[F],Effect[Task],&lt;:&lt;[E,Throwable]):F[A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#toAsync[F[_]](implicitF:cats.effect.Async[F],impliciteff:cats.effect.Effect[monix.bio.Task],implicitev:E&lt;:&lt;Throwable):F[A@scala.annotation.unchecked.uncheckedVariance]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toAsync</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="https://typelevel.org/cats-effect/api/cats/effect/Async.html#cats.effect.Async" name="cats.effect.Async" id="cats.effect.Async" class="extype">Async</a>[<span name="monix.bio.BIO.toAsync.F" class="extype">F</span>]</span>, <span name="eff">eff: <a href="https://typelevel.org/cats-effect/api/cats/effect/Effect.html#cats.effect.Effect" name="cats.effect.Effect" id="cats.effect.Effect" class="extype">Effect</a>[<a href="index.html#Task[+A]=monix.bio.BIO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>]</span>, <span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="scala.Throwable" class="extype">Throwable</span>]</span>)</span><span class="result">: <span name="monix.bio.BIO.toAsync.F" class="extype">F</span>[<span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts the source task into any data type that implements
<a href="https://typelevel.org/cats-effect/typeclasses/async.html" target="_blank">Async</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts the source task into any data type that implements
<a href="https://typelevel.org/cats-effect/typeclasses/async.html" target="_blank">Async</a>.</p><p>Example:</p><pre><span class="kw">import</span> cats.effect.IO
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">import</span> scala.concurrent.duration._

BIO.eval(println(<span class="lit">"Hello!"</span>))
  .delayExecution(<span class="num">5.</span>seconds)
  .toAsync[IO]</pre><p>An <code>Effect[Task]</code> instance is needed in scope, which itself
might need a <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> to
be available. Such requirement is needed because the <code>Task</code>
has to be evaluated in order to be converted.</p><p>Note that this method is only applicable when the typed error <code>E</code>
is also a <code>Throwable</code>, or when the source task is an unexceptional
one (i.e. it is a <code>UIO</code>). If you need a conversion from <code>E</code> into
a <code>Throwable</code>, take a look at <a href="#mapError[E1](f:E=&gt;E1):monix.bio.BIO[E1,A]" name="monix.bio.BIO#mapError" id="monix.bio.BIO#mapError" class="extmbr">mapError</a> or <a href="#onErrorHandleWith[E1,B&gt;:A](f:E=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#onErrorHandleWith" id="monix.bio.BIO#onErrorHandleWith" class="extmbr">onErrorHandleWith</a>.
If you need a conversion into a <code>UIO</code>, take a look at <a href="#attempt:monix.bio.UIO[Either[E,A]]" name="monix.bio.BIO#attempt" id="monix.bio.BIO#attempt" class="extmbr">attempt</a>,
<a href="#materialize(implicitev:E&lt;:&lt;Throwable):monix.bio.UIO[scala.util.Try[A]]" name="monix.bio.BIO#materialize" id="monix.bio.BIO#materialize" class="extmbr">materialize</a> or <a href="#onErrorHandle[U&gt;:A](f:E=&gt;U):monix.bio.UIO[U]" name="monix.bio.BIO#onErrorHandle" id="monix.bio.BIO#onErrorHandle" class="extmbr">onErrorHandle</a>.</p><p>NOTE: the resulting instance will NOT be cancelable, as the
Task's cancelation token doesn't get carried over. This is
implicit in the usage of <code>cats.effect.Async</code> type class.
In the example above what this means is that the task will
still print <code>"Hello!"</code> after 5 seconds, even if the resulting
task gets cancelled.
</p></div><dl class="paramcmts block"><dt class="param">F</dt><dd class="cmt"><p>is the <code>cats.effect.Async</code> instance required in
       order to perform the conversion</p></dd><dt class="param">eff</dt><dd class="cmt"><p>is the <code>Effect[Task]</code> instance needed to
       evaluate tasks; when evaluating tasks, this is the pure
       alternative to demanding a <code>Scheduler</code></p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#to[F[_]](implicitF:monix.bio.TaskLift[F],implicitev:E&lt;:&lt;Throwable):F[A@scala.annotation.unchecked.uncheckedVariance]" name="monix.bio.BIO#to" id="monix.bio.BIO#to" class="extmbr">to</a> that is able to convert to any data type that has
     a <a href="TaskLift.html" name="monix.bio.TaskLift" id="monix.bio.TaskLift" class="extype">TaskLift</a> implementation</p></span><span class="cmt"><p><a href="#toConcurrent[F[_]](implicitF:cats.effect.Concurrent[F],impliciteff:cats.effect.ConcurrentEffect[monix.bio.Task],implicitev:E&lt;:&lt;Throwable):F[A@scala.annotation.unchecked.uncheckedVariance]" name="monix.bio.BIO#toConcurrent" id="monix.bio.BIO#toConcurrent" class="extmbr">toConcurrent</a> that is able to convert to cancelable values via the
     <a href="https://typelevel.org/cats-effect/typeclasses/concurrent.html" target="_blank">Concurrent</a>
     type class.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#toConcurrent" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toConcurrent[F[_]](implicitF:cats.effect.Concurrent[F],impliciteff:cats.effect.ConcurrentEffect[monix.bio.Task],implicitev:E&lt;:&lt;Throwable):F[A@scala.annotation.unchecked.uncheckedVariance]"></a><a id="toConcurrent[F[_]](Concurrent[F],ConcurrentEffect[Task],&lt;:&lt;[E,Throwable]):F[A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#toConcurrent[F[_]](implicitF:cats.effect.Concurrent[F],impliciteff:cats.effect.ConcurrentEffect[monix.bio.Task],implicitev:E&lt;:&lt;Throwable):F[A@scala.annotation.unchecked.uncheckedVariance]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toConcurrent</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="https://typelevel.org/cats-effect/api/cats/effect/Concurrent.html#cats.effect.Concurrent" name="cats.effect.Concurrent" id="cats.effect.Concurrent" class="extype">Concurrent</a>[<span name="monix.bio.BIO.toConcurrent.F" class="extype">F</span>]</span>, <span name="eff">eff: <a href="https://typelevel.org/cats-effect/api/cats/effect/ConcurrentEffect.html#cats.effect.ConcurrentEffect" name="cats.effect.ConcurrentEffect" id="cats.effect.ConcurrentEffect" class="extype">ConcurrentEffect</a>[<a href="index.html#Task[+A]=monix.bio.BIO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>]</span>, <span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="scala.Throwable" class="extype">Throwable</span>]</span>)</span><span class="result">: <span name="monix.bio.BIO.toConcurrent.F" class="extype">F</span>[<span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts the source task into any data type that implements
<a href="https://typelevel.org/cats-effect/typeclasses/concurrent.html" target="_blank">Concurrent</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts the source task into any data type that implements
<a href="https://typelevel.org/cats-effect/typeclasses/concurrent.html" target="_blank">Concurrent</a>.</p><p>Example:</p><pre><span class="kw">import</span> cats.effect.IO
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">import</span> scala.concurrent.duration._

<span class="kw">implicit</span> <span class="kw">val</span> cs = IO.contextShift(global)

BIO.eval(println(<span class="lit">"Hello!"</span>))
  .delayExecution(<span class="num">5.</span>seconds)
  .toConcurrent[IO]</pre><p>A <code>ConcurrentEffect[Task]</code> instance is needed in scope, which itself
might need a <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> to be available.
Such a requirement is needed because the <code>Task</code> has to be evaluated
in order to be converted.</p><p>Note that this method is only applicable when the typed error <code>E</code>
is also a <code>Throwable</code>, or when the source task is an unexceptional
one (i.e. it is a <code>UIO</code>). If you need a conversion from <code>E</code> into
a <code>Throwable</code>, take a look at <a href="#mapError[E1](f:E=&gt;E1):monix.bio.BIO[E1,A]" name="monix.bio.BIO#mapError" id="monix.bio.BIO#mapError" class="extmbr">mapError</a> or <a href="#onErrorHandleWith[E1,B&gt;:A](f:E=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#onErrorHandleWith" id="monix.bio.BIO#onErrorHandleWith" class="extmbr">onErrorHandleWith</a>.
If you need a conversion into a <code>UIO</code>, take a look at <a href="#attempt:monix.bio.UIO[Either[E,A]]" name="monix.bio.BIO#attempt" id="monix.bio.BIO#attempt" class="extmbr">attempt</a>,
<a href="#materialize(implicitev:E&lt;:&lt;Throwable):monix.bio.UIO[scala.util.Try[A]]" name="monix.bio.BIO#materialize" id="monix.bio.BIO#materialize" class="extmbr">materialize</a> or <a href="#onErrorHandle[U&gt;:A](f:E=&gt;U):monix.bio.UIO[U]" name="monix.bio.BIO#onErrorHandle" id="monix.bio.BIO#onErrorHandle" class="extmbr">onErrorHandle</a>.</p><p>NOTE: the resulting value is cancelable, via usage of
<code>cats.effect.Concurrent</code>.
</p></div><dl class="paramcmts block"><dt class="param">F</dt><dd class="cmt"><p>is the <code>cats.effect.Concurrent</code> instance required in
       order to perform the conversion</p></dd><dt class="param">eff</dt><dd class="cmt"><p>is the <code>ConcurrentEffect[Task]</code> instance needed to
       evaluate tasks; when evaluating tasks, this is the pure
       alternative to demanding a <code>Scheduler</code></p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#to[F[_]](implicitF:monix.bio.TaskLift[F],implicitev:E&lt;:&lt;Throwable):F[A@scala.annotation.unchecked.uncheckedVariance]" name="monix.bio.BIO#to" id="monix.bio.BIO#to" class="extmbr">to</a> that is able to convert into any data type that has
     a <a href="TaskLift.html" name="monix.bio.TaskLift" id="monix.bio.TaskLift" class="extype">TaskLift</a> implementation</p></span><span class="cmt"><p><a href="#toAsync[F[_]](implicitF:cats.effect.Async[F],impliciteff:cats.effect.Effect[monix.bio.Task],implicitev:E&lt;:&lt;Throwable):F[A@scala.annotation.unchecked.uncheckedVariance]" name="monix.bio.BIO#toAsync" id="monix.bio.BIO#toAsync" class="extmbr">toAsync</a> that is able to convert into non-cancelable values via the
      <a href="https://typelevel.org/cats-effect/typeclasses/async.html" target="_blank">Async</a>
      type class.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#toReactivePublisher" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toReactivePublisher(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):org.reactivestreams.Publisher[A@scala.annotation.unchecked.uncheckedVariance]"></a><a id="toReactivePublisher(Scheduler,&lt;:&lt;[E,Throwable]):Publisher[A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#toReactivePublisher(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):org.reactivestreams.Publisher[A@scala.annotation.unchecked.uncheckedVariance]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toReactivePublisher</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.1/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="scala.Throwable" class="extype">Throwable</span>]</span>)</span><span class="result">: <span name="org.reactivestreams.Publisher" class="extype">Publisher</span>[<span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts the source task into an <code>org.reactivestreams.Publisher</code>
that emits a single item on success, or an error when there is
a typed or fatal failure.</p><div class="fullcomment"><div class="comment cmt"><p>Converts the source task into an <code>org.reactivestreams.Publisher</code>
that emits a single item on success, or an error when there is
a typed or fatal failure.</p><p>Note that this method is only applicable when the typed error <code>E</code>
is also a <code>Throwable</code>, or when the source task is an unexceptional
one (i.e. it is a <code>UIO</code>). If you need a conversion from <code>E</code> into
a <code>Throwable</code>, take a look at <a href="#mapError[E1](f:E=&gt;E1):monix.bio.BIO[E1,A]" name="monix.bio.BIO#mapError" id="monix.bio.BIO#mapError" class="extmbr">mapError</a> or <a href="#onErrorHandleWith[E1,B&gt;:A](f:E=&gt;monix.bio.BIO[E1,B]):monix.bio.BIO[E1,B]" name="monix.bio.BIO#onErrorHandleWith" id="monix.bio.BIO#onErrorHandleWith" class="extmbr">onErrorHandleWith</a>.
If you need a conversion into a <code>UIO</code>, take a look at <a href="#attempt:monix.bio.UIO[Either[E,A]]" name="monix.bio.BIO#attempt" id="monix.bio.BIO#attempt" class="extmbr">attempt</a>,
<a href="#materialize(implicitev:E&lt;:&lt;Throwable):monix.bio.UIO[scala.util.Try[A]]" name="monix.bio.BIO#materialize" id="monix.bio.BIO#materialize" class="extmbr">materialize</a> or <a href="#onErrorHandle[U&gt;:A](f:E=&gt;U):monix.bio.UIO[U]" name="monix.bio.BIO#onErrorHandle" id="monix.bio.BIO#onErrorHandle" class="extmbr">onErrorHandle</a>.</p><p>See <a href="http://www.reactive-streams.org/" target="_blank">reactive-streams.org</a> for the
Reactive Streams specification.
</p></div></div></li><li class="indented0 " name="monix.bio.BIO#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><p class="shortcomment cmt">Returns a string representation of this task meant for
debugging purposes only.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a string representation of this task meant for
debugging purposes only.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a> → AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.bio.BIO#uncancelable" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="uncancelable:monix.bio.BIO[E,A]"></a><a id="uncancelable:BIO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#uncancelable:monix.bio.BIO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">uncancelable</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <span name="monix.bio.BIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Makes the source <code>Task</code> uninterruptible such that a <code>cancel</code> signal
(e.g.</p><div class="fullcomment"><div class="comment cmt"><p>Makes the source <code>Task</code> uninterruptible such that a <code>cancel</code> signal
(e.g. <a href="Fiber.html#cancel:cats.effect.CancelToken[monix.bio.UIO]" name="monix.bio.Fiber#cancel" id="monix.bio.Fiber#cancel" class="extmbr">Fiber.cancel</a>) has no effect.</p><pre><span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">import</span> scala.concurrent.duration._

<span class="kw">val</span> uncancelable = Task
  .eval(println(<span class="lit">"Hello!"</span>))
  .delayExecution(<span class="num">10.</span>seconds)
  .uncancelable
  .runToFuture

<span class="cmt">// No longer works</span>
uncancelable.cancel()

<span class="cmt">// After 10 seconds</span>
<span class="cmt">// =&gt; Hello!</span></pre></div></div></li><li class="indented0 " name="monix.bio.BIO#void" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="void:monix.bio.BIO[E,Unit]"></a><a id="void:BIO[E,Unit]"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#void:monix.bio.BIO[E,Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">void</span><span class="result">: <a href="" name="monix.bio.BIO" id="monix.bio.BIO" class="extype">BIO</a>[<span name="monix.bio.BIO.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Returns this task mapped to unit
</p></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="arg1">arg1: <a href="https://www.scala-lang.org/api/2.13.1/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.1/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../../monix/bio/BIO.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version ) see corresponding Javadoc for more information.">finalize</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> <span class="name">@Deprecated</span> <span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version )</i> see corresponding Javadoc for more information.</p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="java.io.Serializable" class="parent"><h3>Inherited from <span name="java.io.Serializable" class="extype">Serializable</span></h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.1/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
