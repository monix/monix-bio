<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Monix BIO v1.0.0+17-faf59d96-SNAPSHOT - monix.bio</title><meta content="Monix BIO v1.0.0 17 - faf59d96 - SNAPSHOT - monix.bio" name="description"/><meta content="Monix BIO v1.0.0 17 faf59d96 SNAPSHOT monix.bio" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title">Monix BIO<span id="doc-version">v1.0.0+17-faf59d96-SNAPSHOT</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.monix" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monix"></a><a id="monix:monix"></a> <span class="permalink"><a href="../../monix/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">monix</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 current" name="monix.bio" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bio"></a><a id="bio:bio"></a> <span class="permalink"><a href="../../monix/bio/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">bio</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="monix" id="monix" class="extype">monix</a></dd></dl></div></li><li class="indented3 " name="monix.bio.instances" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="instances"></a><a id="instances:instances"></a> <span class="permalink"><a href="../../monix/bio/instances/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="instances/index.html" title=""><span class="name">instances</span></a></span></li><li class="current-entities indented2"><span class="separator"></span> <a href="BIOApp.html" title="Safe App type that executes a IO." class="trait"></a><a href="BIOApp.html" title="Safe App type that executes a IO.">BIOApp</a></li><li class="current-entities indented2"><a href="BiCallback$.html" title="" class="object"></a> <a href="BiCallback.html" title="Callback type which supports two channels of errors." class="class"></a><a href="BiCallback.html" title="Callback type which supports two channels of errors.">BiCallback</a></li><li class="current-entities indented2"><a href="Cause$.html" title="" class="object"></a> <a href="Cause.html" title="Represent a complete cause of the failed IO exposing both typed and untyped error channel." class="class"></a><a href="Cause.html" title="Represent a complete cause of the failed IO exposing both typed and untyped error channel.">Cause</a></li><li class="current-entities indented2"><a href="Fiber$.html" title="" class="object"></a> <a href="Fiber.html" title="Fiber represents the (pure) result of a IO being started concurrently and that can be either joined or cancelled." class="trait"></a><a href="Fiber.html" title="Fiber represents the (pure) result of a IO being started concurrently and that can be either joined or cancelled.">Fiber</a></li><li class="current-entities indented2"><a href="IO$.html" title="Builders for IO." class="object"></a> <a href="IO.html" title="Task represents a specification for a possibly lazy or asynchronous computation, which when executed will produce an A as a result, along with possible side-effects." class="class"></a><a href="IO.html" title="Task represents a specification for a possibly lazy or asynchronous computation, which when executed will produce an A as a result, along with possible side-effects.">IO</a></li><li class="current-entities indented2"><a href="IOLift$.html" title="" class="object"></a> <a href="IOLift.html" title="A lawless type class that specifies conversions from IO to similar data types (i.e." class="trait"></a><a href="IOLift.html" title="A lawless type class that specifies conversions from IO to similar data types (i.e.">IOLift</a></li><li class="current-entities indented2"><a href="IOLike$.html" title="" class="object"></a> <a href="IOLike.html" title="A lawless type class that provides conversions into a IO." class="trait"></a><a href="IOLike.html" title="A lawless type class that provides conversions into a IO.">IOLike</a></li><li class="current-entities indented2"><a href="IOLocal$.html" title="Builders for IOLocal" class="object"></a> <a href="IOLocal.html" title="A IOLocal is like a ThreadLocal that is pure and with a flexible scope, being processed in the context of the IO data type." class="class"></a><a href="IOLocal.html" title="A IOLocal is like a ThreadLocal that is pure and with a flexible scope, being processed in the context of the IO data type.">IOLocal</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Task$.html" title="" class="object"></a><a href="Task$.html" title="">Task</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="UIO$.html" title="" class="object"></a><a href="UIO$.html" title="">UIO</a></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../index.html" name="monix" id="monix" class="extype">monix</a></p><h1>bio<span class="permalink"><a href="../../monix/bio/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">bio</span></span></h4><div id="comment" class="fullcommenttop"><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/monix/monix-bio/tree/v1.0.0+17-faf59d96-SNAPSHOT/core/shared/src/main/scala/monix/bio/package.scala" target="_blank">package.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.1/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="monix.bio"><span>bio</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="packages" class="package members"><h3>Package Members</h3><ol><li class="indented0 " name="monix.bio.instances" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="instances"></a><a id="instances:instances"></a> <span class="permalink"><a href="../../monix/bio/instances/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="instances/index.html" title=""><span class="name">instances</span></a></span></li></ol></div><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="monix.bio.BIOApp" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="BIOAppextendsAnyRef"></a><a id="BIOApp:BIOApp"></a> <span class="permalink"><a href="../../monix/bio/BIOApp.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="BIOApp.html" title="Safe App type that executes a IO."><span class="name">BIOApp</span></a><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><p class="shortcomment cmt">Safe <code>App</code> type that executes a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Safe <code>App</code> type that executes a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>.  Shutdown occurs after
the <code>IO</code> completes, as follows:</p><p>- If completed with <code>ExitCode.Success</code>, the main method exits and
  shutdown is handled by the platform.</p><p>- If completed with any other <code>ExitCode</code>, <code>sys.exit</code> is called
  with the specified code.</p><p>- If the <code>IO</code> raises an error, the stack trace is printed to
  standard error and <code>sys.exit(1)</code> is called.</p><p>When a shutdown is requested via a signal, the <code>IO</code> is canceled and
we wait for the <code>IO</code> to release any resources.  The process exits
with the numeric value of the signal plus 128.</p><pre><span class="kw">import</span> cats.effect._
<span class="kw">import</span> cats.implicits._
<span class="kw">import</span> monix.bio._

<span class="kw">object</span> MyApp <span class="kw">extends</span> BIOApp {
  <span class="kw">def</span> run(args: <span class="std">List</span>[<span class="std">String</span>]): UIO[ExitCode] =
    args.headOption <span class="kw">match</span> {
      <span class="kw">case</span> <span class="std">Some</span>(name) <span class="kw">=&gt;</span>
        UIO(println(s<span class="lit">"Hello, \${name}."</span>)).as(ExitCode.Success)
      <span class="kw">case</span> <span class="std">None</span> <span class="kw">=&gt;</span>
        UIO(System.err.println(<span class="lit">"Usage: MyApp name"</span>)).as(ExitCode(<span class="num">2</span>))
    }
}</pre><p>N.B. this is homologous with
<a href="https://typelevel.org/cats-effect/datatypes/ioapp.html" target="_blank">cats.effect.IOApp</a>,
but meant for usage with <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>.</p><p>Works on top of JavaScript as well ;-)
</p></div></div></li><li class="indented0 " name="monix.bio.BiCallback" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="BiCallback[-E,-A]extendsEither[monix.bio.Cause[E],A]=&gt;Unit"></a><a id="BiCallback[-E,-A]:BiCallback[E,A]"></a> <span class="permalink"><a href="../../monix/bio/BiCallback.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="BiCallback.html" title="Callback type which supports two channels of errors."><span class="name">BiCallback</span></a><span class="tparams">[<span name="E">-E</span>, <span name="A">-A</span>]</span><span class="result"> extends (<span name="scala.Either" class="extype">Either</span>[<a href="Cause.html" name="monix.bio.Cause" id="monix.bio.Cause" class="extype">Cause</a>[<span name="monix.bio.BiCallback.E" class="extype">E</span>], <span name="monix.bio.BiCallback.A" class="extype">A</span>]) =&gt; <a href="https://www.scala-lang.org/api/2.13.1/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><p class="shortcomment cmt">Callback type which supports two channels of errors.</p></li><li class="indented0 " name="monix.bio.Cause" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="Cause[+E]extendsProductwithSerializable"></a><a id="Cause[+E]:Cause[E]"></a> <span class="permalink"><a href="../../monix/bio/Cause.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">sealed abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="Cause.html" title="Represent a complete cause of the failed IO exposing both typed and untyped error channel."><span class="name">Cause</span></a><span class="tparams">[<span name="E">+E</span>]</span><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.1/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Represent a complete cause of the failed <code>IO</code>
exposing both typed and untyped error channel.</p></li><li class="indented0 " name="monix.bio.Fiber" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="Fiber[E,A]extendsFiber[[β$0$]monix.bio.IO[E,β$0$],A]"></a><a id="Fiber[E,A]:Fiber[E,A]"></a> <span class="permalink"><a href="../../monix/bio/Fiber.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Fiber.html" title="Fiber represents the (pure) result of a IO being started concurrently and that can be either joined or cancelled."><span class="name">Fiber</span></a><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="result"> extends <a href="https://typelevel.org/cats-effect/api/cats/effect/Fiber.html#cats.effect.Fiber" name="cats.effect.Fiber" id="cats.effect.Fiber" class="extype">cats.effect.Fiber</a>[[β$0$]<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.Fiber.E" class="extype">E</span>, <span name="monix.bio.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.β$0$" class="extype">β$0$</span>], <span name="monix.bio.Fiber.A" class="extype">A</span>]</span></span><p class="shortcomment cmt"><code>Fiber</code> represents the (pure) result of a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> being started concurrently
and that can be either joined or cancelled.</p><div class="fullcomment"><div class="comment cmt"><p><code>Fiber</code> represents the (pure) result of a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> being started concurrently
and that can be either joined or cancelled.</p><p>You can think of fibers as being lightweight threads, a fiber being a
concurrency primitive for doing cooperative multi-tasking.</p><p>For example a <code>Fiber</code> value is the result of evaluating <a href="IO.html#start:monix.bio.UIO[monix.bio.Fiber[E@scala.annotation.unchecked.uncheckedVariance,A@scala.annotation.unchecked.uncheckedVariance]]" name="monix.bio.IO#start" id="monix.bio.IO#start" class="extmbr">IO.start</a>:</p><pre><span class="kw">val</span> task = UIO.evalAsync(println(<span class="lit">"Hello!"</span>))

<span class="kw">val</span> forked: UIO[Fiber[<span class="std">Nothing</span>, <span class="std">Unit</span>]] = task.start</pre><p>Usage example:</p><pre><span class="kw">val</span> launchMissiles = Task(println(<span class="lit">"Missiles launched!"</span>))
<span class="kw">val</span> runToBunker = Task(println(<span class="lit">"Run Lola run!"</span>))

<span class="kw">for</span> {
  fiber <span class="kw">&lt;-</span> launchMissiles.start
  _ <span class="kw">&lt;-</span> runToBunker.onErrorHandleWith { error <span class="kw">=&gt;</span>
    <span class="cmt">// Retreat failed, cancel launch (maybe we should</span>
    <span class="cmt">// have retreated to our bunker before the launch?)</span>
    fiber.cancel.flatMap(_ <span class="kw">=&gt;</span> Task.raiseError(error))
  }
  aftermath <span class="kw">&lt;-</span> fiber.join
} <span class="kw">yield</span> {
  aftermath
}</pre></div></div></li><li class="indented0 " name="monix.bio.IO" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="IO[+E,+A]extendsSerializable"></a><a id="IO[+E,+A]:IO[E,A]"></a> <span class="permalink"><a href="../../monix/bio/IO.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">sealed abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="IO.html" title="Task represents a specification for a possibly lazy or asynchronous computation, which when executed will produce an A as a result, along with possible side-effects."><span class="name">IO</span></a><span class="tparams">[<span name="E">+E</span>, <span name="A">+A</span>]</span><span class="result"> extends <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt"><code>Task</code> represents a specification for a possibly lazy or
asynchronous computation, which when executed will produce an <code>A</code>
as a result, along with possible side-effects.</p><div class="fullcomment"><div class="comment cmt"><p><code>Task</code> represents a specification for a possibly lazy or
asynchronous computation, which when executed will produce an <code>A</code>
as a result, along with possible side-effects.</p><p>Compared with <code>Future</code> from Scala's standard library, <code>Task</code> does
not represent a running computation or a value detached from time,
as <code>Task</code> does not execute anything when working with its builders
or operators and it does not submit any work into any thread-pool,
the execution eventually taking place only after <code>runAsync</code> is
called and not before that.</p><p>Note that <code>Task</code> is conservative in how it spawns logical threads.
Transformations like <code>map</code> and <code>flatMap</code> for example will default
to being executed on the logical thread on which the asynchronous
computation was started. But one shouldn't make assumptions about
how things will end up executed, as ultimately it is the
implementation's job to decide on the best execution model. All
you are guaranteed is asynchronous execution after executing
<code>runAsync</code>.</p><h3>Getting Started</h3><p>To build a <code>IO</code> from a by-name parameters (thunks), we can use
<a href="IO$.html#apply[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#apply" id="monix.bio.IO#apply" class="extmbr">IO.apply</a> (
alias <a href="IO$.html#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a>),
<a href="IO$.html#evalTotal[A](a:=&gt;A):monix.bio.UIO[A]" name="monix.bio.IO#evalTotal" id="monix.bio.IO#evalTotal" class="extmbr">monix.bio.IO.evalTotal</a> if the thunk is guaranteed to not throw any exceptions, or
<a href="IO$.html#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a>:</p><pre><span class="kw">val</span> hello = IO(<span class="lit">"Hello "</span>)
<span class="kw">val</span> world = IO.evalAsync(<span class="lit">"World!"</span>)</pre><p>Nothing gets executed yet, as <code>IO</code> is lazy, nothing executes
until you trigger its evaluation via <a href="IO.html#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.IO#runAsync" id="monix.bio.IO#runAsync" class="extmbr">runAsync</a> or
<a href="IO.html#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.IO#runToFuture" id="monix.bio.IO#runToFuture" class="extmbr">runToFuture</a>.</p><p>To combine <code>IO</code> values we can use <a href="IO.html#map[B](f:A=&gt;B):monix.bio.IO[E,B]" name="monix.bio.IO#map" id="monix.bio.IO#map" class="extmbr">.map</a> and
<a href="IO.html#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.IO[E1,B]):monix.bio.IO[E1,B]" name="monix.bio.IO#flatMap" id="monix.bio.IO#flatMap" class="extmbr">.flatMap</a>, which describe sequencing and this time
it's in a very real sense because of the laziness involved:</p><pre><span class="kw">val</span> sayHello = hello
  .flatMap(h <span class="kw">=&gt;</span> world.map(w <span class="kw">=&gt;</span> h + w))
  .map(println)</pre><p>This <code>IO</code> reference will trigger a side effect on evaluation, but
not yet. To make the above print its message:</p><pre><span class="kw">import</span> monix.execution.CancelableFuture
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="kw">val</span> f = sayHello.runToFuture
<span class="cmt">// =&gt; Hello World!</span></pre><p>The returned type is a
<a href="https://monix.io/api/3.1/monix/execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a> which
inherits from Scala's standard <a href="https://www.scala-lang.org/api/2.13.1/scala/concurrent/Future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>,
a value that can be completed already or might be completed at
some point in the future, once the running asynchronous process
finishes. Such a future value can also be canceled, see below.</p><h3>Laziness, Purity and Referential Transparency</h3><p>The fact that <code>Task</code> is lazy whereas <code>Future</code> is not
has real consequences. For example with <code>Task</code> you can do this:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="kw">def</span> retryOnFailure[A](times: <span class="std">Int</span>, source: Task[A]): Task[A] =
  source.onErrorHandleWith { err <span class="kw">=&gt;</span>
    <span class="cmt">// No more retries left? Re-throw error:</span>
    <span class="kw">if</span> (times &lt;= <span class="num">0</span>) Task.raiseError(err) <span class="kw">else</span> {
      <span class="cmt">// Recursive call, yes we can!</span>
      retryOnFailure(times - <span class="num">1</span>, source)
        <span class="cmt">// Adding 500 ms delay for good measure</span>
        .delayExecution(<span class="num">500.</span>millis)
    }
  }</pre><p><code>Future</code> being a strict value-wannabe means that the actual value
gets "memoized" (means cached), however <code>Task</code> is basically a function
that can be repeated for as many times as you want.</p><p><code>Task</code> is a pure data structure that can be used to describe
pure functions, the equivalent of Haskell's <code>IO</code>.</p><h4>Memoization</h4><p><code>Task</code> can also do memoization, making it behave like a "lazy"
Scala <code>Future</code>, meaning that nothing is started yet, its
side effects being evaluated on the first <code>runAsync</code> and then
the result reused on subsequent evaluations:</p><pre>Task(println(<span class="lit">"boo"</span>)).memoize</pre><p>The difference between this and just calling <code>runAsync()</code> is that
<code>memoize()</code> still returns a <code>Task</code> and the actual memoization
happens on the first <code>runAsync()</code> (with idempotency guarantees of
course).</p><p>But here's something else that the <code>Future</code> data type cannot do,
<a href="IO.html#memoizeOnSuccess:monix.bio.IO[E,A]" name="monix.bio.IO#memoizeOnSuccess" id="monix.bio.IO#memoizeOnSuccess" class="extmbr">memoizeOnSuccess</a>:</p><pre>Task.eval {
  <span class="kw">if</span> (scala.util.Random.nextDouble() &gt; <span class="num">0.33</span>)
    <span class="kw">throw</span> <span class="kw">new</span> RuntimeException(<span class="lit">"error!"</span>)
  println(<span class="lit">"moo"</span>)
}.memoizeOnSuccess</pre><p>This keeps repeating the computation for as long as the result is a
failure and caches it only on success. Yes we can!</p><p><i>WARNING:</i> as awesome as <code>memoize</code> can be, use with care
because memoization can break referential transparency!</p><h4>Parallelism</h4><p>Because of laziness, invoking
<a href="IO$.html#sequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#sequence" id="monix.bio.IO#sequence" class="extmbr">IO.sequence</a> will not work like
it does for <code>Future.sequence</code>, the given <code>Task</code> values being
evaluated one after another, in <i>sequence</i>, not in <i>parallel</i>.
If you want parallelism, then you need to use
<a href="IO$.html#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">IO.parSequence</a> and thus be explicit about it.</p><p>This is great because it gives you the possibility of fine tuning the
execution. For example, say you want to execute things in parallel,
but with a maximum limit of 30 tasks being executed in parallel.
One way of doing that is to process your list in batches:</p><pre><span class="cmt">// Some array of tasks, you come up with something good :-)</span>
<span class="kw">val</span> list: <span class="std">Seq</span>[Task[<span class="std">Int</span>]] = <span class="std">Seq</span>.tabulate(<span class="num">100</span>)(Task(_))

<span class="cmt">// Split our list in chunks of 30 items per chunk,</span>
<span class="cmt">// this being the maximum parallelism allowed</span>
<span class="kw">val</span> chunks = list.sliding(<span class="num">30</span>, <span class="num">30</span>).toSeq

<span class="cmt">// Specify that each batch should process stuff in parallel</span>
<span class="kw">val</span> batchedTasks = chunks.map(chunk <span class="kw">=&gt;</span> Task.parSequence(chunk))
<span class="cmt">// Sequence the batches</span>
<span class="kw">val</span> allBatches = Task.sequence(batchedTasks)

<span class="cmt">// Flatten the result, within the context of Task</span>
<span class="kw">val</span> all: Task[<span class="std">Seq</span>[<span class="std">Int</span>]] = allBatches.map(_.flatten)</pre><p>Note that the built <code>Task</code> reference is just a specification at
this point, or you can view it as a function, as nothing has
executed yet, you need to call <a href="IO.html#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.IO#runAsync" id="monix.bio.IO#runAsync" class="extmbr">runAsync</a>
or <a href="IO.html#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.IO#runToFuture" id="monix.bio.IO#runToFuture" class="extmbr">runToFuture</a> explicitly.</p><h3>Cancellation</h3><p>The logic described by an <code>Task</code> task could be cancelable,
depending on how the <code>Task</code> gets built.</p><p><a href="https://monix.io/api/3.1/monix/execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a> references
can also be canceled, in case the described computation can be
canceled. When describing <code>Task</code> tasks with <code>Task.eval</code> nothing
can be cancelled, since there's nothing about a plain function
that you can cancel, but we can build cancelable tasks with
<a href="IO$.html#cancelable0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;cats.effect.CancelToken[[β$1$]monix.bio.IO[E,β$1$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable0" id="monix.bio.IO#cancelable0" class="extmbr">IO.cancelable</a>.</p><pre><span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> scala.util._

<span class="kw">val</span> delayedHello = Task.cancelable0[<span class="std">Unit</span>] { (scheduler, callback) <span class="kw">=&gt;</span>
  <span class="kw">val</span> task = scheduler.scheduleOnce(<span class="num">1.</span>second) {
    println(<span class="lit">"Delayed Hello!"</span>)
    <span class="cmt">// Signaling successful completion</span>
    callback(Success(()))
  }
  <span class="cmt">// Returning a cancel token that knows how to cancel the</span>
  <span class="cmt">// scheduled computation:</span>
  Task {
    println(<span class="lit">"Cancelling!"</span>)
    task.cancel()
  }
}</pre><p>The sample above prints a message with a delay, where the delay
itself is scheduled with the injected <code>Scheduler</code>. The <code>Scheduler</code>
is in fact an implicit parameter to <code>runAsync()</code>.</p><p>This action can be cancelled, because it specifies cancellation
logic. In case we have no cancelable logic to express, then it's
OK if we returned a
<a href="https://monix.io/api/3.1/monix/execution/Cancelable$.html#empty:monix.execution.Cancelable" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable.empty</a> reference,
in which case the resulting <code>Task</code> would not be cancelable.</p><p>But the <code>Task</code> we just described is cancelable, for one at the
edge, due to <code>runAsync</code> returning <a href="https://monix.io/api/3.1/monix/execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a>
and <a href="https://monix.io/api/3.1/monix/execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a> references:</p><pre><span class="cmt">// Triggering execution</span>
<span class="kw">val</span> cf = delayedHello.runToFuture

<span class="cmt">// If we change our mind before the timespan has passed:</span>
cf.cancel()</pre><p>But also cancellation is described on <code>Task</code> as a pure action,
which can be used for example in <a href="IO$.html#race[E,A,B](fa:monix.bio.IO[E,A],fb:monix.bio.IO[E,B]):monix.bio.IO[E,Either[A,B]]" name="monix.bio.IO#race" id="monix.bio.IO#race" class="extmbr">race</a> conditions:</p><pre><span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> scala.concurrent.TimeoutException

<span class="kw">val</span> ta = Task(<span class="num">1</span> + <span class="num">1</span>).delayExecution(<span class="num">4.</span>seconds)

<span class="kw">val</span> tb = Task.raiseError[<span class="std">Int</span>](<span class="kw">new</span> TimeoutException)
  .delayExecution(<span class="num">4.</span>seconds)

Task.racePair(ta, tb).flatMap {
  <span class="kw">case</span> Left((a, fiberB)) <span class="kw">=&gt;</span>
    fiberB.cancel.map(_ <span class="kw">=&gt;</span> a)
  <span class="kw">case</span> Right((fiberA, b)) <span class="kw">=&gt;</span>
    fiberA.cancel.map(_ <span class="kw">=&gt;</span> b)
}</pre><p>The returned type in <code>racePair</code> is <a href="Fiber.html" name="monix.bio.Fiber" id="monix.bio.Fiber" class="extype">Fiber</a>, which is a data
type that's meant to wrap tasks linked to an active process
and that can be <a href="Fiber.html#cancel:cats.effect.CancelToken[monix.bio.UIO]" name="monix.bio.Fiber#cancel" id="monix.bio.Fiber#cancel" class="extmbr">canceled</a> or <a href="Fiber.html#join:monix.bio.IO[E,A]" name="monix.bio.Fiber#join" id="monix.bio.Fiber#join" class="extmbr">joined</a>.</p><p>Also, given a task, we can specify actions that need to be
triggered in case of cancellation, see
<a href="IO.html#doOnCancel(callback:monix.bio.UIO[Unit]):monix.bio.IO[E,A]" name="monix.bio.IO#doOnCancel" id="monix.bio.IO#doOnCancel" class="extmbr">doOnCancel</a>:</p><pre><span class="kw">val</span> task = Task.eval(println(<span class="lit">"Hello!"</span>)).executeAsync

task doOnCancel IO.evalTotal {
  println(<span class="lit">"A cancellation attempt was made!"</span>)
}</pre><p>Given a task, we can also create a new task from it that atomic
(non cancelable), in the sense that either all of it executes
or nothing at all, via <a href="IO.html#uncancelable:monix.bio.IO[E,A]" name="monix.bio.IO#uncancelable" id="monix.bio.IO#uncancelable" class="extmbr">uncancelable</a>.</p><h3>Note on the ExecutionModel</h3><p><code>Task</code> is conservative in how it introduces async boundaries.
Transformations like <code>map</code> and <code>flatMap</code> for example will default
to being executed on the current call stack on which the
asynchronous computation was started. But one shouldn't make
assumptions about how things will end up executed, as ultimately
it is the implementation's job to decide on the best execution
model. All you are guaranteed (and can assume) is asynchronous
execution after executing <code>runAsync</code>.</p><p>Currently the default
<a href="https://monix.io/api/3.1/monix/execution/ExecutionModel.html" name="monix.execution.ExecutionModel" id="monix.execution.ExecutionModel" class="extype">ExecutionModel</a> specifies
batched execution by default and <code>Task</code> in its evaluation respects
the injected <code>ExecutionModel</code>. If you want a different behavior,
you need to execute the <code>Task</code> reference with a different scheduler.</p></div></div></li><li class="indented0 " name="monix.bio.IOLift" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="IOLift[F[_]]extendsmonix.bio.Task~&gt;F"></a><a id="IOLift[F[_]]:IOLift[F]"></a> <span class="permalink"><a href="../../monix/bio/IOLift.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="IOLift.html" title="A lawless type class that specifies conversions from IO to similar data types (i.e."><span class="name">IOLift</span></a><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="result"> extends <span name="cats.~&gt;" class="extype">~&gt;</span>[<a href="#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>, <span name="monix.bio.IOLift.F" class="extype">F</span>]</span></span><p class="shortcomment cmt">A lawless type class that specifies conversions from <code>IO</code>
to similar data types (i.e.</p><div class="fullcomment"><div class="comment cmt"><p>A lawless type class that specifies conversions from <code>IO</code>
to similar data types (i.e. pure, asynchronous, preferably
cancelable).
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@implicitNotFound</span><span class="args">(<span><span class="defval">"""Cannot find implicit value for IOLift[${F}].<br/>Building this implicit value might depend on having an implicit<br/>s.c.ExecutionContext in scope, a Scheduler or some equivalent type."""</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.IOLike" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="IOLike[F[_]]extendsF~&gt;monix.bio.Task"></a><a id="IOLike[F[_]]:IOLike[F]"></a> <span class="permalink"><a href="../../monix/bio/IOLike.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="IOLike.html" title="A lawless type class that provides conversions into a IO."><span class="name">IOLike</span></a><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="result"> extends <span name="cats.~&gt;" class="extype">~&gt;</span>[<span name="monix.bio.IOLike.F" class="extype">F</span>, <a href="#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>]</span></span><p class="shortcomment cmt">A lawless type class that provides conversions into a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>.</p><div class="fullcomment"><div class="comment cmt"><p>A lawless type class that provides conversions into a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>.</p><p>Sample:</p><pre><span class="cmt">// Conversion from cats.Eval</span>
<span class="kw">import</span> cats.Eval

<span class="kw">val</span> source0 = Eval.always(<span class="num">1</span> + <span class="num">1</span>)
<span class="kw">val</span> task0 = IOLike[Eval].apply(source0)

<span class="cmt">// Conversion from Future</span>
<span class="kw">import</span> scala.concurrent.Future

<span class="kw">val</span> source1 = Future.successful(<span class="num">1</span> + <span class="num">1</span>)
<span class="kw">val</span> task1 = IOLike[Future].apply(source1)

<span class="cmt">// Conversion from IO</span>
<span class="kw">import</span> cats.effect.{IO <span class="kw">=&gt;</span> CIO}

<span class="kw">val</span> source2 = CIO(<span class="num">1</span> + <span class="num">1</span>)
<span class="kw">val</span> task2 = IOLike[CIO].apply(source2)</pre><p>This is an alternative to the usage of <a href="https://typelevel.org/cats-effect/api/cats/effect/Effect.html" name="cats.effect.Effect" id="cats.effect.Effect" class="extype">cats.effect.Effect</a>,
where the internals are specialized to <code>IO</code> anyway, like for
example the implementation of <code>monix.reactive.Observable</code>.
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@implicitNotFound</span><span class="args">(<span><span class="defval">"""Cannot find implicit value for IOLike[${F}].<br/>Building this implicit value might depend on having an implicit<br/>s.c.ExecutionContext in scope, a Scheduler or some equivalent type."""</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.IOLocal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="IOLocal[A]extendsAnyRef"></a><a id="IOLocal[A]:IOLocal[A]"></a> <span class="permalink"><a href="../../monix/bio/IOLocal.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="IOLocal.html" title="A IOLocal is like a ThreadLocal that is pure and with a flexible scope, being processed in the context of the IO data type."><span class="name">IOLocal</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><p class="shortcomment cmt">A <code>IOLocal</code> is like a
<a href="https://monix.io/api/3.1/monix/execution/misc/ThreadLocal.html" name="monix.execution.misc.ThreadLocal" id="monix.execution.misc.ThreadLocal" class="extype">ThreadLocal</a>
that is pure and with a flexible scope, being processed in the
context of the <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> data type.</p><div class="fullcomment"><div class="comment cmt"><p>A <code>IOLocal</code> is like a
<a href="https://monix.io/api/3.1/monix/execution/misc/ThreadLocal.html" name="monix.execution.misc.ThreadLocal" id="monix.execution.misc.ThreadLocal" class="extype">ThreadLocal</a>
that is pure and with a flexible scope, being processed in the
context of the <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> data type.</p><p>This data type wraps <a href="https://monix.io/api/3.1/monix/execution/misc/Local.html" name="monix.execution.misc.Local" id="monix.execution.misc.Local" class="extype">monix.execution.misc.Local</a>.</p><p>Just like a <code>ThreadLocal</code>, usage of a <code>IOLocal</code> is safe,
the state of all current locals being transported over
async boundaries (aka when threads get forked) by the <code>Task</code>
run-loop implementation, but only when the <code>Task</code> reference
gets executed with <a href="IO$$Options.html#localContextPropagation:Boolean" name="monix.bio.IO.Options#localContextPropagation" id="monix.bio.IO.Options#localContextPropagation" class="extmbr">IO.Options.localContextPropagation</a>
set to <code>true</code>.</p><p>One way to achieve this is with <a href="IO.html#executeWithOptions(f:monix.bio.IO.Options=&gt;monix.bio.IO.Options):monix.bio.IO[E,A]" name="monix.bio.IO#executeWithOptions" id="monix.bio.IO#executeWithOptions" class="extmbr">IO.executeWithOptions</a>,
a single call is sufficient just before <code>runAsync</code>:</p><pre><span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="kw">val</span> t = Task(<span class="num">42</span>)
t.executeWithOptions(_.enableLocalContextPropagation)
  <span class="cmt">// triggers the actual execution</span>
  .runToFuture</pre><p>Another possibility is to use <a href="IO.html#runToFutureOpt(implicits:monix.execution.Scheduler,implicitopts:monix.bio.IO.Options,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.IO#runToFutureOpt" id="monix.bio.IO#runToFutureOpt" class="extmbr">IO.runToFutureOpt</a> or
<a href="IO.html#runToFutureOpt(implicits:monix.execution.Scheduler,implicitopts:monix.bio.IO.Options,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.IO#runToFutureOpt" id="monix.bio.IO#runToFutureOpt" class="extmbr">IO.runToFutureOpt</a> instead of <code>runAsync</code> and specify the set of
options implicitly:</p><pre>{
  <span class="kw">implicit</span> <span class="kw">val</span> options = IO.defaultOptions.enableLocalContextPropagation

  <span class="cmt">// Options passed implicitly</span>
  <span class="kw">val</span> f = t.runToFutureOpt
}</pre><p>Full example:</p><pre><span class="kw">import</span> monix.bio.{UIO, IOLocal}

<span class="kw">val</span> task: UIO[<span class="std">Unit</span>] =
  <span class="kw">for</span> {
    local <span class="kw">&lt;-</span> IOLocal(<span class="num">0</span>)
    value1 <span class="kw">&lt;-</span> local.read <span class="cmt">// value1 == 0</span>
    _ <span class="kw">&lt;-</span> local.write(<span class="num">100</span>)
    value2 <span class="kw">&lt;-</span> local.read <span class="cmt">// value2 == 100</span>
    value3 <span class="kw">&lt;-</span> local.bind(<span class="num">200</span>)(local.read.map(_ * <span class="num">2</span>)) <span class="cmt">// value3 == 200 * 2</span>
    value4 <span class="kw">&lt;-</span> local.read <span class="cmt">// value4 == 100</span>
    _ <span class="kw">&lt;-</span> local.clear
    value5 <span class="kw">&lt;-</span> local.read <span class="cmt">// value5 == 0</span>
  } <span class="kw">yield</span> {
    <span class="cmt">// Should print 0, 100, 400, 100, 0</span>
    println(<span class="lit">"value1: "</span> + value1)
    println(<span class="lit">"value2: "</span> + value2)
    println(<span class="lit">"value3: "</span> + value3)
    println(<span class="lit">"value4: "</span> + value4)
    println(<span class="lit">"value5: "</span> + value5)
  }

<span class="cmt">// For transporting locals over async boundaries defined by</span>
<span class="cmt">// Task, any Scheduler will do, however for transporting locals</span>
<span class="cmt">// over async boundaries managed by Future and others, you need</span>
<span class="cmt">// a `TracingScheduler` here:</span>
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="cmt">// Needs enabling the "localContextPropagation" option</span>
<span class="cmt">// just before execution</span>
<span class="kw">implicit</span> <span class="kw">val</span> opts = IO.defaultOptions.enableLocalContextPropagation

<span class="cmt">// Triggering actual execution</span>
<span class="kw">val</span> result = task.runToFutureOpt</pre></div></div></li><li class="indented0 " name="monix.bio.Task" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Task[+A]=monix.bio.IO[Throwable,A]"></a><a id="Task[+A]:Task[A]"></a> <span class="permalink"><a href="../../monix/bio/index.html#Task[+A]=monix.bio.IO[Throwable,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">type</span></span> <span class="symbol"><span class="name">Task</span><span class="tparams">[<span name="A">+A</span>]</span><span class="result alias"> = <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.bio.Task.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Type alias that represents <code>IO</code> which is expected to fail with any <code>Throwable.</code>
Similar to <code>monix.eval.Task</code> and <code>cats.effect.IO</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias that represents <code>IO</code> which is expected to fail with any <code>Throwable.</code>
Similar to <code>monix.eval.Task</code> and <code>cats.effect.IO</code>.</p><p>WARNING: There are still two error channels (both <code>Throwable</code>) so use with care.
         If error is thrown from what was expected to be a pure function (map, flatMap, finalizers, etc.)
         then it will terminate the Task, instead of a normal failure.
</p></div></div></li><li class="indented0 " name="monix.bio.UIO" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="UIO[+A]=monix.bio.IO[Nothing,A]"></a><a id="UIO[+A]:UIO[A]"></a> <span class="permalink"><a href="../../monix/bio/index.html#UIO[+A]=monix.bio.IO[Nothing,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">type</span></span> <span class="symbol"><span class="name">UIO</span><span class="tparams">[<span name="A">+A</span>]</span><span class="result alias"> = <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<a href="https://www.scala-lang.org/api/2.13.1/scala/Nothing.html#scala.Nothing" name="scala.Nothing" id="scala.Nothing" class="extype">Nothing</a>, <span name="monix.bio.UIO.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Type alias that represents <code>IO</code> in which all expected errors were handled.</p></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="monix.bio.BiCallback" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="BiCallback"></a><a id="BiCallback:BiCallback"></a> <span class="permalink"><a href="../../monix/bio/BiCallback$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="BiCallback$.html" title=""><span class="name">BiCallback</span></a></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="monix.bio.Cause" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Cause"></a><a id="Cause:Cause"></a> <span class="permalink"><a href="../../monix/bio/Cause$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Cause$.html" title=""><span class="name">Cause</span></a><span class="result"> extends <span name="java.io.Serializable" class="extype">Serializable</span></span></span></li><li class="indented0 " name="monix.bio.Fiber" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Fiber"></a><a id="Fiber:Fiber"></a> <span class="permalink"><a href="../../monix/bio/Fiber$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Fiber$.html" title=""><span class="name">Fiber</span></a></span></li><li class="indented0 " name="monix.bio.IO" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="IO"></a><a id="IO:IO"></a> <span class="permalink"><a href="../../monix/bio/IO$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="IO$.html" title="Builders for IO."><span class="name">IO</span></a><span class="result"> extends <span name="monix.bio.TaskInstancesLevel0" class="extype">TaskInstancesLevel0</span> with <span name="java.io.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Builders for <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>.</p></li><li class="indented0 " name="monix.bio.IOLift" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="IOLift"></a><a id="IOLift:IOLift"></a> <span class="permalink"><a href="../../monix/bio/IOLift$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="IOLift$.html" title=""><span class="name">IOLift</span></a><span class="result"> extends <span name="monix.bio.IOLiftImplicits0" class="extype">IOLiftImplicits0</span> with <span name="java.io.Serializable" class="extype">Serializable</span></span></span></li><li class="indented0 " name="monix.bio.IOLike" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="IOLike"></a><a id="IOLike:IOLike"></a> <span class="permalink"><a href="../../monix/bio/IOLike$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="IOLike$.html" title=""><span class="name">IOLike</span></a><span class="result"> extends <span name="monix.bio.IOLikeImplicits0" class="extype">IOLikeImplicits0</span> with <span name="java.io.Serializable" class="extype">Serializable</span></span></span></li><li class="indented0 " name="monix.bio.IOLocal" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="IOLocal"></a><a id="IOLocal:IOLocal"></a> <span class="permalink"><a href="../../monix/bio/IOLocal$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="IOLocal$.html" title="Builders for IOLocal"><span class="name">IOLocal</span></a></span><p class="shortcomment cmt">Builders for <a href="IOLocal.html" name="monix.bio.IOLocal" id="monix.bio.IOLocal" class="extype">IOLocal</a></p></li><li class="indented0 " name="monix.bio.Task" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Task"></a><a id="Task:Task"></a> <span class="permalink"><a href="../../monix/bio/Task$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Task$.html" title=""><span class="name">Task</span></a><span class="result"> extends <span name="monix.bio.internal.TaskDeprecated.Companion" class="extype">Companion</span></span></span></li><li class="indented0 " name="monix.bio.UIO" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="UIO"></a><a id="UIO:UIO"></a> <span class="permalink"><a href="../../monix/bio/UIO$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="UIO$.html" title=""><span class="name">UIO</span></a><span class="result"> extends <span name="monix.bio.internal.UIODeprecated.Companion" class="extype">Companion</span></span></span></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.1/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.1/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
