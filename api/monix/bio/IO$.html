<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Monix BIO v1.2.0+14-3ac8b4af-SNAPSHOT - monix.bio.IO</title><meta content="Monix BIO v1.2.0 14 - 3ac8b4af - SNAPSHOT - monix.bio.IO" name="description"/><meta content="Monix BIO v1.2.0 14 3ac8b4af SNAPSHOT monix.bio.IO" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title">Monix BIO<span id="doc-version">v1.2.0+14-3ac8b4af-SNAPSHOT</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.monix" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monix" class="anchorToMember"></a><a id="monix:monix" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">monix</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="monix.bio" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bio" class="anchorToMember"></a><a id="bio:bio" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">bio</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="monix" id="monix" class="extype">monix</a></dd></dl></div></li><li class="indented3 " name="monix.bio.instances" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="instances" class="anchorToMember"></a><a id="instances:instances" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/instances/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="instances/index.html" title=""><span class="name">instances</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.bio" id="monix.bio" class="extype">bio</a></dd></dl></div></li><li class="indented3 " name="monix.bio.internal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="internal" class="anchorToMember"></a><a id="internal:internal" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/internal/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="internal/index.html" title=""><span class="name">internal</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.bio" id="monix.bio" class="extype">bio</a></dd></dl></div></li><li class="indented3 " name="monix.bio.tracing" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="tracing" class="anchorToMember"></a><a id="tracing:tracing" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/tracing/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="tracing/index.html" title=""><span class="name">tracing</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.bio" id="monix.bio" class="extype">bio</a></dd></dl></div></li><li class="current-entities indented2"><span class="separator"></span> <a href="BIOApp.html" title="Safe App type that executes a IO." class="trait"></a><a href="BIOApp.html" title="Safe App type that executes a IO.">BIOApp</a></li><li class="current-entities indented2"><a href="BiCallback$.html" title="" class="object"></a> <a href="BiCallback.html" title="Callback type which supports two channels of errors." class="class"></a><a href="BiCallback.html" title="Callback type which supports two channels of errors.">BiCallback</a></li><li class="current-entities indented2"><a href="Cause$.html" title="" class="object"></a> <a href="Cause.html" title="Represent a complete cause of the failed IO exposing both typed and untyped error channel." class="class"></a><a href="Cause.html" title="Represent a complete cause of the failed IO exposing both typed and untyped error channel.">Cause</a></li><li class="current-entities indented2"><a href="Fiber$.html" title="" class="object"></a> <a href="Fiber.html" title="Fiber represents the (pure) result of a IO being started concurrently and that can be either joined or cancelled." class="trait"></a><a href="Fiber.html" title="Fiber represents the (pure) result of a IO being started concurrently and that can be either joined or cancelled.">Fiber</a></li><li class="current-entities indented2"><a href="" title="Builders for IO." class="object"></a> <a href="IO.html" title="Task represents a specification for a possibly lazy or asynchronous computation, which when executed will produce an A as a result, along with possible side-effects." class="class"></a><a href="IO.html" title="Task represents a specification for a possibly lazy or asynchronous computation, which when executed will produce an A as a result, along with possible side-effects.">IO</a></li><li class="current-entities indented2"><a href="IOLift$.html" title="" class="object"></a> <a href="IOLift.html" title="A lawless type class that specifies conversions from IO to similar data types (i.e." class="trait"></a><a href="IOLift.html" title="A lawless type class that specifies conversions from IO to similar data types (i.e.">IOLift</a></li><li class="current-entities indented2"><a href="IOLike$.html" title="" class="object"></a> <a href="IOLike.html" title="A lawless type class that provides conversions into a IO." class="trait"></a><a href="IOLike.html" title="A lawless type class that provides conversions into a IO.">IOLike</a></li><li class="current-entities indented2"><a href="IOLocal$.html" title="Builders for IOLocal" class="object"></a> <a href="IOLocal.html" title="A IOLocal is like a ThreadLocal that is pure and with a flexible scope, being processed in the context of the IO data type." class="class"></a><a href="IOLocal.html" title="A IOLocal is like a ThreadLocal that is pure and with a flexible scope, being processed in the context of the IO data type.">IOLocal</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Task$.html" title="" class="object"></a><a href="Task$.html" title="">Task</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="UIO$.html" title="" class="object"></a><a href="UIO$.html" title="">UIO</a></li></ul></div></div><div id="content"><body class="object value"><div id="definition"><a href="IO.html" title="See companion class"><div class="big-circle object-companion-class">o</div></a><p id="owner"><a href="../index.html" name="monix" id="monix" class="extype">monix</a>.<a href="index.html" name="monix.bio" id="monix.bio" class="extype">bio</a></p><h1><a href="IO.html" title="See companion class">IO</a><span class="permalink"><a href="../../monix/bio/IO$.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"><div>Companion <a href="IO.html" title="See companion class">class IO</a></div></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><span class="name">IO</span><span class="result"> extends <span name="monix.bio.TaskInstancesLevel0" class="extype">TaskInstancesLevel0</span> with <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Builders for <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>.</p></div><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/monix/monix-bio/tree/v1.2.0+14-3ac8b4af-SNAPSHOT/core/shared/src/main/scala/monix/bio/IO.scala" target="_blank">IO.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a>, <span name="monix.bio.TaskInstancesLevel0" class="extype">TaskInstancesLevel0</span>, <span name="monix.bio.TaskInstancesLevel1" class="extype">TaskInstancesLevel1</span>, <span name="monix.bio.TaskInstancesLevel2" class="extype">TaskInstancesLevel2</span>, <span name="monix.bio.TaskParallelNewtype" class="extype">TaskParallelNewtype</span>, <span name="monix.bio.TaskContextShift" class="extype">TaskContextShift</span>, <span name="monix.bio.TaskTimers" class="extype">TaskTimers</span>, <span name="monix.bio.TaskClocks" class="extype">TaskClocks</span>, <span name="monix.bio.internal.IODeprecated.Companion" class="extype">Companion</span>, <a href="https://www.scala-lang.org/api/2.13.6/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.6/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="monix.bio.IO"><span>IO</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="monix.bio.TaskInstancesLevel0"><span>TaskInstancesLevel0</span></li><li class="in" name="monix.bio.TaskInstancesLevel1"><span>TaskInstancesLevel1</span></li><li class="in" name="monix.bio.TaskInstancesLevel2"><span>TaskInstancesLevel2</span></li><li class="in" name="monix.bio.TaskParallelNewtype"><span>TaskParallelNewtype</span></li><li class="in" name="monix.bio.TaskContextShift"><span>TaskContextShift</span></li><li class="in" name="monix.bio.TaskTimers"><span>TaskTimers</span></li><li class="in" name="monix.bio.TaskClocks"><span>TaskClocks</span></li><li class="in" name="monix.bio.internal.IODeprecated.Companion"><span>Companion</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="monix.bio.IO.AsyncBuilder" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="AsyncBuilder[CancelationToken]extendsAnyRef" class="anchorToMember"></a><a id="AsyncBuilder[CancelationToken]:AsyncBuilder[CancelationToken]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$$AsyncBuilder.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="IO$$AsyncBuilder.html" title="The AsyncBuilder is a type used by the IO.create builder, in order to change its behavior based on the type of the cancelation token."><span class="name">AsyncBuilder</span></a><span class="tparams">[<span name="CancelationToken">CancelationToken</span>]</span><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.6/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><p class="shortcomment cmt">The <code>AsyncBuilder</code> is a type used by the <a href="#create[E,A]:monix.bio.IO.AsyncBuilder.CreatePartiallyApplied[E,A]" name="monix.bio.IO#create" id="monix.bio.IO#create" class="extmbr">IO.create</a> builder,
in order to change its behavior based on the type of the
cancelation token.</p><div class="fullcomment"><div class="comment cmt"><p>The <code>AsyncBuilder</code> is a type used by the <a href="#create[E,A]:monix.bio.IO.AsyncBuilder.CreatePartiallyApplied[E,A]" name="monix.bio.IO#create" id="monix.bio.IO#create" class="extmbr">IO.create</a> builder,
in order to change its behavior based on the type of the
cancelation token.</p><p>In combination with the
<a href="https://typelevel.org/cats/guidelines.html#partially-applied-type-params" target="_blank">Partially-Applied Type technique</a>,
this ends up providing a polymorphic <a href="#create[E,A]:monix.bio.IO.AsyncBuilder.CreatePartiallyApplied[E,A]" name="monix.bio.IO#create" id="monix.bio.IO#create" class="extmbr">IO.create</a> that can
support multiple cancelation tokens optimally, i.e. without
implicit conversions and that can be optimized depending on
the <code>CancelToken</code> used - for example if <code>Unit</code> is returned,
then the yielded task will not be cancelable and the internal
implementation will not have to worry about managing it, thus
increasing performance.
</p></div></div></li><li class="indented0 " name="monix.bio.IO.Options" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="OptionsextendsProductwithSerializable" class="anchorToMember"></a><a id="Options:Options" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$$Options.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">case class</span></span> <span class="symbol"><a href="IO$$Options.html" title="Set of options for customizing the task's behavior."><span class="name">Options</span></a><span class="params">(<span name="autoCancelableRunLoops">autoCancelableRunLoops: <a href="https://www.scala-lang.org/api/2.13.6/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>, <span name="localContextPropagation">localContextPropagation: <a href="https://www.scala-lang.org/api/2.13.6/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.6/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Set of options for customizing the task's behavior.</p><div class="fullcomment"><div class="comment cmt"><p>Set of options for customizing the task's behavior.</p><p>See <a href="#defaultOptions:monix.bio.IO.Options" name="monix.bio.IO#defaultOptions" id="monix.bio.IO#defaultOptions" class="extmbr">IO.defaultOptions</a> for the default <code>Options</code> instance
used by <a href="IO.html#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.IO#runAsync" id="monix.bio.IO#runAsync" class="extmbr">IO.runAsync</a> or <a href="IO.html#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.IO#runToFuture" id="monix.bio.IO#runToFuture" class="extmbr">IO.runToFuture</a>.
</p></div><dl class="paramcmts block"><dt class="param">autoCancelableRunLoops</dt><dd class="cmt"><p>should be set to <code>true</code> in
                               case you want <code>flatMap</code> driven loops to be
                               auto-cancelable. Defaults to <code>true</code>.</p></dd><dt class="param">localContextPropagation</dt><dd class="cmt"><p>should be set to <code>true</code> in
                               case you want the <a href="https://monix.io/api/3.1/monix/execution/misc/Local.html" name="monix.execution.misc.Local" id="monix.execution.misc.Local" class="extype">Local</a>
                               variables to be propagated on async boundaries.
                               Defaults to <code>false</code>.</p></dd></dl></div></li><li class="indented0 " name="monix.bio.TaskParallelNewtype.Par" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Par[+E,+A]=TaskParallelNewtype.this.Par.Type[E,A]" class="anchorToMember"></a><a id="Par[+E,+A]:Par[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#Par[+E,+A]=TaskParallelNewtype.this.Par.Type[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">type</span></span> <span class="symbol"><span class="name">Par</span><span class="tparams">[<span name="E">+E</span>, <span name="A">+A</span>]</span><span class="result alias"> = <span name="monix.bio.instances.Newtype2.Type" class="extype">TaskParallelNewtype.Par.Type</span>[<span name="monix.bio.TaskParallelNewtype.Par.E" class="extype">E</span>, <span name="monix.bio.TaskParallelNewtype.Par.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Newtype encoding for a <code>Task</code> data type that has a <a href="http://typelevel.org/cats/api/cats/Applicative.html" name="cats.Applicative" id="cats.Applicative" class="extype">cats.Applicative</a>
capable of doing parallel processing in <code>ap</code> and <code>map2</code>, needed
for implementing <code>cats.Parallel</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Newtype encoding for a <code>Task</code> data type that has a <a href="http://typelevel.org/cats/api/cats/Applicative.html" name="cats.Applicative" id="cats.Applicative" class="extype">cats.Applicative</a>
capable of doing parallel processing in <code>ap</code> and <code>map2</code>, needed
for implementing <code>cats.Parallel</code>.</p><p>Helpers are provided for converting back and forth in <code>Par.apply</code>
for wrapping any <code>Task</code> value and <code>Par.unwrap</code> for unwrapping.</p><p>The encoding is based on the "newtypes" project by
Alexander Konovalov, chosen because it's devoid of boxing issues and
a good choice until opaque types will land in Scala.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskParallelNewtype</dd></dl></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean" class="anchorToMember"></a><a id="!=(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.6/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean" class="anchorToMember"></a><a id="==(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.6/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.bio.IO#apply" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="apply[A](a:=&gt;A):monix.bio.Task[A]" class="anchorToMember"></a><a id="apply[A](=&gt;A):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#apply[A](a:=&gt;A):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">apply</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: =&gt; <span name="monix.bio.IO.apply.A" class="extype">A</span></span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.apply.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Lifts the given thunk in the <code>IO</code> context, processing it synchronously
when the task gets evaluated.</p><div class="fullcomment"><div class="comment cmt"><p>Lifts the given thunk in the <code>IO</code> context, processing it synchronously
when the task gets evaluated.</p><p>This is an alias for:</p><pre><span class="kw">val</span> thunk = () <span class="kw">=&gt;</span> <span class="num">42</span>
IO.eval(thunk())</pre><p>WARN: behavior of <code>IO.apply</code> has changed since 3.0.0-RC2.
Before the change (during Monix 2.x series), this operation was forcing
a fork, being equivalent to the new <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a>.</p><p>Switch to <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> if you wish the old behavior, or combine
<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> with <a href="IO.html#executeAsync:monix.bio.IO[E,A]" name="monix.bio.IO#executeAsync" id="monix.bio.IO#executeAsync" class="extmbr">IO.executeAsync</a>.
</p></div></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="monix.bio.IO#async" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="async[E,A](register:monix.bio.BiCallback[E,A]=&gt;Unit):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="async[E,A]((BiCallback[E,A])=&gt;Unit):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#async[E,A](register:monix.bio.BiCallback[E,A]=&gt;Unit):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">async</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="register">register: (<a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a>[<span name="monix.bio.IO.async.E" class="extype">E</span>, <span name="monix.bio.IO.async.A" class="extype">A</span>]) =&gt; <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.async.E" class="extype">E</span>, <span name="monix.bio.IO.async.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Create a non-cancelable <code>Task</code> from an asynchronous computation,
which takes the form of a function with which we can register a
callback to execute upon completion.</p><div class="fullcomment"><div class="comment cmt"><p>Create a non-cancelable <code>Task</code> from an asynchronous computation,
which takes the form of a function with which we can register a
callback to execute upon completion.</p><p>This operation is the implementation for <code>cats.effect.Async</code> and
is thus yielding non-cancelable tasks, being the simplified
version of <a href="#cancelable[E,A](register:monix.bio.BiCallback[E,A]=&gt;cats.effect.CancelToken[[β$0$]monix.bio.IO[E,β$0$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable" id="monix.bio.IO#cancelable" class="extmbr">IO.cancelable</a>.
This can be used to translate from a callback-based API to pure
<code>Task</code> values that cannot be canceled.</p><p>See the the documentation for
<a href="https://typelevel.org/cats-effect/typeclasses/async.html" target="_blank">cats.effect.Async</a>.</p><p>For example, in case we wouldn't have <a href="#deferFuture[A](fa:=&gt;scala.concurrent.Future[A]):monix.bio.Task[A]" name="monix.bio.IO#deferFuture" id="monix.bio.IO#deferFuture" class="extmbr">IO.deferFuture</a>
already defined, we could do this:</p><pre><span class="kw">import</span> scala.concurrent.{Future, ExecutionContext}
<span class="kw">import</span> scala.util._

<span class="kw">def</span> deferFuture[A](f: <span class="kw">=&gt;</span> Future[A])(<span class="kw">implicit</span> ec: ExecutionContext): Task[A] =
  Task.async { cb <span class="kw">=&gt;</span>
    <span class="cmt">// N.B. we could do `f.onComplete(cb)` directly ;-)</span>
    f.onComplete {
      <span class="kw">case</span> Success(a) <span class="kw">=&gt;</span> cb.onSuccess(a)
      <span class="kw">case</span> Failure(e) <span class="kw">=&gt;</span> cb.onError(e)
    }
  }</pre><p>Note that this function needs an explicit <code>ExecutionContext</code> in order
to trigger <code>Future#complete</code>, however Monix's <code>Task</code> can inject
a <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> for you, thus allowing you
to get rid of these pesky execution contexts being passed around explicitly.
See <a href="#async0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async0" id="monix.bio.IO#async0" class="extmbr">IO.async0</a>.</p><p>CONTRACT for <code>register</code>:</p><ul><li>the provided function is executed when the <code>Task</code> will be evaluated
   (via <code>runAsync</code> or when its turn comes in the <code>flatMap</code> chain, not before)</li><li>the injected <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a> can be
   called at most once, either with a successful result, or with
   an error; calling it more than once is a contract violation</li><li>the injected callback is thread-safe and in case it gets called
   multiple times it will throw a
   <a href="https://monix.io/api/3.1/monix/execution/exceptions/CallbackCalledMultipleTimesException.html" name="monix.execution.exceptions.CallbackCalledMultipleTimesException" id="monix.execution.exceptions.CallbackCalledMultipleTimesException" class="extype">monix.execution.exceptions.CallbackCalledMultipleTimesException</a>;
   also see <a href="https://monix.io/api/3.1/monix/execution/Callback.html#tryOnSuccess(value:%3C?%3E):Boolean" name="monix.execution.Callback" id="monix.execution.Callback" class="extype">Callback.tryOnSuccess</a>
   and <a href="https://monix.io/api/3.1/monix/execution/Callback.html#tryOnError(e:%3C?%3E):Boolean" name="monix.execution.Callback" id="monix.execution.Callback" class="extype">Callback.tryOnError</a>
   and <a href="BiCallback.html#tryOnTermination(e:Throwable):Boolean" name="monix.bio.BiCallback#tryOnTermination" id="monix.bio.BiCallback#tryOnTermination" class="extmbr">monix.bio.BiCallback.tryOnTermination</a>
</li></ul></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#async0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async0" id="monix.bio.IO#async0" class="extmbr">IO.async0</a> for a variant that also injects a
     <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> into the provided callback,
     useful for forking, or delaying tasks or managing async boundaries</p></span><span class="cmt"><p><a href="#cancelable[E,A](register:monix.bio.BiCallback[E,A]=&gt;cats.effect.CancelToken[[β$0$]monix.bio.IO[E,β$0$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable" id="monix.bio.IO#cancelable" class="extmbr">IO.cancelable</a> and <a href="#cancelable0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;cats.effect.CancelToken[[β$1$]monix.bio.IO[E,β$1$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable0" id="monix.bio.IO#cancelable0" class="extmbr">IO.cancelable0</a>
     for creating cancelable tasks</p></span><span class="cmt"><p><a href="#create[E,A]:monix.bio.IO.AsyncBuilder.CreatePartiallyApplied[E,A]" name="monix.bio.IO#create" id="monix.bio.IO#create" class="extmbr">IO.create</a> for the builder that does it all</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#async0" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="async0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;Unit):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="async0[E,A]((Scheduler,BiCallback[E,A])=&gt;Unit):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#async0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;Unit):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">async0</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="register">register: (<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>, <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a>[<span name="monix.bio.IO.async0.E" class="extype">E</span>, <span name="monix.bio.IO.async0.A" class="extype">A</span>]) =&gt; <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.async0.E" class="extype">E</span>, <span name="monix.bio.IO.async0.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Create a non-cancelable <code>Task</code> from an asynchronous computation,
which takes the form of a function with which we can register a
callback to execute upon completion, a function that also injects a
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> for managing async boundaries.</p><div class="fullcomment"><div class="comment cmt"><p>Create a non-cancelable <code>Task</code> from an asynchronous computation,
which takes the form of a function with which we can register a
callback to execute upon completion, a function that also injects a
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> for managing async boundaries.</p><p>This operation is the implementation for <code>cats.effect.Async</code> and
is thus yielding non-cancelable tasks, being the simplified
version of <a href="#cancelable0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;cats.effect.CancelToken[[β$1$]monix.bio.IO[E,β$1$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable0" id="monix.bio.IO#cancelable0" class="extmbr">IO.cancelable0</a>. It can be used to translate from a
callback-based API to pure <code>Task</code> values that cannot be canceled.</p><p>See the the documentation for
<a href="https://typelevel.org/cats-effect/typeclasses/async.html" target="_blank">cats.effect.Async</a>.</p><p>For example, in case we wouldn't have <a href="#deferFuture[A](fa:=&gt;scala.concurrent.Future[A]):monix.bio.Task[A]" name="monix.bio.IO#deferFuture" id="monix.bio.IO#deferFuture" class="extmbr">IO.deferFuture</a>
already defined, we could do this:</p><pre><span class="kw">import</span> scala.concurrent.Future
<span class="kw">import</span> scala.util._

<span class="kw">def</span> deferFuture[A](f: <span class="kw">=&gt;</span> Future[A]): Task[A] =
  Task.async0 { (scheduler, cb) <span class="kw">=&gt;</span>
    <span class="cmt">// We are being given an ExecutionContext ;-)</span>
    <span class="kw">implicit</span> <span class="kw">val</span> ec = scheduler

    <span class="cmt">// N.B. we could do `f.onComplete(cb)` directly ;-)</span>
    f.onComplete {
      <span class="kw">case</span> Success(a) <span class="kw">=&gt;</span> cb.onSuccess(a)
      <span class="kw">case</span> Failure(e) <span class="kw">=&gt;</span> cb.onError(e)
    }
  }</pre><p>Note that this function doesn't need an implicit <code>ExecutionContext</code>.
Compared with usage of <a href="#async[E,A](register:monix.bio.BiCallback[E,A]=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async" id="monix.bio.IO#async" class="extmbr">IO.async</a>, this
function injects a <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> for us to
use for managing async boundaries.</p><p>CONTRACT for <code>register</code>:</p><ul><li>the provided function is executed when the <code>Task</code> will be evaluated
   (via <code>runAsync</code> or when its turn comes in the <code>flatMap</code> chain, not before)</li><li>the injected <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">monix.bio.BiCallback</a> can be called at
   most once, either with a successful result, or with an error;
   calling it more than once is a contract violation</li><li>the injected callback is thread-safe and in case it gets called
   multiple times it will throw a
   <a href="https://monix.io/api/3.1/monix/execution/exceptions/CallbackCalledMultipleTimesException.html" name="monix.execution.exceptions.CallbackCalledMultipleTimesException" id="monix.execution.exceptions.CallbackCalledMultipleTimesException" class="extype">monix.execution.exceptions.CallbackCalledMultipleTimesException</a>;
   also see <a href="https://monix.io/api/3.1/monix/execution/Callback.html#tryOnSuccess(value:%3C?%3E):Boolean" name="monix.execution.Callback" id="monix.execution.Callback" class="extype">Callback.tryOnSuccess</a>
   and <a href="https://monix.io/api/3.1/monix/execution/Callback.html#tryOnError(e:%3C?%3E):Boolean" name="monix.execution.Callback" id="monix.execution.Callback" class="extype">Callback.tryOnError</a>
   and <a href="BiCallback.html#tryOnTermination(e:Throwable):Boolean" name="monix.bio.BiCallback#tryOnTermination" id="monix.bio.BiCallback#tryOnTermination" class="extmbr">BiCallback.tryOnTermination</a></li></ul><p>NOTES on the naming:</p><ul><li><code>async</code> comes from <code>cats.effect.Async#async</code></li><li>the <code>0</code> suffix is about overloading the simpler
   <a href="#async[E,A](register:monix.bio.BiCallback[E,A]=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async" id="monix.bio.IO#async" class="extmbr">IO.async</a> builder
</li></ul></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#async[E,A](register:monix.bio.BiCallback[E,A]=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async" id="monix.bio.IO#async" class="extmbr">IO.async</a> for a simpler variant that doesn't inject a
     <code>Scheduler</code>, in case you don't need one</p></span><span class="cmt"><p><a href="#cancelable[E,A](register:monix.bio.BiCallback[E,A]=&gt;cats.effect.CancelToken[[β$0$]monix.bio.IO[E,β$0$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable" id="monix.bio.IO#cancelable" class="extmbr">IO.cancelable</a> and <a href="#cancelable0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;cats.effect.CancelToken[[β$1$]monix.bio.IO[E,β$1$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable0" id="monix.bio.IO#cancelable0" class="extmbr">IO.cancelable0</a>
     for creating cancelable tasks</p></span><span class="cmt"><p><a href="#create[E,A]:monix.bio.IO.AsyncBuilder.CreatePartiallyApplied[E,A]" name="monix.bio.IO#create" id="monix.bio.IO#create" class="extmbr">IO.create</a> for the builder that does it all</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#asyncF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asyncF[E,A](register:monix.bio.BiCallback[E,A]=&gt;monix.bio.IO[E,Unit]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="asyncF[E,A]((BiCallback[E,A])=&gt;IO[E,Unit]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#asyncF[E,A](register:monix.bio.BiCallback[E,A]=&gt;monix.bio.IO[E,Unit]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asyncF</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="register">register: (<a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a>[<span name="monix.bio.IO.asyncF.E" class="extype">E</span>, <span name="monix.bio.IO.asyncF.A" class="extype">A</span>]) =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.asyncF.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.asyncF.E" class="extype">E</span>, <span name="monix.bio.IO.asyncF.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Suspends an asynchronous side effect in <code>IO</code>, this being a
variant of <a href="#async[E,A](register:monix.bio.BiCallback[E,A]=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async" id="monix.bio.IO#async" class="extmbr">async</a> that takes a pure registration function.</p><div class="fullcomment"><div class="comment cmt"><p>Suspends an asynchronous side effect in <code>IO</code>, this being a
variant of <a href="#async[E,A](register:monix.bio.BiCallback[E,A]=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async" id="monix.bio.IO#async" class="extmbr">async</a> that takes a pure registration function.</p><p>Implements <code>cats.effect.Async.asyncF</code>.</p><p>The difference versus <a href="#async[E,A](register:monix.bio.BiCallback[E,A]=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async" id="monix.bio.IO#async" class="extmbr">async</a> is that this variant can suspend
side-effects via the provided function parameter. It's more relevant
in polymorphic code making use of the <code>cats.effect.Async</code>
type class, as it alleviates the need for <code>cats.effect.Effect</code>.</p><p>Contract for the returned <code>IO[E, Unit]</code> in the provided function:</p><ul><li>can be asynchronous</li><li>can be cancelable, in which case it hooks into IO's cancelation
   mechanism such that the resulting task is cancelable</li><li>it should not end in error, because the provided callback
   is the only way to signal the final result and it can only
   be called once, so invoking it twice would be a contract
   violation; so on errors thrown in <code>IO</code>, the task can become
   non-terminating, with the error being printed via
   <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#reportFailure(t:Throwable):Unit" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler.reportFailure</a>
</li></ul></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#async[E,A](register:monix.bio.BiCallback[E,A]=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async" id="monix.bio.IO#async" class="extmbr">IO.async</a> and <a href="#async0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async0" id="monix.bio.IO#async0" class="extmbr">IO.async0</a> for a simpler variants</p></span><span class="cmt"><p><a href="#cancelable[E,A](register:monix.bio.BiCallback[E,A]=&gt;cats.effect.CancelToken[[β$0$]monix.bio.IO[E,β$0$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable" id="monix.bio.IO#cancelable" class="extmbr">Task.cancelable</a> and
     <a href="#cancelable0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;cats.effect.CancelToken[[β$1$]monix.bio.IO[E,β$1$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable0" id="monix.bio.IO#cancelable0" class="extmbr">IO.cancelable0</a> for creating cancelable tasks</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#cancelBoundary" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="cancelBoundary:monix.bio.UIO[Unit]" class="anchorToMember"></a><a id="cancelBoundary:UIO[Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#cancelBoundary:monix.bio.UIO[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">cancelBoundary</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Returns a cancelable boundary — a <code>Task</code> that checks for the
cancellation status of the run-loop and does not allow for the
bind continuation to keep executing in case cancellation happened.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a cancelable boundary — a <code>Task</code> that checks for the
cancellation status of the run-loop and does not allow for the
bind continuation to keep executing in case cancellation happened.</p><p>This operation is very similar to <code>Task.shift</code>, as it can be dropped
in <code>flatMap</code> chains in order to make loops cancelable.</p><p>Example:</p><pre><span class="kw">import</span> cats.syntax.all._

<span class="kw">def</span> fib(n: <span class="std">Int</span>, a: <span class="std">Long</span>, b: <span class="std">Long</span>): Task[<span class="std">Long</span>] =
  Task.suspend {
    <span class="kw">if</span> (n &lt;= <span class="num">0</span>) Task.pure(a) <span class="kw">else</span> {
      <span class="kw">val</span> next = fib(n - <span class="num">1</span>, b, a + b)

      <span class="cmt">// Every 100-th cycle, check cancellation status</span>
      <span class="kw">if</span> (n % <span class="num">100</span> == <span class="num">0</span>)
        Task.cancelBoundary *&gt; next
      <span class="kw">else</span>
        next
    }
  }</pre><p>NOTE: that by default <code>Task</code> is configured to be auto-cancelable
(see <a href="IO$$Options.html" name="monix.bio.IO.Options" id="monix.bio.IO.Options" class="extype">IO.Options</a>), so this isn't strictly needed, unless you
want to fine tune the cancelation boundaries.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#cancelable" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="cancelable[E,A](register:monix.bio.BiCallback[E,A]=&gt;cats.effect.CancelToken[[β$0$]monix.bio.IO[E,β$0$]]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="cancelable[E,A]((BiCallback[E,A])=&gt;CancelToken[[β$0$]IO[E,β$0$]]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#cancelable[E,A](register:monix.bio.BiCallback[E,A]=&gt;cats.effect.CancelToken[[β$0$]monix.bio.IO[E,β$0$]]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">cancelable</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="register">register: (<a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a>[<span name="monix.bio.IO.cancelable.E" class="extype">E</span>, <span name="monix.bio.IO.cancelable.A" class="extype">A</span>]) =&gt; <span name="cats.effect.CancelToken" class="extype">CancelToken</span>[[β$0$]<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.cancelable.E" class="extype">E</span>, <span name="monix.bio.IO.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.β$0$" class="extype">β$0$</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.cancelable.E" class="extype">E</span>, <span name="monix.bio.IO.cancelable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Create a cancelable <code>Task</code> from an asynchronous computation that
can be canceled, taking the form of a function with which we can
register a callback to execute upon completion.</p><div class="fullcomment"><div class="comment cmt"><p>Create a cancelable <code>Task</code> from an asynchronous computation that
can be canceled, taking the form of a function with which we can
register a callback to execute upon completion.</p><p>This operation is the implementation for
<code>cats.effect.Concurrent#cancelable</code> and is thus yielding
cancelable tasks. It can be used to translate from a callback-based
API to pure <code>Task</code> values that can be canceled.</p><p>See the the documentation for
<a href="https://typelevel.org/cats-effect/typeclasses/concurrent.html" target="_blank">cats.effect.Concurrent</a>.</p><p>For example, in case we wouldn't have <a href="IO.html#delayExecution(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.IO[E,A]" name="monix.bio.IO#delayExecution" id="monix.bio.IO#delayExecution" class="extmbr">IO.delayExecution</a>
already defined and we wanted to delay evaluation using a Java
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank">ScheduledExecutorService</a>
(no need for that because we've got <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>,
but lets say for didactic purposes):</p><pre><span class="kw">import</span> java.util.concurrent.ScheduledExecutorService
<span class="kw">import</span> scala.concurrent.ExecutionContext
<span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> scala.util.control.NonFatal

<span class="kw">def</span> delayed[A](sc: ScheduledExecutorService, timespan: FiniteDuration)
  (thunk: <span class="kw">=&gt;</span> A)
  (<span class="kw">implicit</span> ec: ExecutionContext): Task[A] = {

  Task.cancelable { cb <span class="kw">=&gt;</span>
    <span class="kw">val</span> future = sc.schedule(<span class="kw">new</span> Runnable { <span class="cmt">// scheduling delay</span>
      <span class="kw">def</span> run() = ec.execute(<span class="kw">new</span> Runnable { <span class="cmt">// scheduling thunk execution</span>
        <span class="kw">def</span> run() =
          <span class="kw">try</span>
            cb.onSuccess(thunk)
          <span class="kw">catch</span> { <span class="kw">case</span> NonFatal(e) <span class="kw">=&gt;</span>
            cb.onError(e)
          }
        })
      },
      timespan.length,
      timespan.unit)

    <span class="cmt">// Returning the cancelation token that is able to cancel the</span>
    <span class="cmt">// scheduling in case the active computation hasn't finished yet</span>
    Task { future.cancel(<span class="kw">false</span>); () }
  }
}</pre><p>Note in this sample we are passing an implicit <code>ExecutionContext</code>
in order to do the actual processing, the <code>ScheduledExecutorService</code>
being in charge just of scheduling. We don't need to do that, as <code>Task</code>
affords to have a <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> injected
instead via <a href="#cancelable0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;cats.effect.CancelToken[[β$1$]monix.bio.IO[E,β$1$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable0" id="monix.bio.IO#cancelable0" class="extmbr">IO.cancelable0</a>.</p><p>CONTRACT for <code>register</code>:</p><ul><li>the provided function is executed when the <code>Task</code> will be evaluated
   (via <code>runAsync</code> or when its turn comes in the <code>flatMap</code> chain, not before)</li><li>the injected <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a> can be
   called at most once, either with a successful result, or with
   an typed; calling it more than once is a contract violation</li><li>the injected callback is thread-safe and in case it gets called
   multiple times it will throw a
   <a href="https://monix.io/api/3.1/monix/execution/exceptions/CallbackCalledMultipleTimesException.html" name="monix.execution.exceptions.CallbackCalledMultipleTimesException" id="monix.execution.exceptions.CallbackCalledMultipleTimesException" class="extype">monix.execution.exceptions.CallbackCalledMultipleTimesException</a>;
   also see <a href="https://monix.io/api/3.1/monix/execution/Callback.html#tryOnSuccess(value:%3C?%3E):Boolean" name="monix.execution.Callback" id="monix.execution.Callback" class="extype">Callback.tryOnSuccess</a>
   and <a href="https://monix.io/api/3.1/monix/execution/Callback.html#tryOnError(e:%3C?%3E):Boolean" name="monix.execution.Callback" id="monix.execution.Callback" class="extype">Callback.tryOnError</a>
   and <a href="BiCallback.html#tryOnTermination(e:Throwable):Boolean" name="monix.bio.BiCallback#tryOnTermination" id="monix.bio.BiCallback#tryOnTermination" class="extmbr">BiCallback.tryOnTermination</a>
</li></ul></div><dl class="paramcmts block"><dt class="param">register</dt><dd class="cmt"><p>is a function that will be called when
        this <code>Task</code> is executed, receiving a callback as a
        parameter, a callback that the user is supposed to call in
        order to signal the desired outcome of this <code>Task</code>. This
        function also receives a <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>
        that can be used for managing asynchronous boundaries, a
        scheduler being nothing more than an evolved <code>ExecutionContext</code>.</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#cancelable0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;cats.effect.CancelToken[[β$1$]monix.bio.IO[E,β$1$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable0" id="monix.bio.IO#cancelable0" class="extmbr">IO.cancelable0</a> for the version that also injects a
     <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> in that callback</p></span><span class="cmt"><p><a href="#async0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async0" id="monix.bio.IO#async0" class="extmbr">IO.async0</a> and <a href="#async[E,A](register:monix.bio.BiCallback[E,A]=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async" id="monix.bio.IO#async" class="extmbr">Task.async</a> for the
     simpler versions of this builder that create non-cancelable tasks
     from callback-based APIs</p></span><span class="cmt"><p><a href="#create[E,A]:monix.bio.IO.AsyncBuilder.CreatePartiallyApplied[E,A]" name="monix.bio.IO#create" id="monix.bio.IO#create" class="extmbr">IO.create</a> for the builder that does it all</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#cancelable0" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="cancelable0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;cats.effect.CancelToken[[β$1$]monix.bio.IO[E,β$1$]]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="cancelable0[E,A]((Scheduler,BiCallback[E,A])=&gt;CancelToken[[β$1$]IO[E,β$1$]]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#cancelable0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;cats.effect.CancelToken[[β$1$]monix.bio.IO[E,β$1$]]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">cancelable0</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="register">register: (<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>, <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a>[<span name="monix.bio.IO.cancelable0.E" class="extype">E</span>, <span name="monix.bio.IO.cancelable0.A" class="extype">A</span>]) =&gt; <span name="cats.effect.CancelToken" class="extype">CancelToken</span>[[β$1$]<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.cancelable0.E" class="extype">E</span>, <span name="monix.bio.IO.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.β$1$" class="extype">β$1$</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.cancelable0.E" class="extype">E</span>, <span name="monix.bio.IO.cancelable0.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Create a cancelable <code>Task</code> from an asynchronous computation,
which takes the form of a function with which we can register a
callback to execute upon completion, a function that also injects a
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> for managing async boundaries.</p><div class="fullcomment"><div class="comment cmt"><p>Create a cancelable <code>Task</code> from an asynchronous computation,
which takes the form of a function with which we can register a
callback to execute upon completion, a function that also injects a
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> for managing async boundaries.</p><p>This operation is the implementation for
<code>cats.effect.Concurrent#cancelable</code> and is thus yielding
cancelable tasks. It can be used to translate from a callback-based API
to pure <code>Task</code> values that can be canceled.</p><p>See the the documentation for
<a href="https://typelevel.org/cats-effect/typeclasses/concurrent.html" target="_blank">cats.effect.Concurrent</a>.</p><p>For example, in case we wouldn't have <a href="IO.html#delayExecution(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.IO[E,A]" name="monix.bio.IO#delayExecution" id="monix.bio.IO#delayExecution" class="extmbr">IO.delayExecution</a>
already defined and we wanted to delay evaluation using a Java
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank">ScheduledExecutorService</a>
(no need for that because we've got <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>,
but lets say for didactic purposes):</p><pre><span class="kw">import</span> java.util.concurrent.ScheduledExecutorService
<span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> scala.util.control.NonFatal

<span class="kw">def</span> delayed1[A](sc: ScheduledExecutorService, timespan: FiniteDuration)
  (thunk: <span class="kw">=&gt;</span> A): Task[A] = {

  Task.cancelable0 { (scheduler, cb) <span class="kw">=&gt;</span>
    <span class="kw">val</span> future = sc.schedule(<span class="kw">new</span> Runnable { <span class="cmt">// scheduling delay</span>
      <span class="kw">def</span> run = scheduler.execute(<span class="kw">new</span> Runnable { <span class="cmt">// scheduling thunk execution</span>
        <span class="kw">def</span> run() =
          <span class="kw">try</span>
            cb.onSuccess(thunk)
          <span class="kw">catch</span> { <span class="kw">case</span> NonFatal(e) <span class="kw">=&gt;</span>
            cb.onError(e)
          }
        })
      },
      timespan.length,
      timespan.unit)

    <span class="cmt">// Returning the cancel token that is able to cancel the</span>
    <span class="cmt">// scheduling in case the active computation hasn't finished yet</span>
    Task { future.cancel(<span class="kw">false</span>); () }
  }
}</pre><p>As can be seen, the passed function needs to pass a
<a href="https://monix.io/api/3.1/monix/execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a> in order to specify cancelation
logic.</p><p>This is a sample given for didactic purposes. Our <code>cancelable0</code> is
being injected a <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> and it is
perfectly capable of doing such delayed execution without help from
Java's standard library:</p><pre><span class="kw">def</span> delayed2[A](timespan: FiniteDuration)(thunk: <span class="kw">=&gt;</span> A): Task[A] =
  Task.cancelable0 { (scheduler, cb) <span class="kw">=&gt;</span>
    <span class="cmt">// N.B. this already returns the Cancelable that we need!</span>
    <span class="kw">val</span> cancelable = scheduler.scheduleOnce(timespan) {
      <span class="kw">try</span> cb.onSuccess(thunk)
      <span class="kw">catch</span> { <span class="kw">case</span> NonFatal(e) <span class="kw">=&gt;</span> cb.onError(e) }
    }
    <span class="cmt">// `scheduleOnce` above returns a Cancelable, which</span>
    <span class="cmt">// has to be converted into a Task[Unit]</span>
    Task(cancelable.cancel())
  }</pre><p>CONTRACT for <code>register</code>:</p><ul><li>the provided function is executed when the <code>Task</code> will be evaluated
   (via <code>runAsync</code> or when its turn comes in the <code>flatMap</code> chain, not before)</li><li>the injected <a href="BiCallback.html" name="monix.bio.BiCallback" id="monix.bio.BiCallback" class="extype">BiCallback</a> can be
   called at most once, either with a successful result, or with
   an error; calling it more than once is a contract violation</li><li>the injected callback is thread-safe and in case it gets called
   multiple times it will throw a
   <a href="https://monix.io/api/3.1/monix/execution/exceptions/CallbackCalledMultipleTimesException.html" name="monix.execution.exceptions.CallbackCalledMultipleTimesException" id="monix.execution.exceptions.CallbackCalledMultipleTimesException" class="extype">monix.execution.exceptions.CallbackCalledMultipleTimesException</a>;
   also see <a href="https://monix.io/api/3.1/monix/execution/Callback.html#tryOnSuccess(value:%3C?%3E):Boolean" name="monix.execution.Callback" id="monix.execution.Callback" class="extype">Callback.tryOnSuccess</a>
   and <a href="https://monix.io/api/3.1/monix/execution/Callback.html#tryOnError(e:%3C?%3E):Boolean" name="monix.execution.Callback" id="monix.execution.Callback" class="extype">Callback.tryOnError</a>
   and <a href="BiCallback.html#tryOnTermination(e:Throwable):Boolean" name="monix.bio.BiCallback#tryOnTermination" id="monix.bio.BiCallback#tryOnTermination" class="extmbr">BiCallback.tryOnTermination</a></li></ul><p>NOTES on the naming:</p><ul><li><code>cancelable</code> comes from <code>cats.effect.Concurrent#cancelable</code></li><li>the <code>0</code> suffix is about overloading the simpler
   <a href="#cancelable[E,A](register:monix.bio.BiCallback[E,A]=&gt;cats.effect.CancelToken[[β$0$]monix.bio.IO[E,β$0$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable" id="monix.bio.IO#cancelable" class="extmbr">IO.cancelable</a> builder
</li></ul></div><dl class="paramcmts block"><dt class="param">register</dt><dd class="cmt"><p>is a function that will be called when
        this <code>Task</code> is executed, receiving a callback as a
        parameter, a callback that the user is supposed to call in
        order to signal the desired outcome of this <code>Task</code>. This
        function also receives a <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>
        that can be used for managing asynchronous boundaries, a
        scheduler being nothing more than an evolved <code>ExecutionContext</code>.</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#cancelable[E,A](register:monix.bio.BiCallback[E,A]=&gt;cats.effect.CancelToken[[β$0$]monix.bio.IO[E,β$0$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable" id="monix.bio.IO#cancelable" class="extmbr">Task.cancelable</a> for the simpler
     variant that doesn't inject the <code>Scheduler</code> in that callback</p></span><span class="cmt"><p><a href="#async0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async0" id="monix.bio.IO#async0" class="extmbr">IO.async0</a> and <a href="#async[E,A](register:monix.bio.BiCallback[E,A]=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async" id="monix.bio.IO#async" class="extmbr">IO.async</a> for the
     simpler versions of this builder that create non-cancelable tasks
     from callback-based APIs</p></span><span class="cmt"><p><a href="#create[E,A]:monix.bio.IO.AsyncBuilder.CreatePartiallyApplied[E,A]" name="monix.bio.IO#create" id="monix.bio.IO#create" class="extmbr">IO.create</a> for the builder that does it all</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.TaskInstancesLevel0#catsAsync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="catsAsync:monix.bio.instances.CatsConcurrentForTask" class="anchorToMember"></a><a id="catsAsync:CatsConcurrentForTask" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#catsAsync:monix.bio.instances.CatsConcurrentForTask" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">catsAsync</span><span class="result">: <a href="instances/CatsConcurrentForTask.html" name="monix.bio.instances.CatsConcurrentForTask" id="monix.bio.instances.CatsConcurrentForTask" class="extype">CatsConcurrentForTask</a></span></span><p class="shortcomment cmt">Global instance for <code>cats.effect.Async</code> and for <code>cats.effect.Concurrent</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Global instance for <code>cats.effect.Async</code> and for <code>cats.effect.Concurrent</code>.</p><p>Implied are also <code>cats.CoflatMap</code>, <code>cats.Applicative</code>, <code>cats.Monad</code>,
<code>cats.MonadError</code> and <code>cats.effect.Sync</code>.</p><p>As trivia, it's named "catsAsync" and not "catsConcurrent" because
it represents the <code>cats.effect.Async</code> lineage, up until
<code>cats.effect.Effect</code>, which imposes extra restrictions, in our case
the need for a <code>Scheduler</code> to be in scope (see <a href="#catsEffect(implicits:monix.execution.Scheduler,implicitopts:monix.bio.IO.Options):monix.bio.instances.CatsConcurrentEffectForTask" name="monix.bio.IO#catsEffect" id="monix.bio.IO#catsEffect" class="extmbr">IO.catsEffect</a>).
So by naming the lineage, not the concrete sub-type implemented, we avoid
breaking compatibility whenever a new type class (that we can implement)
gets added into Cats.</p><p>Seek more info about Cats, the standard library for FP, at:</p><ul><li><a href="https://typelevel.org/cats/" target="_blank">typelevel/cats</a></li><li><a href="https://github.com/typelevel/cats-effect" target="_blank">typelevel/cats-effect</a>
</li></ul></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskInstancesLevel0</dd></dl></div></li><li class="indented0 " name="monix.bio.TaskInstancesLevel1#catsEffect" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="catsEffect(implicits:monix.execution.Scheduler,implicitopts:monix.bio.IO.Options):monix.bio.instances.CatsConcurrentEffectForTask" class="anchorToMember"></a><a id="catsEffect(Scheduler,Options):CatsConcurrentEffectForTask" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#catsEffect(implicits:monix.execution.Scheduler,implicitopts:monix.bio.IO.Options):monix.bio.instances.CatsConcurrentEffectForTask" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">catsEffect</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="opts">opts: <a href="IO$$Options.html" name="monix.bio.IO.Options" id="monix.bio.IO.Options" class="extype">Options</a> = <span class="symbol"><span class="name"><a href="">IO.defaultOptions</a></span></span></span>)</span><span class="result">: <a href="instances/CatsConcurrentEffectForTask.html" name="monix.bio.instances.CatsConcurrentEffectForTask" id="monix.bio.instances.CatsConcurrentEffectForTask" class="extype">CatsConcurrentEffectForTask</a></span></span><p class="shortcomment cmt">Global instance for <code>cats.effect.Effect</code> and for
<code>cats.effect.ConcurrentEffect</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Global instance for <code>cats.effect.Effect</code> and for
<code>cats.effect.ConcurrentEffect</code>.</p><p>Implied are <code>cats.CoflatMap</code>, <code>cats.Applicative</code>, <code>cats.Monad</code>,
<code>cats.MonadError</code>, <code>cats.effect.Sync</code> and <code>cats.effect.Async</code>.</p><p>Note this is different from
<a href="#catsAsync:monix.bio.instances.CatsConcurrentForTask" name="monix.bio.IO#catsAsync" id="monix.bio.IO#catsAsync" class="extmbr">IO.catsAsync</a> because we need an
implicit <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> in scope in
order to trigger the execution of a <code>Task</code>. It's also lower
priority in order to not trigger conflicts, because
<code>Effect &lt;: Async</code> and <code>ConcurrentEffect &lt;: Concurrent with Effect</code>.</p><p>As trivia, it's named "catsEffect" and not "catsConcurrentEffect"
because it represents the <code>cats.effect.Effect</code> lineage, as in the
minimum that this value will support in the future. So by naming the
lineage, not the concrete sub-type implemented, we avoid breaking
compatibility whenever a new type class (that we can implement)
gets added into Cats.</p><p>Seek more info about Cats, the standard library for FP, at:</p><ul><li><a href="https://typelevel.org/cats/" target="_blank">typelevel/cats</a></li><li><a href="https://github.com/typelevel/cats-effect" target="_blank">typelevel/cats-effect</a>
</li></ul></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is a <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> that needs
       to be available in scope</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskInstancesLevel1</dd></dl></div></li><li class="indented0 " name="monix.bio.TaskInstancesLevel0#catsMonoid" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="catsMonoid[E,A](implicitA:cats.Monoid[A]):cats.Monoid[monix.bio.IO[E,A]]" class="anchorToMember"></a><a id="catsMonoid[E,A](Monoid[A]):Monoid[IO[E,A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#catsMonoid[E,A](implicitA:cats.Monoid[A]):cats.Monoid[monix.bio.IO[E,A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">catsMonoid</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="A">A: <span name="cats.Monoid" class="extype">Monoid</span>[<span name="monix.bio.TaskInstancesLevel0.catsMonoid.A" class="extype">A</span>]</span>)</span><span class="result">: <span name="cats.Monoid" class="extype">Monoid</span>[<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.TaskInstancesLevel0.catsMonoid.E" class="extype">E</span>, <span name="monix.bio.TaskInstancesLevel0.catsMonoid.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Given an <code>A</code> type that has a <code>cats.Monoid[A]</code> implementation,
then this provides the evidence that <code>IO[E, A]</code> also has
a <code>Monoid[ IO[E, A] ]</code> implementation.</p><div class="fullcomment"><div class="comment cmt"><p>Given an <code>A</code> type that has a <code>cats.Monoid[A]</code> implementation,
then this provides the evidence that <code>IO[E, A]</code> also has
a <code>Monoid[ IO[E, A] ]</code> implementation.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskInstancesLevel0</dd></dl></div></li><li class="indented0 " name="monix.bio.TaskInstancesLevel0#catsParallel" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="catsParallel[E]:cats.Parallel.Aux[[β$3$]monix.bio.IO[E,β$3$],[β$4$]monix.bio.IO.Par.Type[E,β$4$]]" class="anchorToMember"></a><a id="catsParallel[E]:Aux[[β$3$]IO[E,β$3$],[β$4$]TaskParallelNewtype.Par.Type[E,β$4$]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#catsParallel[E]:cats.Parallel.Aux[[β$3$]monix.bio.IO[E,β$3$],[β$4$]monix.bio.IO.Par.Type[E,β$4$]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">catsParallel</span><span class="tparams">[<span name="E">E</span>]</span><span class="result">: <span name="cats.Parallel.Aux" class="extype">Aux</span>[[β$3$]<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.TaskInstancesLevel0.catsParallel.E" class="extype">E</span>, <span name="monix.bio.TaskInstancesLevel0.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.β$3$" class="extype">β$3$</span>], [β$4$]<span name="monix.bio.instances.Newtype2.Type" class="extype">TaskParallelNewtype.Par.Type</span>[<span name="monix.bio.TaskInstancesLevel0.catsParallel.E" class="extype">E</span>, <span name="monix.bio.TaskInstancesLevel0.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.β$4$" class="extype">β$4$</span>]]</span></span><p class="shortcomment cmt">Global instance for <code>cats.Parallel</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Global instance for <code>cats.Parallel</code>.</p><p>The <code>Parallel</code> type class is useful for processing
things in parallel in a generic way, usable with
Cats' utils and syntax:</p><pre><span class="kw">import</span> cats.syntax.all._
<span class="kw">import</span> scala.concurrent.duration._

<span class="kw">val</span> taskA = Task.sleep(<span class="num">1.</span>seconds).map(_ <span class="kw">=&gt;</span> <span class="lit">"a"</span>)
<span class="kw">val</span> taskB = Task.sleep(<span class="num">2.</span>seconds).map(_ <span class="kw">=&gt;</span> <span class="lit">"b"</span>)
<span class="kw">val</span> taskC = Task.sleep(<span class="num">3.</span>seconds).map(_ <span class="kw">=&gt;</span> <span class="lit">"c"</span>)

<span class="cmt">// Returns "abc" after 3 seconds</span>
(taskA, taskB, taskC).parMapN { (a, b, c) <span class="kw">=&gt;</span>
  a + b + c
}</pre><p>Seek more info about Cats, the standard library for FP, at:</p><ul><li><a href="https://typelevel.org/cats/" target="_blank">typelevel/cats</a></li><li><a href="https://github.com/typelevel/cats-effect" target="_blank">typelevel/cats-effect</a>
</li></ul></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskInstancesLevel0</dd></dl></div></li><li class="indented0 " name="monix.bio.TaskInstancesLevel1#catsSemigroup" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="catsSemigroup[E,A](implicitA:cats.Semigroup[A]):cats.Semigroup[monix.bio.IO[E,A]]" class="anchorToMember"></a><a id="catsSemigroup[E,A](Semigroup[A]):Semigroup[IO[E,A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#catsSemigroup[E,A](implicitA:cats.Semigroup[A]):cats.Semigroup[monix.bio.IO[E,A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">catsSemigroup</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="A">A: <span name="cats.Semigroup" class="extype">Semigroup</span>[<span name="monix.bio.TaskInstancesLevel1.catsSemigroup.A" class="extype">A</span>]</span>)</span><span class="result">: <span name="cats.Semigroup" class="extype">Semigroup</span>[<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.TaskInstancesLevel1.catsSemigroup.E" class="extype">E</span>, <span name="monix.bio.TaskInstancesLevel1.catsSemigroup.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Given an <code>A</code> type that has a <code>cats.Semigroup[A]</code> implementation,
then this provides the evidence that <code>IO[E, A]</code> also has
a <code>Semigroup[ IO[E, A] ]</code> implementation.</p><div class="fullcomment"><div class="comment cmt"><p>Given an <code>A</code> type that has a <code>cats.Semigroup[A]</code> implementation,
then this provides the evidence that <code>IO[E, A]</code> also has
a <code>Semigroup[ IO[E, A] ]</code> implementation.</p><p>This has a lower-level priority than <a href="#catsMonoid[E,A](implicitA:cats.Monoid[A]):cats.Monoid[monix.bio.IO[E,A]]" name="monix.bio.IO#catsMonoid" id="monix.bio.IO#catsMonoid" class="extmbr">IO.catsMonoid</a>
in order to avoid conflicts.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskInstancesLevel1</dd></dl></div></li><li class="indented0 " name="monix.bio.TaskClocks#clock" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clock[E](s:monix.execution.Scheduler):cats.effect.Clock[[β$30$]monix.bio.IO[E,β$30$]]" class="anchorToMember"></a><a id="clock[E](Scheduler):Clock[[β$30$]IO[E,β$30$]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#clock[E](s:monix.execution.Scheduler):cats.effect.Clock[[β$30$]monix.bio.IO[E,β$30$]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clock</span><span class="tparams">[<span name="E">E</span>]</span><span class="params">(<span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="https://typelevel.org/cats-effect/api/cats/effect/Clock.html#cats.effect.Clock" name="cats.effect.Clock" id="cats.effect.Clock" class="extype">Clock</a>[[β$30$]<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.TaskClocks.clock.E" class="extype">E</span>, <span name="monix.bio.TaskClocks.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.β$30$" class="extype">β$30$</span>]]</span></span><p class="shortcomment cmt">Builds a <code>cats.effect.Clock</code> instance, given a
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> reference.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a <code>cats.effect.Clock</code> instance, given a
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> reference.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskClocks</dd></dl></div></li><li class="indented0 " name="monix.bio.TaskClocks#clock" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clock[E]:cats.effect.Clock[[β$26$]monix.bio.IO[E,β$26$]]" class="anchorToMember"></a><a id="clock[E]:Clock[[β$26$]IO[E,β$26$]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#clock[E]:cats.effect.Clock[[β$26$]monix.bio.IO[E,β$26$]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clock</span><span class="tparams">[<span name="E">E</span>]</span><span class="result">: <a href="https://typelevel.org/cats-effect/api/cats/effect/Clock.html#cats.effect.Clock" name="cats.effect.Clock" id="cats.effect.Clock" class="extype">Clock</a>[[β$26$]<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.TaskClocks.clock.E" class="extype">E</span>, <span name="monix.bio.TaskClocks.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.β$26$" class="extype">β$26$</span>]]</span></span><p class="shortcomment cmt">Default, pure, globally visible <code>cats.effect.Clock</code>
implementation that defers the evaluation to <code>Task</code>'s default
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>
(that's being injected in <a href="IO.html#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.IO#runToFuture" id="monix.bio.IO#runToFuture" class="extmbr">IO.runToFuture</a>).</p><div class="fullcomment"><div class="comment cmt"><p>Default, pure, globally visible <code>cats.effect.Clock</code>
implementation that defers the evaluation to <code>Task</code>'s default
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>
(that's being injected in <a href="IO.html#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.IO#runToFuture" id="monix.bio.IO#runToFuture" class="extmbr">IO.runToFuture</a>).
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskClocks</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object" class="anchorToMember"></a><a id="clone():AnyRef" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.TaskInstancesLevel0#commutativeApplicative" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="commutativeApplicative[E]:cats.CommutativeApplicative[[β$7$]monix.bio.IO.Par.Type[E,β$7$]]" class="anchorToMember"></a><a id="commutativeApplicative[E]:CommutativeApplicative[[β$7$]TaskParallelNewtype.Par.Type[E,β$7$]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#commutativeApplicative[E]:cats.CommutativeApplicative[[β$7$]monix.bio.IO.Par.Type[E,β$7$]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">commutativeApplicative</span><span class="tparams">[<span name="E">E</span>]</span><span class="result">: <a href="http://typelevel.org/cats/api/cats/CommutativeApplicative.html#cats.CommutativeApplicative" name="cats.CommutativeApplicative" id="cats.CommutativeApplicative" class="extype">CommutativeApplicative</a>[[β$7$]<span name="monix.bio.instances.Newtype2.Type" class="extype">TaskParallelNewtype.Par.Type</span>[<span name="monix.bio.TaskInstancesLevel0.commutativeApplicative.E" class="extype">E</span>, <span name="monix.bio.TaskInstancesLevel0.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.β$7$" class="extype">β$7$</span>]]</span></span><p class="shortcomment cmt">Global instance for <code>cats.CommutativeApplicative</code>
</p><div class="fullcomment"><div class="comment cmt"><p>Global instance for <code>cats.CommutativeApplicative</code>
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskInstancesLevel0</dd></dl></div></li><li class="indented0 " name="monix.bio.TaskContextShift#contextShift" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="contextShift[E](s:monix.execution.Scheduler):cats.effect.ContextShift[[β$16$]monix.bio.IO[E,β$16$]]" class="anchorToMember"></a><a id="contextShift[E](Scheduler):ContextShift[[β$16$]IO[E,β$16$]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#contextShift[E](s:monix.execution.Scheduler):cats.effect.ContextShift[[β$16$]monix.bio.IO[E,β$16$]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">contextShift</span><span class="tparams">[<span name="E">E</span>]</span><span class="params">(<span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="https://typelevel.org/cats-effect/api/cats/effect/ContextShift.html#cats.effect.ContextShift" name="cats.effect.ContextShift" id="cats.effect.ContextShift" class="extype">ContextShift</a>[[β$16$]<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.TaskContextShift.contextShift.E" class="extype">E</span>, <span name="monix.bio.TaskContextShift.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.β$16$" class="extype">β$16$</span>]]</span></span><p class="shortcomment cmt">Builds a <code>cats.effect.ContextShift</code> instance, given a
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> reference.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a <code>cats.effect.ContextShift</code> instance, given a
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> reference.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskContextShift</dd></dl></div></li><li class="indented0 " name="monix.bio.TaskContextShift#contextShift" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="contextShift[E]:cats.effect.ContextShift[[β$12$]monix.bio.IO[E,β$12$]]" class="anchorToMember"></a><a id="contextShift[E]:ContextShift[[β$12$]IO[E,β$12$]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#contextShift[E]:cats.effect.ContextShift[[β$12$]monix.bio.IO[E,β$12$]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">contextShift</span><span class="tparams">[<span name="E">E</span>]</span><span class="result">: <a href="https://typelevel.org/cats-effect/api/cats/effect/ContextShift.html#cats.effect.ContextShift" name="cats.effect.ContextShift" id="cats.effect.ContextShift" class="extype">ContextShift</a>[[β$12$]<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.TaskContextShift.contextShift.E" class="extype">E</span>, <span name="monix.bio.TaskContextShift.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.β$12$" class="extype">β$12$</span>]]</span></span><p class="shortcomment cmt">Default, pure, globally visible <code>cats.effect.ContextShift</code>
implementation that shifts the evaluation to <code>Task</code>'s default
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>
(that's being injected in <a href="IO.html#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.IO#runToFuture" id="monix.bio.IO#runToFuture" class="extmbr">IO.runToFuture</a>).</p><div class="fullcomment"><div class="comment cmt"><p>Default, pure, globally visible <code>cats.effect.ContextShift</code>
implementation that shifts the evaluation to <code>Task</code>'s default
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>
(that's being injected in <a href="IO.html#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.IO#runToFuture" id="monix.bio.IO#runToFuture" class="extmbr">IO.runToFuture</a>).
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskContextShift</dd></dl></div></li><li class="indented0 " name="monix.bio.IO#create" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="create[E,A]:monix.bio.IO.AsyncBuilder.CreatePartiallyApplied[E,A]" class="anchorToMember"></a><a id="create[E,A]:CreatePartiallyApplied[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#create[E,A]:monix.bio.IO.AsyncBuilder.CreatePartiallyApplied[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">create</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="result">: <span name="monix.bio.IO.AsyncBuilder.CreatePartiallyApplied" class="extype">CreatePartiallyApplied</span>[<span name="monix.bio.IO.create.E" class="extype">E</span>, <span name="monix.bio.IO.create.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Polymorphic <code>Task</code> builder that is able to describe asynchronous
tasks depending on the type of the given callback.</p><div class="fullcomment"><div class="comment cmt"><p>Polymorphic <code>Task</code> builder that is able to describe asynchronous
tasks depending on the type of the given callback.</p><p>Note that this function uses the
<a href="https://typelevel.org/cats/guidelines.html#partially-applied-type-params" target="_blank">Partially-Applied Type technique</a>.</p><p>Calling <code>create</code> with a callback that returns <code>Unit</code> is
equivalent with <a href="#async0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;Unit):monix.bio.IO[E,A]" name="monix.bio.IO#async0" id="monix.bio.IO#async0" class="extmbr">IO.async0</a>:</p><p><code>Task.async0(f) &lt;-&gt; Task.create(f)</code></p><p>Example:</p><pre><span class="kw">import</span> scala.concurrent.Future

<span class="kw">def</span> deferFuture[A](f: <span class="kw">=&gt;</span> Future[A]): Task[A] =
  Task.create { (scheduler, cb) <span class="kw">=&gt;</span>
    f.onComplete(cb(_))(scheduler)
  }</pre><p>We could return a <a href="https://monix.io/api/3.1/monix/execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a>
reference and thus make a cancelable task. Example:</p><pre><span class="kw">import</span> monix.execution.Cancelable
<span class="kw">import</span> scala.concurrent.duration.FiniteDuration
<span class="kw">import</span> scala.util.Try

<span class="kw">def</span> delayResult1[A](timespan: FiniteDuration)(thunk: <span class="kw">=&gt;</span> A): Task[A] =
  Task.create { (scheduler, cb) <span class="kw">=&gt;</span>
    <span class="kw">val</span> c = scheduler.scheduleOnce(timespan)(cb(Try(thunk)))
    <span class="cmt">// We can simply return `c`, but doing this for didactic purposes!</span>
    Cancelable(() <span class="kw">=&gt;</span> c.cancel())
  }</pre><p>Passed function can also return <code>cats.effect.IO[Unit]</code> as a task that
describes a cancelation action:</p><pre><span class="kw">import</span> cats.effect.{IO <span class="kw">=&gt;</span> CIO}

<span class="kw">def</span> delayResult2[A](timespan: FiniteDuration)(thunk: <span class="kw">=&gt;</span> A): Task[A] =
  Task.create { (scheduler, cb) <span class="kw">=&gt;</span>
    <span class="kw">val</span> c = scheduler.scheduleOnce(timespan)(cb(Try(thunk)))
    <span class="cmt">// We can simply return `c`, but doing this for didactic purposes!</span>
    CIO(c.cancel())
  }</pre><p>Passed function can also return <code>Task[Unit]</code> as a task that
describes a cancelation action, thus for an <code>f</code> that can be
passed to <a href="#cancelable0[E,A](register:(monix.execution.Scheduler,monix.bio.BiCallback[E,A])=&gt;cats.effect.CancelToken[[β$1$]monix.bio.IO[E,β$1$]]):monix.bio.IO[E,A]" name="monix.bio.IO#cancelable0" id="monix.bio.IO#cancelable0" class="extmbr">IO.cancelable0</a>, and this equivalence holds:</p><p><code>Task.cancelable(f) &lt;-&gt; Task.create(f)</code></p><pre><span class="kw">def</span> delayResult3[A](timespan: FiniteDuration)(thunk: <span class="kw">=&gt;</span> A): Task[A] =
  Task.create { (scheduler, cb) <span class="kw">=&gt;</span>
    <span class="kw">val</span> c = scheduler.scheduleOnce(timespan)(cb(Try(thunk)))
    <span class="cmt">// We can simply return `c`, but doing this for didactic purposes!</span>
    Task(c.cancel())
  }</pre><p>The supported types for the cancelation tokens are:</p><ul><li><code>Unit</code>, yielding non-cancelable tasks</li><li><a href="https://monix.io/api/3.1/monix/execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a>, the Monix standard</li><li><a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task[Unit</a>]</li><li><code>cats.effect.IO[Unit]</code>, see
   <a href="https://typelevel.org/cats-effect/datatypes/io.html" target="_blank">IO docs</a></li></ul><p>Support for more might be added in the future.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#defaultOptions" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="defaultOptions:monix.bio.IO.Options" class="anchorToMember"></a><a id="defaultOptions:Options" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#defaultOptions:monix.bio.IO.Options" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">defaultOptions</span><span class="result">: <a href="IO$$Options.html" name="monix.bio.IO.Options" id="monix.bio.IO.Options" class="extype">Options</a></span></span><p class="shortcomment cmt">Default <a href="IO$$Options.html" name="monix.bio.IO.Options" id="monix.bio.IO.Options" class="extype">Options</a> to use for <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> evaluation,
thus:</p><div class="fullcomment"><div class="comment cmt"><p>Default <a href="IO$$Options.html" name="monix.bio.IO.Options" id="monix.bio.IO.Options" class="extype">Options</a> to use for <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> evaluation,
thus:</p><ul><li><code>autoCancelableRunLoops</code> is <code>true</code> by default</li><li><code>localContextPropagation</code> is <code>false</code> by default</li></ul><p>On top of the JVM the default can be overridden by
setting the following system properties:</p><ul><li><code>monix.environment.autoCancelableRunLoops</code>
   (<code>false</code>, <code>no</code> or <code>0</code> for disabling)</li><li><code>monix.environment.localContextPropagation</code>
   (<code>true</code>, <code>yes</code> or <code>1</code> for enabling)
</li></ul></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="IO$$Options.html" name="monix.bio.IO.Options" id="monix.bio.IO.Options" class="extype">IO.Options</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#defer" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="defer[A](fa:=&gt;monix.bio.Task[A]):monix.bio.Task[A]" class="anchorToMember"></a><a id="defer[A](=&gt;Task[A]):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#defer[A](fa:=&gt;monix.bio.Task[A]):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">defer</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="fa">fa: =&gt; <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.defer.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.defer.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Defers the creation of a <code>Task</code> in case it is effectful.</p><div class="fullcomment"><div class="comment cmt"><p>Defers the creation of a <code>Task</code> in case it is effectful.</p><p>It will catch any exceptions thrown in <code>fa</code> and expose them as
a typed error.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#deferTotal[E,A](fa:=&gt;monix.bio.IO[E,A]):monix.bio.IO[E,A]" name="monix.bio.IO#deferTotal" id="monix.bio.IO#deferTotal" class="extmbr">deferTotal</a> if <code>fa</code> is not expected to throw any exceptions.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#deferAction" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="deferAction[E,A](f:monix.execution.Scheduler=&gt;monix.bio.IO[E,A]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="deferAction[E,A]((Scheduler)=&gt;IO[E,A]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#deferAction[E,A](f:monix.execution.Scheduler=&gt;monix.bio.IO[E,A]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">deferAction</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="f">f: (<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>) =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.deferAction.E" class="extype">E</span>, <span name="monix.bio.IO.deferAction.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.deferAction.E" class="extype">E</span>, <span name="monix.bio.IO.deferAction.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Defers the creation of a <code>Task</code> by using the provided
function, which has the ability to inject a needed
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Defers the creation of a <code>Task</code> by using the provided
function, which has the ability to inject a needed
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>.</p><p>Example:</p><pre><span class="kw">import</span> scala.concurrent.duration.MILLISECONDS

<span class="kw">def</span> measureLatency[A](source: Task[A]): Task[(A, <span class="std">Long</span>)] =
  Task.deferAction { <span class="kw">implicit</span> s <span class="kw">=&gt;</span>
    <span class="cmt">// We have our Scheduler, which can inject time, we</span>
    <span class="cmt">// can use it for side-effectful operations</span>
    <span class="kw">val</span> start = s.clockRealTime(MILLISECONDS)

    source.map { a <span class="kw">=&gt;</span>
      <span class="kw">val</span> finish = s.clockRealTime(MILLISECONDS)
      (a, finish - start)
    }
  }</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the function that's going to be called when the
       resulting <code>Task</code> gets evaluated</p></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#deferFuture" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="deferFuture[A](fa:=&gt;scala.concurrent.Future[A]):monix.bio.Task[A]" class="anchorToMember"></a><a id="deferFuture[A](=&gt;Future[A]):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#deferFuture[A](fa:=&gt;scala.concurrent.Future[A]):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">deferFuture</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="fa">fa: =&gt; <a href="https://www.scala-lang.org/api/2.13.6/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="monix.bio.IO.deferFuture.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.deferFuture.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Promote a non-strict Scala <code>Future</code> to a <code>Task</code> of the same type.</p><div class="fullcomment"><div class="comment cmt"><p>Promote a non-strict Scala <code>Future</code> to a <code>Task</code> of the same type.</p><p>The equivalent of doing:</p><pre><span class="kw">import</span> scala.concurrent.Future
<span class="kw">def</span> mkFuture = Future.successful(<span class="num">27</span>)

Task.defer(Task.fromFuture(mkFuture))</pre></div></div></li><li class="indented0 " name="monix.bio.IO#deferFutureAction" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="deferFutureAction[A](f:monix.execution.Scheduler=&gt;scala.concurrent.Future[A]):monix.bio.Task[A]" class="anchorToMember"></a><a id="deferFutureAction[A]((Scheduler)=&gt;Future[A]):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#deferFutureAction[A](f:monix.execution.Scheduler=&gt;scala.concurrent.Future[A]):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">deferFutureAction</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="f">f: (<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>) =&gt; <a href="https://www.scala-lang.org/api/2.13.6/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="monix.bio.IO.deferFutureAction.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.deferFutureAction.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Wraps calls that generate <code>Future</code> results into <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>, provided
a callback with an injected <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>
to act as the necessary <code>ExecutionContext</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps calls that generate <code>Future</code> results into <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>, provided
a callback with an injected <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>
to act as the necessary <code>ExecutionContext</code>.</p><p>This builder helps with wrapping <code>Future</code>-enabled APIs that need
an implicit <code>ExecutionContext</code> to work. Consider this example:</p><pre><span class="kw">import</span> scala.concurrent.{ExecutionContext, Future}

<span class="kw">def</span> sumFuture(list: <span class="std">Seq</span>[<span class="std">Int</span>])(<span class="kw">implicit</span> ec: ExecutionContext): Future[<span class="std">Int</span>] =
  Future(list.sum)</pre><p>We'd like to wrap this function into one that returns a lazy
<code>Task</code> that evaluates this sum every time it is called, because
that's how tasks work best. However in order to invoke this
function an <code>ExecutionContext</code> is needed:</p><pre><span class="kw">def</span> sumTask(list: <span class="std">Seq</span>[<span class="std">Int</span>])(<span class="kw">implicit</span> ec: ExecutionContext): Task[<span class="std">Int</span>] =
  Task.deferFuture(sumFuture(list))</pre><p>But this is not only superfluous, but against the best practices
of using <code>Task</code>. The difference is that <code>Task</code> takes a
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> (inheriting from
<code>ExecutionContext</code>) only when <a href="IO.html#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.IO#runAsync" id="monix.bio.IO#runAsync" class="extmbr">runAsync</a> happens.
But with <code>deferFutureAction</code> we get to have an injected
<code>Scheduler</code> in the passed callback:</p><pre><span class="kw">def</span> sumTask2(list: <span class="std">Seq</span>[<span class="std">Int</span>]): Task[<span class="std">Int</span>] =
  Task.deferFutureAction { <span class="kw">implicit</span> scheduler <span class="kw">=&gt;</span>
    sumFuture(list)
  }</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the function that's going to be executed when the task
       gets evaluated, generating the wrapped <code>Future</code></p></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#deferFutureEither" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="deferFutureEither[E,A](fa:=&gt;scala.concurrent.Future[Either[E,A]]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="deferFutureEither[E,A](=&gt;Future[Either[E,A]]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#deferFutureEither[E,A](fa:=&gt;scala.concurrent.Future[Either[E,A]]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">deferFutureEither</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="fa">fa: =&gt; <a href="https://www.scala-lang.org/api/2.13.6/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.IO.deferFutureEither.E" class="extype">E</span>, <span name="monix.bio.IO.deferFutureEither.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.deferFutureEither.E" class="extype">E</span>, <span name="monix.bio.IO.deferFutureEither.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Promote a non-strict Scala <code>Future</code> wrapping a Scala <code>Either[E, A]</code> to a <code>IO[E, A]</code>.</p></li><li class="indented0 " name="monix.bio.IO#deferTotal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="deferTotal[E,A](fa:=&gt;monix.bio.IO[E,A]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="deferTotal[E,A](=&gt;IO[E,A]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#deferTotal[E,A](fa:=&gt;monix.bio.IO[E,A]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">deferTotal</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="fa">fa: =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.deferTotal.E" class="extype">E</span>, <span name="monix.bio.IO.deferTotal.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.deferTotal.E" class="extype">E</span>, <span name="monix.bio.IO.deferTotal.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Defers the creation of a <code>IO</code> in case it is effectful.</p><div class="fullcomment"><div class="comment cmt"><p>Defers the creation of a <code>IO</code> in case it is effectful.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#defer[A](fa:=&gt;monix.bio.Task[A]):monix.bio.Task[A]" name="monix.bio.IO#defer" id="monix.bio.IO#defer" class="extmbr">defer</a> if <code>fa</code> is expected to throw exceptions and you would
     like to expose them as typed errors.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#delay" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="delay[A](a:=&gt;A):monix.bio.Task[A]" class="anchorToMember"></a><a id="delay[A](=&gt;A):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#delay[A](a:=&gt;A):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">delay</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: =&gt; <span name="monix.bio.IO.delay.A" class="extype">A</span></span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.delay.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Alias for <a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">eval</a>.</p></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean" class="anchorToMember"></a><a id="eq(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.6/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean" class="anchorToMember"></a><a id="equals(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.6/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.bio.IO#eval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eval[A](a:=&gt;A):monix.bio.Task[A]" class="anchorToMember"></a><a id="eval[A](=&gt;A):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#eval[A](a:=&gt;A):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eval</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: =&gt; <span name="monix.bio.IO.eval.A" class="extype">A</span></span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.eval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Promote a non-strict value, a thunk, to a <code>IO</code>, catching exceptions
in the process.</p><div class="fullcomment"><div class="comment cmt"><p>Promote a non-strict value, a thunk, to a <code>IO</code>, catching exceptions
in the process.</p><p>Note that since <code>IO</code> is not memoized or strict, this will recompute the
value each time the <code>IO</code> is executed, behaving like a function.
</p></div><dl class="paramcmts block"><dt class="param">a</dt><dd class="cmt"><p>is the thunk to process on evaluation</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#evalTotal[A](a:=&gt;A):monix.bio.UIO[A]" name="monix.bio.IO#evalTotal" id="monix.bio.IO#evalTotal" class="extmbr">evalTotal</a> if <code>a</code> is not expected to throw any exceptions.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#evalAsync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="evalAsync[A](a:=&gt;A):monix.bio.Task[A]" class="anchorToMember"></a><a id="evalAsync[A](=&gt;A):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">evalAsync</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: =&gt; <span name="monix.bio.IO.evalAsync.A" class="extype">A</span></span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.evalAsync.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Lifts a non-strict value, a thunk, to a <code>Task</code> that will trigger a logical
fork before evaluation.</p><div class="fullcomment"><div class="comment cmt"><p>Lifts a non-strict value, a thunk, to a <code>Task</code> that will trigger a logical
fork before evaluation.</p><p>Like <a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">eval</a>, but the provided <code>thunk</code> will not be evaluated immediately.
Equivalence:</p><p><code>Task.evalAsync(a) &lt;-&gt; Task.eval(a).executeAsync</code>
</p></div><dl class="paramcmts block"><dt class="param">a</dt><dd class="cmt"><p>is the thunk to process on evaluation</p></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#evalOnce" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="evalOnce[A](a:=&gt;A):monix.bio.Task[A]" class="anchorToMember"></a><a id="evalOnce[A](=&gt;A):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#evalOnce[A](a:=&gt;A):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">evalOnce</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: =&gt; <span name="monix.bio.IO.evalOnce.A" class="extype">A</span></span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.evalOnce.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Promote a non-strict value to a <code>IO</code> that is memoized on the first
evaluation, the result being then available on subsequent evaluations.</p></li><li class="indented0 " name="monix.bio.IO#evalTotal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="evalTotal[A](a:=&gt;A):monix.bio.UIO[A]" class="anchorToMember"></a><a id="evalTotal[A](=&gt;A):UIO[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#evalTotal[A](a:=&gt;A):monix.bio.UIO[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">evalTotal</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: =&gt; <span name="monix.bio.IO.evalTotal.A" class="extype">A</span></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="monix.bio.IO.evalTotal.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Promote a non-strict value which does not throw any unexpected errors to <code>UIO</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Promote a non-strict value which does not throw any unexpected errors to <code>UIO</code>.</p><p>Note that since <code>IO</code> is not memoized or strict, this will recompute the
value each time the <code>IO</code> is executed, behaving like a function.
</p></div><dl class="paramcmts block"><dt class="param">a</dt><dd class="cmt"><p>is the thunk to process on evaluation</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">eval</a> if <code>a</code> is expected to throw exceptions and you want to expose them
     in a typed error channel.</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.IO#from" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="from[F[_],A](fa:F[A])(implicitF:monix.bio.IOLike[F]):monix.bio.Task[A]" class="anchorToMember"></a><a id="from[F[_],A](F[A])(IOLike[F]):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#from[F[_],A](fa:F[A])(implicitF:monix.bio.IOLike[F]):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">from</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="A">A</span>]</span><span class="params">(<span name="fa">fa: <span name="monix.bio.IO.from.F" class="extype">F</span>[<span name="monix.bio.IO.from.A" class="extype">A</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="IOLike.html" name="monix.bio.IOLike" id="monix.bio.IOLike" class="extype">IOLike</a>[<span name="monix.bio.IO.from.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.from.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts into a <code>Task</code> from any <code>F[_]</code> for which there exists
a <a href="IOLike.html" name="monix.bio.IOLike" id="monix.bio.IOLike" class="extype">IOLike</a> implementation.</p><div class="fullcomment"><div class="comment cmt"><p>Converts into a <code>Task</code> from any <code>F[_]</code> for which there exists
a <a href="IOLike.html" name="monix.bio.IOLike" id="monix.bio.IOLike" class="extype">IOLike</a> implementation.</p><p>Supported types include, but are not necessarily limited to:</p><ul><li><a href="https://typelevel.org/cats/datatypes/eval.html" target="_blank">cats.Eval</a></li><li><a href="https://typelevel.org/cats-effect/datatypes/io.html" target="_blank">cats.effect.IO</a></li><li><a href="https://typelevel.org/cats-effect/datatypes/syncio.html" target="_blank">cats.effect.SyncIO</a></li><li><a href="https://typelevel.org/cats-effect/typeclasses/effect.html" target="_blank">cats.effect.Effect (Async)</a></li><li><a href="https://typelevel.org/cats-effect/typeclasses/concurrent-effect.html" target="_blank">cats.effect.ConcurrentEffect</a></li><li><a href="https://www.scala-lang.org/api/2.13.6/scala/index.html#Either[+A,+B]=scala.util.Either[A,B]" name="scala" id="scala" class="extype">scala.Either</a></li><li><a href="https://www.scala-lang.org/api/2.13.6/scala/util/Try.html" name="scala.util.Try" id="scala.util.Try" class="extype">scala.util.Try</a></li><li><a href="https://www.scala-lang.org/api/2.13.6/scala/concurrent/Future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">scala.concurrent.Future</a>
</li></ul></div></div></li><li class="indented0 " name="monix.bio.IO#fromCancelablePromise" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="fromCancelablePromise[A](p:monix.execution.CancelablePromise[A]):monix.bio.Task[A]" class="anchorToMember"></a><a id="fromCancelablePromise[A](CancelablePromise[A]):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromCancelablePromise[A](p:monix.execution.CancelablePromise[A]):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromCancelablePromise</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="p">p: <a href="https://monix.io/api/3.1/monix/execution/CancelablePromise.html#monix.execution.CancelablePromise" name="monix.execution.CancelablePromise" id="monix.execution.CancelablePromise" class="extype">CancelablePromise</a>[<span name="monix.bio.IO.fromCancelablePromise.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.fromCancelablePromise.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Wraps a <a href="https://monix.io/api/3.1/monix/execution/CancelablePromise.html" name="monix.execution.CancelablePromise" id="monix.execution.CancelablePromise" class="extype">monix.execution.CancelablePromise</a> into <code>Task</code>.</p></li><li class="indented0 " name="monix.bio.IO#fromCancelablePromiseEither" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="fromCancelablePromiseEither[E,A](p:monix.execution.CancelablePromise[Either[E,A]]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="fromCancelablePromiseEither[E,A](CancelablePromise[Either[E,A]]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromCancelablePromiseEither[E,A](p:monix.execution.CancelablePromise[Either[E,A]]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromCancelablePromiseEither</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="p">p: <a href="https://monix.io/api/3.1/monix/execution/CancelablePromise.html#monix.execution.CancelablePromise" name="monix.execution.CancelablePromise" id="monix.execution.CancelablePromise" class="extype">CancelablePromise</a>[<span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.IO.fromCancelablePromiseEither.E" class="extype">E</span>, <span name="monix.bio.IO.fromCancelablePromiseEither.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.fromCancelablePromiseEither.E" class="extype">E</span>, <span name="monix.bio.IO.fromCancelablePromiseEither.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Wraps a <a href="https://monix.io/api/3.1/monix/execution/CancelablePromise.html" name="monix.execution.CancelablePromise" id="monix.execution.CancelablePromise" class="extype">monix.execution.CancelablePromise</a> into <code>IO</code>.</p></li><li class="indented0 " name="monix.bio.IO#fromConcurrentEffect" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fromConcurrentEffect[F[_],A](fa:F[A])(implicitF:cats.effect.ConcurrentEffect[F]):monix.bio.Task[A]" class="anchorToMember"></a><a id="fromConcurrentEffect[F[_],A](F[A])(ConcurrentEffect[F]):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromConcurrentEffect[F[_],A](fa:F[A])(implicitF:cats.effect.ConcurrentEffect[F]):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromConcurrentEffect</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="A">A</span>]</span><span class="params">(<span name="fa">fa: <span name="monix.bio.IO.fromConcurrentEffect.F" class="extype">F</span>[<span name="monix.bio.IO.fromConcurrentEffect.A" class="extype">A</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="https://typelevel.org/cats-effect/api/cats/effect/ConcurrentEffect.html#cats.effect.ConcurrentEffect" name="cats.effect.ConcurrentEffect" id="cats.effect.ConcurrentEffect" class="extype">ConcurrentEffect</a>[<span name="monix.bio.IO.fromConcurrentEffect.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.fromConcurrentEffect.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Builds a <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a> out of any data type that implements
<a href="https://typelevel.org/cats-effect/typeclasses/concurrent.html" target="_blank">Concurrent</a> and
<a href="https://typelevel.org/cats-effect/typeclasses/concurrent-effect.html" target="_blank">ConcurrentEffect</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a> out of any data type that implements
<a href="https://typelevel.org/cats-effect/typeclasses/concurrent.html" target="_blank">Concurrent</a> and
<a href="https://typelevel.org/cats-effect/typeclasses/concurrent-effect.html" target="_blank">ConcurrentEffect</a>.</p><p>Example:</p><pre><span class="kw">import</span> cats.effect.{IO <span class="kw">=&gt;</span> CIO, _}
<span class="kw">import</span> cats.syntax.all._
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">import</span> scala.concurrent.duration._

<span class="kw">implicit</span> <span class="kw">val</span> timer = CIO.timer(global)
<span class="kw">implicit</span> <span class="kw">val</span> cs = CIO.contextShift(global)

<span class="kw">val</span> cio = CIO.sleep(<span class="num">5.</span>seconds) *&gt; CIO(println(<span class="lit">"Hello!"</span>))

<span class="cmt">// Resulting task is cancelable</span>
<span class="kw">val</span> task: Task[<span class="std">Unit</span>] = IO.fromConcurrentEffect(cio)</pre><p>Cancellation / finalization behavior is carried over, so the
resulting task can be safely cancelled.
</p></div><dl class="paramcmts block"><dt class="param">F</dt><dd class="cmt"><p>is the <code>cats.effect.Effect</code> type class instance necessary
       for converting to <code>Task</code>; this instance can also be a
       <code>cats.effect.Concurrent</code>, in which case the resulting
       <code>Task</code> value is cancelable if the source also is</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#liftToConcurrent[F[_]](implicitF:cats.effect.Concurrent[F],impliciteff:cats.effect.ConcurrentEffect[monix.bio.Task]):monix.bio.Task~&gt;F" name="monix.bio.IO#liftToConcurrent" id="monix.bio.IO#liftToConcurrent" class="extmbr">IO.liftToConcurrent</a> for its dual</p></span><span class="cmt"><p><a href="#fromEffect[F[_],A](fa:F[A])(implicitF:cats.effect.Effect[F]):monix.bio.Task[A]" name="monix.bio.IO#fromEffect" id="monix.bio.IO#fromEffect" class="extmbr">IO.fromEffect</a> for a version that works with simpler,
     non-cancelable <code>Async</code> data types</p></span><span class="cmt"><p><a href="#from[F[_],A](fa:F[A])(implicitF:monix.bio.IOLike[F]):monix.bio.Task[A]" name="monix.bio.IO#from" id="monix.bio.IO#from" class="extmbr">IO.from</a> for a more generic version that works with
     any <a href="IOLike.html" name="monix.bio.IOLike" id="monix.bio.IOLike" class="extype">IOLike</a> data type</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#fromEffect" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fromEffect[F[_],A](fa:F[A])(implicitF:cats.effect.Effect[F]):monix.bio.Task[A]" class="anchorToMember"></a><a id="fromEffect[F[_],A](F[A])(Effect[F]):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromEffect[F[_],A](fa:F[A])(implicitF:cats.effect.Effect[F]):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromEffect</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="A">A</span>]</span><span class="params">(<span name="fa">fa: <span name="monix.bio.IO.fromEffect.F" class="extype">F</span>[<span name="monix.bio.IO.fromEffect.A" class="extype">A</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="https://typelevel.org/cats-effect/api/cats/effect/Effect.html#cats.effect.Effect" name="cats.effect.Effect" id="cats.effect.Effect" class="extype">Effect</a>[<span name="monix.bio.IO.fromEffect.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.fromEffect.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Builds a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> out of any data type that implements
<a href="https://typelevel.org/cats-effect/typeclasses/async.html" target="_blank">Async</a> and
<a href="https://typelevel.org/cats-effect/typeclasses/effect.html" target="_blank">Effect</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> out of any data type that implements
<a href="https://typelevel.org/cats-effect/typeclasses/async.html" target="_blank">Async</a> and
<a href="https://typelevel.org/cats-effect/typeclasses/effect.html" target="_blank">Effect</a>.</p><p>Example:</p><pre><span class="kw">import</span> cats.effect.{IO <span class="kw">=&gt;</span> CIO}

<span class="kw">val</span> cio: CIO[<span class="std">Unit</span>] = CIO(println(<span class="lit">"Hello!"</span>))
<span class="kw">val</span> task: Task[<span class="std">Unit</span>] = IO.fromEffect(cio)</pre><p>WARNING: the resulting task might not carry the source's cancellation behavior
if the source is cancelable! This is implicit in the usage of <code>Effect</code>.
</p></div><dl class="paramcmts block"><dt class="param">F</dt><dd class="cmt"><p>is the <code>cats.effect.Effect</code> type class instance necessary
       for converting to <code>Task</code>; this instance can also be a
       <code>cats.effect.Concurrent</code>, in which case the resulting
       <code>Task</code> value is cancelable if the source also is</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#fromConcurrentEffect[F[_],A](fa:F[A])(implicitF:cats.effect.ConcurrentEffect[F]):monix.bio.Task[A]" name="monix.bio.IO#fromConcurrentEffect" id="monix.bio.IO#fromConcurrentEffect" class="extmbr">IO.fromConcurrentEffect</a> for a version that can use
     <a href="https://typelevel.org/cats-effect/typeclasses/concurrent.html" target="_blank">Concurrent</a>
     for converting cancelable tasks.</p></span><span class="cmt"><p><a href="#from[F[_],A](fa:F[A])(implicitF:monix.bio.IOLike[F]):monix.bio.Task[A]" name="monix.bio.IO#from" id="monix.bio.IO#from" class="extmbr">IO.from</a> for a more generic version that works with
     any <a href="IOLike.html" name="monix.bio.IOLike" id="monix.bio.IOLike" class="extype">IOLike</a> data type</p></span><span class="cmt"><p><a href="#liftToAsync[F[_]](implicitF:cats.effect.Async[F],impliciteff:cats.effect.Effect[monix.bio.Task]):monix.bio.Task~&gt;F" name="monix.bio.IO#liftToAsync" id="monix.bio.IO#liftToAsync" class="extmbr">for</a> its dual</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#fromEither" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="fromEither[E,A](a:Either[E,A]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="fromEither[E,A](Either[E,A]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromEither[E,A](a:Either[E,A]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromEither</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="a">a: <span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.IO.fromEither.E" class="extype">E</span>, <span name="monix.bio.IO.fromEither.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.fromEither.E" class="extype">E</span>, <span name="monix.bio.IO.fromEither.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Builds a <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a> instance out of a Scala <code>Either</code>.</p></li><li class="indented0 " name="monix.bio.IO#fromFuture" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fromFuture[A](f:scala.concurrent.Future[A]):monix.bio.Task[A]" class="anchorToMember"></a><a id="fromFuture[A](Future[A]):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromFuture[A](f:scala.concurrent.Future[A]):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromFuture</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="f">f: <a href="https://www.scala-lang.org/api/2.13.6/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="monix.bio.IO.fromFuture.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.fromFuture.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts the given Scala <code>Future</code> into a <code>Task</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts the given Scala <code>Future</code> into a <code>Task</code>.</p><p>There is an async boundary inserted at the end to guarantee
that we stay on the main Scheduler.</p><p>NOTE: if you want to defer the creation of the future, use
in combination with <a href="#defer[A](fa:=&gt;monix.bio.Task[A]):monix.bio.Task[A]" name="monix.bio.IO#defer" id="monix.bio.IO#defer" class="extmbr">defer</a>.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#fromFutureEither" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="fromFutureEither[E,A](a:scala.concurrent.Future[Either[E,A]]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="fromFutureEither[E,A](Future[Either[E,A]]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromFutureEither[E,A](a:scala.concurrent.Future[Either[E,A]]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromFutureEither</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="a">a: <a href="https://www.scala-lang.org/api/2.13.6/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.IO.fromFutureEither.E" class="extype">E</span>, <span name="monix.bio.IO.fromFutureEither.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.fromFutureEither.E" class="extype">E</span>, <span name="monix.bio.IO.fromFutureEither.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Builds a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instance out of a Scala <code>Either</code> wrapped in a Scala <code>Future</code></p></li><li class="indented0 " name="monix.bio.IO#fromFutureLike" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="fromFutureLike[F[_],A](tfa:monix.bio.Task[F[A]])(implicitF:monix.catnap.FutureLift[monix.bio.Task,F]):monix.bio.Task[A]" class="anchorToMember"></a><a id="fromFutureLike[F[_],A](Task[F[A]])(FutureLift[Task,F]):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromFutureLike[F[_],A](tfa:monix.bio.Task[F[A]])(implicitF:monix.catnap.FutureLift[monix.bio.Task,F]):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromFutureLike</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="A">A</span>]</span><span class="params">(<span name="tfa">tfa: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.fromFutureLike.F" class="extype">F</span>[<span name="monix.bio.IO.fromFutureLike.A" class="extype">A</span>]]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="https://monix.io/api/3.1/monix/catnap/FutureLift.html#monix.catnap.FutureLift" name="monix.catnap.FutureLift" id="monix.catnap.FutureLift" class="extype">FutureLift</a>[<a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>, <span name="monix.bio.IO.fromFutureLike.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.fromFutureLike.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts any Future-like data-type into a <code>Task</code>, via <a href="https://monix.io/api/3.1/monix/catnap/FutureLift.html" name="monix.catnap.FutureLift" id="monix.catnap.FutureLift" class="extype">monix.catnap.FutureLift</a>.</p></li><li class="indented0 " name="monix.bio.IO#fromOption" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fromOption[E,A](opt:Option[A],ifEmpty:=&gt;E):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="fromOption[E,A](Option[A],=&gt;E):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromOption[E,A](opt:Option[A],ifEmpty:=&gt;E):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromOption</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="opt">opt: <a href="https://www.scala-lang.org/api/2.13.6/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.bio.IO.fromOption.A" class="extype">A</span>]</span>, <span name="ifEmpty">ifEmpty: =&gt; <span name="monix.bio.IO.fromOption.E" class="extype">E</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.fromOption.E" class="extype">E</span>, <span name="monix.bio.IO.fromOption.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Builds a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instance out of a Scala <code>Option</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instance out of a Scala <code>Option</code>.
If the Option is empty, the task fails with the provided fallback.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#fromOptionEval[E,E1&gt;:E,A](opt:monix.bio.IO[E,Option[A]],ifEmpty:=&gt;E1):monix.bio.IO[E1,A]" name="monix.bio.IO#fromOptionEval" id="monix.bio.IO#fromOptionEval" class="extmbr">IO.fromOptionEval</a> for a version that takes a <code>IO[E, Option[A]]</code>
Example:</p><pre><span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> NotFound()

IO.fromOption(<span class="std">Some</span>(<span class="num">1</span>), NotFound()) <span class="cmt">// &lt;-&gt; IO.now(1)</span>
IO.fromOption(<span class="std">None</span>, NotFound())   <span class="cmt">// &lt;-&gt; IO.raiseError(NotFound())</span></pre></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#fromOption" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fromOption[A](opt:Option[A]):monix.bio.IO[Unit,A]" class="anchorToMember"></a><a id="fromOption[A](Option[A]):IO[Unit,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromOption[A](opt:Option[A]):monix.bio.IO[Unit,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromOption</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="opt">opt: <a href="https://www.scala-lang.org/api/2.13.6/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.bio.IO.fromOption.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>, <span name="monix.bio.IO.fromOption.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Builds a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instance out of a Scala <code>Option</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instance out of a Scala <code>Option</code>.
If the Option is empty, the task fails with Unit.</p><p>Example:</p><pre>IO.fromOption(<span class="std">Some</span>(<span class="num">1</span>)) <span class="cmt">// &lt;-&gt; IO.now(1))</span>
IO.fromOption(<span class="std">None</span>)    <span class="cmt">// &lt;-&gt; IO.raiseError(())</span></pre></div></div></li><li class="indented0 " name="monix.bio.IO#fromOptionEval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fromOptionEval[E,E1&gt;:E,A](opt:monix.bio.IO[E,Option[A]],ifEmpty:=&gt;E1):monix.bio.IO[E1,A]" class="anchorToMember"></a><a id="fromOptionEval[E,E1&gt;:E,A](IO[E,Option[A]],=&gt;E1):IO[E1,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromOptionEval[E,E1&gt;:E,A](opt:monix.bio.IO[E,Option[A]],ifEmpty:=&gt;E1):monix.bio.IO[E1,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromOptionEval</span><span class="tparams">[<span name="E">E</span>, <span name="E1">E1 &gt;: <span name="monix.bio.IO.fromOptionEval.E" class="extype">E</span></span>, <span name="A">A</span>]</span><span class="params">(<span name="opt">opt: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.fromOptionEval.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.6/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.bio.IO.fromOptionEval.A" class="extype">A</span>]]</span>, <span name="ifEmpty">ifEmpty: =&gt; <span name="monix.bio.IO.fromOptionEval.E1" class="extype">E1</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.fromOptionEval.E1" class="extype">E1</span>, <span name="monix.bio.IO.fromOptionEval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Builds a new <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instance out of a <code>IO[E, Option[A]]</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a new <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instance out of a <code>IO[E, Option[A]]</code>.
If the inner Option is empty, the task fails with the provided fallback.</p><p>Example:</p><pre><span class="kw">type</span> ErrorCode = <span class="std">Int</span>
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Item()

<span class="kw">def</span> findItem(id: <span class="std">Int</span>): IO[ErrorCode, <span class="std">Option</span>[Item]] =
  UIO.now(<span class="std">Some</span>(Item()))

IO.fromOptionEval(findItem(<span class="num">1</span>), <span class="num">404</span>)</pre></div></div></li><li class="indented0 " name="monix.bio.IO#fromReactivePublisher" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fromReactivePublisher[A](source:org.reactivestreams.Publisher[A]):monix.bio.Task[Option[A]]" class="anchorToMember"></a><a id="fromReactivePublisher[A](Publisher[A]):Task[Option[A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromReactivePublisher[A](source:org.reactivestreams.Publisher[A]):monix.bio.Task[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromReactivePublisher</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="source">source: <span name="org.reactivestreams.Publisher" class="extype">Publisher</span>[<span name="monix.bio.IO.fromReactivePublisher.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<a href="https://www.scala-lang.org/api/2.13.6/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.bio.IO.fromReactivePublisher.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Converts an <code>org.reactivestreams.Publisher</code> into a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts an <code>org.reactivestreams.Publisher</code> into a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>.</p><p>See <a href="http://www.reactive-streams.org/" target="_blank">reactive-streams.org</a> for the
Reactive Streams specification.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>is the <code>org.reactivestreams.Publisher</code> reference to
              wrap into a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>.</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="IO.html#toReactivePublisher(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):org.reactivestreams.Publisher[A@scala.annotation.unchecked.uncheckedVariance]" name="monix.bio.IO#toReactivePublisher" id="monix.bio.IO#toReactivePublisher" class="extmbr">IO.toReactivePublisher</a> for converting a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> into
     a reactive publisher.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#fromTry" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="fromTry[A](a:scala.util.Try[A]):monix.bio.Task[A]" class="anchorToMember"></a><a id="fromTry[A](Try[A]):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromTry[A](a:scala.util.Try[A]):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromTry</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: <a href="https://www.scala-lang.org/api/2.13.6/scala/util/Try.html#scala.util.Try" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="monix.bio.IO.fromTry.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.fromTry.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Builds a <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a> instance out of a Scala <code>Try</code>.</p></li><li class="indented0 " name="monix.bio.IO#fromTryEither" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="fromTryEither[E,A](a:scala.util.Try[Either[E,A]]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="fromTryEither[E,A](Try[Either[E,A]]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#fromTryEither[E,A](a:scala.util.Try[Either[E,A]]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromTryEither</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="a">a: <a href="https://www.scala-lang.org/api/2.13.6/scala/util/Try.html#scala.util.Try" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.IO.fromTryEither.E" class="extype">E</span>, <span name="monix.bio.IO.fromTryEither.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.fromTryEither.E" class="extype">E</span>, <span name="monix.bio.IO.fromTryEither.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Builds a <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instance out of scala <code>Either</code> wrapped in scala <code>Try</code></p></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]" class="anchorToMember"></a><a id="getClass():Class[_&lt;:AnyRef]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#java.lang.Class" name="java.lang.Class" id="java.lang.Class" class="extype">Class</a>[_ &lt;: <a href="https://www.scala-lang.org/api/2.13.6/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="monix.bio.IO#left" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="left[A,B](a:A):monix.bio.UIO[Either[A,B]]" class="anchorToMember"></a><a id="left[A,B](A):UIO[Either[A,B]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#left[A,B](a:A):monix.bio.UIO[Either[A,B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">left</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="a">a: <span name="monix.bio.IO.left.A" class="extype">A</span></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.IO.left.A" class="extype">A</span>, <span name="monix.bio.IO.left.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">Returns an <code>IO</code> that on execution is always successful, emitting left value.</p></li><li class="indented0 " name="monix.bio.IO#liftFrom" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="liftFrom[F[_]](implicitF:monix.bio.IOLike[F]):F~&gt;monix.bio.Task" class="anchorToMember"></a><a id="liftFrom[F[_]](IOLike[F]):~&gt;[F,Task]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#liftFrom[F[_]](implicitF:monix.bio.IOLike[F]):F~&gt;monix.bio.Task" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">liftFrom</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="IOLike.html" name="monix.bio.IOLike" id="monix.bio.IOLike" class="extype">IOLike</a>[<span name="monix.bio.IO.liftFrom.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="cats.~&gt;" class="extype">~&gt;</span>[<span name="monix.bio.IO.liftFrom.F" class="extype">F</span>, <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>]</span></span><p class="shortcomment cmt">Returns a <code>F ~&gt; Task</code> (<code>FunctionK</code>) for transforming any
supported data-type into <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>F ~&gt; Task</code> (<code>FunctionK</code>) for transforming any
supported data-type into <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>.</p><p>Useful for <code>mapK</code> transformations, for example when working
with <code>Resource</code> or <code>Iterant</code>:</p><pre><span class="kw">import</span> cats.effect.{IO <span class="kw">=&gt;</span> CIO, _}
<span class="kw">import</span> monix.bio._
<span class="kw">import</span> java.io._

<span class="kw">def</span> open(file: File) =
  Resource[CIO, InputStream](CIO {
    <span class="kw">val</span> in = <span class="kw">new</span> FileInputStream(file)
    (in, CIO(in.close()))
  })

<span class="cmt">// Lifting to a Resource of Task</span>
<span class="kw">val</span> res: Resource[Task, InputStream] =
  open(<span class="kw">new</span> File(<span class="lit">"sample"</span>)).mapK(Task.liftFrom[CIO])</pre></div></div></li><li class="indented0 " name="monix.bio.IO#liftFromConcurrentEffect" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="liftFromConcurrentEffect[F[_]](implicitF:cats.effect.ConcurrentEffect[F]):F~&gt;monix.bio.Task" class="anchorToMember"></a><a id="liftFromConcurrentEffect[F[_]](ConcurrentEffect[F]):~&gt;[F,Task]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#liftFromConcurrentEffect[F[_]](implicitF:cats.effect.ConcurrentEffect[F]):F~&gt;monix.bio.Task" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">liftFromConcurrentEffect</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="https://typelevel.org/cats-effect/api/cats/effect/ConcurrentEffect.html#cats.effect.ConcurrentEffect" name="cats.effect.ConcurrentEffect" id="cats.effect.ConcurrentEffect" class="extype">ConcurrentEffect</a>[<span name="monix.bio.IO.liftFromConcurrentEffect.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="cats.~&gt;" class="extype">~&gt;</span>[<span name="monix.bio.IO.liftFromConcurrentEffect.F" class="extype">F</span>, <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>]</span></span><p class="shortcomment cmt">Returns a <code>F ~&gt; Task</code> (<code>FunctionK</code>) for transforming any
supported data-type, that implements <a href="https://typelevel.org/cats-effect/api/cats/effect/ConcurrentEffect.html" name="cats.effect.ConcurrentEffect" id="cats.effect.ConcurrentEffect" class="extype">cats.effect.ConcurrentEffect</a>,
into <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>F ~&gt; Task</code> (<code>FunctionK</code>) for transforming any
supported data-type, that implements <a href="https://typelevel.org/cats-effect/api/cats/effect/ConcurrentEffect.html" name="cats.effect.ConcurrentEffect" id="cats.effect.ConcurrentEffect" class="extype">cats.effect.ConcurrentEffect</a>,
into <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>.</p><p>Useful for <code>mapK</code> transformations, for example when working
with <code>Resource</code> or <code>Iterant</code>.</p><p>This is the less generic <a href="#liftFrom[F[_]](implicitF:monix.bio.IOLike[F]):F~&gt;monix.bio.Task" name="monix.bio.IO#liftFrom" id="monix.bio.IO#liftFrom" class="extmbr">liftFrom</a> operation, supplied
in order order to force the usage of
<a href="https://typelevel.org/cats-effect/typeclasses/concurrent-effect.html" target="_blank">ConcurrentEffect</a>
for where it matters.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#liftFromEffect" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="liftFromEffect[F[_]](implicitF:cats.effect.Effect[F]):F~&gt;monix.bio.Task" class="anchorToMember"></a><a id="liftFromEffect[F[_]](Effect[F]):~&gt;[F,Task]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#liftFromEffect[F[_]](implicitF:cats.effect.Effect[F]):F~&gt;monix.bio.Task" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">liftFromEffect</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="https://typelevel.org/cats-effect/api/cats/effect/Effect.html#cats.effect.Effect" name="cats.effect.Effect" id="cats.effect.Effect" class="extype">Effect</a>[<span name="monix.bio.IO.liftFromEffect.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="cats.~&gt;" class="extype">~&gt;</span>[<span name="monix.bio.IO.liftFromEffect.F" class="extype">F</span>, <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>]</span></span><p class="shortcomment cmt">Returns a <code>F ~&gt; Task</code> (<code>FunctionK</code>) for transforming any
supported data-type, that implements <code>Effect</code>, into <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>F ~&gt; Task</code> (<code>FunctionK</code>) for transforming any
supported data-type, that implements <code>Effect</code>, into <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>.</p><p>Useful for <code>mapK</code> transformations, for example when working
with <code>Resource</code> or <code>Iterant</code>.</p><p>This is the less generic <a href="#liftFrom[F[_]](implicitF:monix.bio.IOLike[F]):F~&gt;monix.bio.Task" name="monix.bio.IO#liftFrom" id="monix.bio.IO#liftFrom" class="extmbr">liftFrom</a> operation, supplied
in order order to force the usage of
<a href="https://typelevel.org/cats-effect/typeclasses/effect.html" target="_blank">Effect</a>
for where it matters.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#liftTo" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="liftTo[F[_]](implicitF:monix.bio.IOLift[F]):monix.bio.Task~&gt;F" class="anchorToMember"></a><a id="liftTo[F[_]](IOLift[F]):~&gt;[Task,F]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#liftTo[F[_]](implicitF:monix.bio.IOLift[F]):monix.bio.Task~&gt;F" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">liftTo</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="IOLift.html" name="monix.bio.IOLift" id="monix.bio.IOLift" class="extype">IOLift</a>[<span name="monix.bio.IO.liftTo.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="cats.~&gt;" class="extype">~&gt;</span>[<a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>, <span name="monix.bio.IO.liftTo.F" class="extype">F</span>]</span></span><p class="shortcomment cmt">Generates <code>cats.FunctionK</code> values for converting from <code>Task</code> to
supporting types (for which we have a <a href="IOLift.html" name="monix.bio.IOLift" id="monix.bio.IOLift" class="extype">IOLift</a> instance).</p><div class="fullcomment"><div class="comment cmt"><p>Generates <code>cats.FunctionK</code> values for converting from <code>Task</code> to
supporting types (for which we have a <a href="IOLift.html" name="monix.bio.IOLift" id="monix.bio.IOLift" class="extype">IOLift</a> instance).</p><p>See <a href="http://typelevel.org/cats/api/cats/arrow/FunctionK.html" name="cats.arrow.FunctionK" id="cats.arrow.FunctionK" class="extype">https://typelevel.org/cats/datatypes/functionk.html</a>.</p><pre><span class="kw">import</span> cats.effect.{IO <span class="kw">=&gt;</span> CIO, _}
<span class="kw">import</span> monix.bio._
<span class="kw">import</span> java.io._

<span class="cmt">// Needed for converting from Task to something else, because we need</span>
<span class="cmt">// ConcurrentEffect[Task] capabilities, also provided by [[BIOApp]]</span>
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="kw">def</span> open(file: File) =
  Resource[Task, InputStream](Task {
    <span class="kw">val</span> in = <span class="kw">new</span> FileInputStream(file)
    (in, Task(in.close()))
  })

<span class="cmt">// Lifting to a Resource of cats.effect.IO</span>
<span class="kw">val</span> res: Resource[CIO, InputStream] =
  open(<span class="kw">new</span> File(<span class="lit">"sample"</span>)).mapK(Task.liftTo[CIO])

<span class="cmt">// This was needed in order to process the resource</span>
<span class="cmt">// with a Task, instead of a Coeval</span>
res.use { in <span class="kw">=&gt;</span>
  CIO {
    in.read()
  }
}</pre></div></div></li><li class="indented0 " name="monix.bio.IO#liftToAsync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="liftToAsync[F[_]](implicitF:cats.effect.Async[F],impliciteff:cats.effect.Effect[monix.bio.Task]):monix.bio.Task~&gt;F" class="anchorToMember"></a><a id="liftToAsync[F[_]](cats.effect.Async[F],Effect[Task]):~&gt;[Task,F]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#liftToAsync[F[_]](implicitF:cats.effect.Async[F],impliciteff:cats.effect.Effect[monix.bio.Task]):monix.bio.Task~&gt;F" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">liftToAsync</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="https://typelevel.org/cats-effect/api/cats/effect/Async.html#cats.effect.Async" name="cats.effect.Async" id="cats.effect.Async" class="extype">cats.effect.Async</a>[<span name="monix.bio.IO.liftToAsync.F" class="extype">F</span>]</span>, <span name="eff">eff: <a href="https://typelevel.org/cats-effect/api/cats/effect/Effect.html#cats.effect.Effect" name="cats.effect.Effect" id="cats.effect.Effect" class="extype">Effect</a>[<a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>]</span>)</span><span class="result">: <span name="cats.~&gt;" class="extype">~&gt;</span>[<a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>, <span name="monix.bio.IO.liftToAsync.F" class="extype">F</span>]</span></span><p class="shortcomment cmt">Generates <code>cats.FunctionK</code> values for converting from <code>Task</code> to
supporting types (for which we have a <code>cats.effect.Async</code>) instance.</p><div class="fullcomment"><div class="comment cmt"><p>Generates <code>cats.FunctionK</code> values for converting from <code>Task</code> to
supporting types (for which we have a <code>cats.effect.Async</code>) instance.</p><p>See <a href="https://typelevel.org/cats/datatypes/functionk.html" target="_blank">https://typelevel.org/cats/datatypes/functionk.html</a>.</p><p>Prefer to use <a href="#liftTo[F[_]](implicitF:monix.bio.IOLift[F]):monix.bio.Task~&gt;F" name="monix.bio.IO#liftTo" id="monix.bio.IO#liftTo" class="extmbr">liftTo</a>, this alternative is provided in order to force
the usage of <code>cats.effect.Async</code>, since <a href="IOLift.html" name="monix.bio.IOLift" id="monix.bio.IOLift" class="extype">IOLift</a> is lawless.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#liftToConcurrent" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="liftToConcurrent[F[_]](implicitF:cats.effect.Concurrent[F],impliciteff:cats.effect.ConcurrentEffect[monix.bio.Task]):monix.bio.Task~&gt;F" class="anchorToMember"></a><a id="liftToConcurrent[F[_]](Concurrent[F],ConcurrentEffect[Task]):~&gt;[Task,F]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#liftToConcurrent[F[_]](implicitF:cats.effect.Concurrent[F],impliciteff:cats.effect.ConcurrentEffect[monix.bio.Task]):monix.bio.Task~&gt;F" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">liftToConcurrent</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="https://typelevel.org/cats-effect/api/cats/effect/Concurrent.html#cats.effect.Concurrent" name="cats.effect.Concurrent" id="cats.effect.Concurrent" class="extype">Concurrent</a>[<span name="monix.bio.IO.liftToConcurrent.F" class="extype">F</span>]</span>, <span name="eff">eff: <a href="https://typelevel.org/cats-effect/api/cats/effect/ConcurrentEffect.html#cats.effect.ConcurrentEffect" name="cats.effect.ConcurrentEffect" id="cats.effect.ConcurrentEffect" class="extype">ConcurrentEffect</a>[<a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>]</span>)</span><span class="result">: <span name="cats.~&gt;" class="extype">~&gt;</span>[<a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>, <span name="monix.bio.IO.liftToConcurrent.F" class="extype">F</span>]</span></span><p class="shortcomment cmt">Generates <code>cats.FunctionK</code> values for converting from <code>Task</code> to
supporting types (for which we have a <a href="https://typelevel.org/cats-effect/api/cats/effect/Concurrent.html" name="cats.effect.Concurrent" id="cats.effect.Concurrent" class="extype">cats.effect.Concurrent</a>) instance.</p><div class="fullcomment"><div class="comment cmt"><p>Generates <code>cats.FunctionK</code> values for converting from <code>Task</code> to
supporting types (for which we have a <a href="https://typelevel.org/cats-effect/api/cats/effect/Concurrent.html" name="cats.effect.Concurrent" id="cats.effect.Concurrent" class="extype">cats.effect.Concurrent</a>) instance.</p><p>See <a href="https://typelevel.org/cats/datatypes/functionk.html" target="_blank">https://typelevel.org/cats/datatypes/functionk.html</a>.</p><p>Prefer to use <a href="#liftTo[F[_]](implicitF:monix.bio.IOLift[F]):monix.bio.Task~&gt;F" name="monix.bio.IO#liftTo" id="monix.bio.IO#liftTo" class="extmbr">liftTo</a>, this alternative is provided in order to force
the usage of <a href="https://typelevel.org/cats-effect/api/cats/effect/Concurrent.html" name="cats.effect.Concurrent" id="cats.effect.Concurrent" class="extype">cats.effect.Concurrent</a>, since <a href="IOLift.html" name="monix.bio.IOLift" id="monix.bio.IOLift" class="extype">IOLift</a> is lawless.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#map2" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="map2[E,A1,A2,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2])(f:(A1,A2)=&gt;R):monix.bio.IO[E,R]" class="anchorToMember"></a><a id="map2[E,A1,A2,R](IO[E,A1],IO[E,A2])((A1,A2)=&gt;R):IO[E,R]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#map2[E,A1,A2,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2])(f:(A1,A2)=&gt;R):monix.bio.IO[E,R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map2</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map2.E" class="extype">E</span>, <span name="monix.bio.IO.map2.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map2.E" class="extype">E</span>, <span name="monix.bio.IO.map2.A2" class="extype">A2</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.map2.A1" class="extype">A1</span>, <span name="monix.bio.IO.map2.A2" class="extype">A2</span>) =&gt; <span name="monix.bio.IO.map2.R" class="extype">R</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map2.E" class="extype">E</span>, <span name="monix.bio.IO.map2.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Pairs 2 <code>IO</code> values, applying the given mapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 2 <code>IO</code> values, applying the given mapping function.</p><p>Returns a new <code>IO</code> reference that completes with the result
of mapping that function to their successful results, or in
failure in case either of them fails.</p><p>This is a specialized <a href="#sequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#sequence" id="monix.bio.IO#sequence" class="extmbr">IO.sequence</a> operation and as such
the tasks are evaluated in order, one after another, the
operation being described in terms of <a href="IO.html#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.IO[E1,B]):monix.bio.IO[E1,B]" name="monix.bio.IO#flatMap" id="monix.bio.IO#flatMap" class="extmbr">.flatMap</a>.</p><pre><span class="kw">val</span> fa1 = IO(<span class="num">1</span>)
<span class="kw">val</span> fa2 = IO(<span class="num">2</span>)

<span class="cmt">// Yields Success(3)</span>
IO.map2(fa1, fa2) { (a, b) <span class="kw">=&gt;</span>
  a + b
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
IO.map2(fa1, IO.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>))) { (a, b: <span class="std">Int</span>) <span class="kw">=&gt;</span>
  a + b
}</pre></div></div></li><li class="indented0 " name="monix.bio.IO#map3" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="map3[E,A1,A2,A3,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3])(f:(A1,A2,A3)=&gt;R):monix.bio.IO[E,R]" class="anchorToMember"></a><a id="map3[E,A1,A2,A3,R](IO[E,A1],IO[E,A2],IO[E,A3])((A1,A2,A3)=&gt;R):IO[E,R]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#map3[E,A1,A2,A3,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3])(f:(A1,A2,A3)=&gt;R):monix.bio.IO[E,R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map3</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map3.E" class="extype">E</span>, <span name="monix.bio.IO.map3.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map3.E" class="extype">E</span>, <span name="monix.bio.IO.map3.A2" class="extype">A2</span>]</span>, <span name="fa3">fa3: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map3.E" class="extype">E</span>, <span name="monix.bio.IO.map3.A3" class="extype">A3</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.map3.A1" class="extype">A1</span>, <span name="monix.bio.IO.map3.A2" class="extype">A2</span>, <span name="monix.bio.IO.map3.A3" class="extype">A3</span>) =&gt; <span name="monix.bio.IO.map3.R" class="extype">R</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map3.E" class="extype">E</span>, <span name="monix.bio.IO.map3.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Pairs 3 <code>IO</code> values, applying the given mapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 3 <code>IO</code> values, applying the given mapping function.</p><p>Returns a new <code>IO</code> reference that completes with the result
of mapping that function to their successful results, or in
failure in case either of them fails.</p><p>This is a specialized <a href="#sequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#sequence" id="monix.bio.IO#sequence" class="extmbr">IO.sequence</a> operation and as such
the tasks are evaluated in order, one after another, the
operation being described in terms of <a href="IO.html#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.IO[E1,B]):monix.bio.IO[E1,B]" name="monix.bio.IO#flatMap" id="monix.bio.IO#flatMap" class="extmbr">.flatMap</a>.</p><pre><span class="kw">val</span> fa1 = IO(<span class="num">1</span>)
<span class="kw">val</span> fa2 = IO(<span class="num">2</span>)
<span class="kw">val</span> fa3 = IO(<span class="num">3</span>)

<span class="cmt">// Yields Success(6)</span>
IO.map3(fa1, fa2, fa3) { (a, b, c) <span class="kw">=&gt;</span>
  a + b + c
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
IO.map3(fa1, IO.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>)), fa3) { (a, b: <span class="std">Int</span>, c) <span class="kw">=&gt;</span>
  a + b + c
}</pre></div></div></li><li class="indented0 " name="monix.bio.IO#map4" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="map4[E,A1,A2,A3,A4,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4])(f:(A1,A2,A3,A4)=&gt;R):monix.bio.IO[E,R]" class="anchorToMember"></a><a id="map4[E,A1,A2,A3,A4,R](IO[E,A1],IO[E,A2],IO[E,A3],IO[E,A4])((A1,A2,A3,A4)=&gt;R):IO[E,R]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#map4[E,A1,A2,A3,A4,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4])(f:(A1,A2,A3,A4)=&gt;R):monix.bio.IO[E,R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map4</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map4.E" class="extype">E</span>, <span name="monix.bio.IO.map4.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map4.E" class="extype">E</span>, <span name="monix.bio.IO.map4.A2" class="extype">A2</span>]</span>, <span name="fa3">fa3: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map4.E" class="extype">E</span>, <span name="monix.bio.IO.map4.A3" class="extype">A3</span>]</span>, <span name="fa4">fa4: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map4.E" class="extype">E</span>, <span name="monix.bio.IO.map4.A4" class="extype">A4</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.map4.A1" class="extype">A1</span>, <span name="monix.bio.IO.map4.A2" class="extype">A2</span>, <span name="monix.bio.IO.map4.A3" class="extype">A3</span>, <span name="monix.bio.IO.map4.A4" class="extype">A4</span>) =&gt; <span name="monix.bio.IO.map4.R" class="extype">R</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map4.E" class="extype">E</span>, <span name="monix.bio.IO.map4.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Pairs 4 <code>IO</code> values, applying the given mapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 4 <code>IO</code> values, applying the given mapping function.</p><p>Returns a new <code>IO</code> reference that completes with the result
of mapping that function to their successful results, or in
failure in case either of them fails.</p><p>This is a specialized <a href="#sequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#sequence" id="monix.bio.IO#sequence" class="extmbr">IO.sequence</a> operation and as such
the tasks are evaluated in order, one after another, the
operation being described in terms of <a href="IO.html#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.IO[E1,B]):monix.bio.IO[E1,B]" name="monix.bio.IO#flatMap" id="monix.bio.IO#flatMap" class="extmbr">.flatMap</a>.</p><pre><span class="kw">val</span> fa1 = IO(<span class="num">1</span>)
<span class="kw">val</span> fa2 = IO(<span class="num">2</span>)
<span class="kw">val</span> fa3 = IO(<span class="num">3</span>)
<span class="kw">val</span> fa4 = IO(<span class="num">4</span>)

<span class="cmt">// Yields Success(10)</span>
IO.map4(fa1, fa2, fa3, fa4) { (a, b, c, d) <span class="kw">=&gt;</span>
  a + b + c + d
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
IO.map4(fa1, IO.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>)), fa3, fa4) {
  (a, b: <span class="std">Int</span>, c, d) <span class="kw">=&gt;</span> a + b + c + d
}</pre></div></div></li><li class="indented0 " name="monix.bio.IO#map5" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="map5[E,A1,A2,A3,A4,A5,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.bio.IO[E,R]" class="anchorToMember"></a><a id="map5[E,A1,A2,A3,A4,A5,R](IO[E,A1],IO[E,A2],IO[E,A3],IO[E,A4],IO[E,A5])((A1,A2,A3,A4,A5)=&gt;R):IO[E,R]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#map5[E,A1,A2,A3,A4,A5,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.bio.IO[E,R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map5</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="A5">A5</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map5.E" class="extype">E</span>, <span name="monix.bio.IO.map5.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map5.E" class="extype">E</span>, <span name="monix.bio.IO.map5.A2" class="extype">A2</span>]</span>, <span name="fa3">fa3: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map5.E" class="extype">E</span>, <span name="monix.bio.IO.map5.A3" class="extype">A3</span>]</span>, <span name="fa4">fa4: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map5.E" class="extype">E</span>, <span name="monix.bio.IO.map5.A4" class="extype">A4</span>]</span>, <span name="fa5">fa5: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map5.E" class="extype">E</span>, <span name="monix.bio.IO.map5.A5" class="extype">A5</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.map5.A1" class="extype">A1</span>, <span name="monix.bio.IO.map5.A2" class="extype">A2</span>, <span name="monix.bio.IO.map5.A3" class="extype">A3</span>, <span name="monix.bio.IO.map5.A4" class="extype">A4</span>, <span name="monix.bio.IO.map5.A5" class="extype">A5</span>) =&gt; <span name="monix.bio.IO.map5.R" class="extype">R</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map5.E" class="extype">E</span>, <span name="monix.bio.IO.map5.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Pairs 5 <code>IO</code> values, applying the given mapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 5 <code>IO</code> values, applying the given mapping function.</p><p>Returns a new <code>IO</code> reference that completes with the result
of mapping that function to their successful results, or in
failure in case either of them fails.</p><p>This is a specialized <a href="#sequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#sequence" id="monix.bio.IO#sequence" class="extmbr">IO.sequence</a> operation and as such
the tasks are evaluated in order, one after another, the
operation being described in terms of <a href="IO.html#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.IO[E1,B]):monix.bio.IO[E1,B]" name="monix.bio.IO#flatMap" id="monix.bio.IO#flatMap" class="extmbr">.flatMap</a>.</p><pre><span class="kw">val</span> fa1 = IO(<span class="num">1</span>)
<span class="kw">val</span> fa2 = IO(<span class="num">2</span>)
<span class="kw">val</span> fa3 = IO(<span class="num">3</span>)
<span class="kw">val</span> fa4 = IO(<span class="num">4</span>)
<span class="kw">val</span> fa5 = IO(<span class="num">5</span>)

<span class="cmt">// Yields Success(15)</span>
IO.map5(fa1, fa2, fa3, fa4, fa5) { (a, b, c, d, e) <span class="kw">=&gt;</span>
  a + b + c + d + e
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
IO.map5(fa1, IO.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>)), fa3, fa4, fa5) {
  (a, b: <span class="std">Int</span>, c, d, e) <span class="kw">=&gt;</span> a + b + c + d + e
}</pre></div></div></li><li class="indented0 " name="monix.bio.IO#map6" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="map6[E,A1,A2,A3,A4,A5,A6,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5],fa6:monix.bio.IO[E,A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.bio.IO[E,R]" class="anchorToMember"></a><a id="map6[E,A1,A2,A3,A4,A5,A6,R](IO[E,A1],IO[E,A2],IO[E,A3],IO[E,A4],IO[E,A5],IO[E,A6])((A1,A2,A3,A4,A5,A6)=&gt;R):IO[E,R]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#map6[E,A1,A2,A3,A4,A5,A6,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5],fa6:monix.bio.IO[E,A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.bio.IO[E,R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map6</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="A5">A5</span>, <span name="A6">A6</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map6.E" class="extype">E</span>, <span name="monix.bio.IO.map6.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map6.E" class="extype">E</span>, <span name="monix.bio.IO.map6.A2" class="extype">A2</span>]</span>, <span name="fa3">fa3: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map6.E" class="extype">E</span>, <span name="monix.bio.IO.map6.A3" class="extype">A3</span>]</span>, <span name="fa4">fa4: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map6.E" class="extype">E</span>, <span name="monix.bio.IO.map6.A4" class="extype">A4</span>]</span>, <span name="fa5">fa5: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map6.E" class="extype">E</span>, <span name="monix.bio.IO.map6.A5" class="extype">A5</span>]</span>, <span name="fa6">fa6: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map6.E" class="extype">E</span>, <span name="monix.bio.IO.map6.A6" class="extype">A6</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.map6.A1" class="extype">A1</span>, <span name="monix.bio.IO.map6.A2" class="extype">A2</span>, <span name="monix.bio.IO.map6.A3" class="extype">A3</span>, <span name="monix.bio.IO.map6.A4" class="extype">A4</span>, <span name="monix.bio.IO.map6.A5" class="extype">A5</span>, <span name="monix.bio.IO.map6.A6" class="extype">A6</span>) =&gt; <span name="monix.bio.IO.map6.R" class="extype">R</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.map6.E" class="extype">E</span>, <span name="monix.bio.IO.map6.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Pairs 6 <code>IO</code> values, applying the given mapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 6 <code>IO</code> values, applying the given mapping function.</p><p>Returns a new <code>IO</code> reference that completes with the result
of mapping that function to their successful results, or in
failure in case either of them fails.</p><p>This is a specialized <a href="#sequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#sequence" id="monix.bio.IO#sequence" class="extmbr">IO.sequence</a> operation and as such
the tasks are evaluated in order, one after another, the
operation being described in terms of <a href="IO.html#flatMap[E1&gt;:E,B](f:A=&gt;monix.bio.IO[E1,B]):monix.bio.IO[E1,B]" name="monix.bio.IO#flatMap" id="monix.bio.IO#flatMap" class="extmbr">.flatMap</a>.</p><pre><span class="kw">val</span> fa1 = IO(<span class="num">1</span>)
<span class="kw">val</span> fa2 = IO(<span class="num">2</span>)
<span class="kw">val</span> fa3 = IO(<span class="num">3</span>)
<span class="kw">val</span> fa4 = IO(<span class="num">4</span>)
<span class="kw">val</span> fa5 = IO(<span class="num">5</span>)
<span class="kw">val</span> fa6 = IO(<span class="num">6</span>)

<span class="cmt">// Yields Success(21)</span>
IO.map6(fa1, fa2, fa3, fa4, fa5, fa6) { (a, b, c, d, e, f) <span class="kw">=&gt;</span>
  a + b + c + d + e + f
}

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
IO.map6(fa1, IO.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>)), fa3, fa4, fa5, fa6) {
  (a, b: <span class="std">Int</span>, c, d, e, f) <span class="kw">=&gt;</span> a + b + c + d + e + f
}</pre></div></div></li><li class="indented0 " name="monix.bio.IO#mapBoth" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapBoth[E,A1,A2,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2])(f:(A1,A2)=&gt;R):monix.bio.IO[E,R]" class="anchorToMember"></a><a id="mapBoth[E,A1,A2,R](IO[E,A1],IO[E,A2])((A1,A2)=&gt;R):IO[E,R]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#mapBoth[E,A1,A2,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2])(f:(A1,A2)=&gt;R):monix.bio.IO[E,R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mapBoth</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.mapBoth.E" class="extype">E</span>, <span name="monix.bio.IO.mapBoth.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.mapBoth.E" class="extype">E</span>, <span name="monix.bio.IO.mapBoth.A2" class="extype">A2</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.mapBoth.A1" class="extype">A1</span>, <span name="monix.bio.IO.mapBoth.A2" class="extype">A2</span>) =&gt; <span name="monix.bio.IO.mapBoth.R" class="extype">R</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.mapBoth.E" class="extype">E</span>, <span name="monix.bio.IO.mapBoth.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Yields a task that on evaluation will process the given tasks
in parallel, then apply the given mapping function on their results.</p><div class="fullcomment"><div class="comment cmt"><p>Yields a task that on evaluation will process the given tasks
in parallel, then apply the given mapping function on their results.</p><p>Example:</p><pre><span class="kw">val</span> task1 = Task(<span class="num">1</span> + <span class="num">1</span>)
<span class="kw">val</span> task2 = Task(<span class="num">2</span> + <span class="num">2</span>)

<span class="cmt">// Yields 6</span>
Task.mapBoth(task1, task2)((a, b) <span class="kw">=&gt;</span> a + b)</pre><p>ADVICE: In a real life scenario the tasks should
                          be expensive in order to warrant parallel execution. Parallelism
                          doesn't magically speed up the code - it's usually fine for I/O-bound
                          tasks, however for CPU-bound tasks it can make things worse.
                          Performance improvements need to be verified.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.
</p></div></div></li><li class="indented0 " name="monix.bio.TaskInstancesLevel2#monadError" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monadError[E]:monix.bio.instances.CatsBaseForTask[E]" class="anchorToMember"></a><a id="monadError[E]:CatsBaseForTask[E]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#monadError[E]:monix.bio.instances.CatsBaseForTask[E]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">monadError</span><span class="tparams">[<span name="E">E</span>]</span><span class="result">: <a href="instances/CatsBaseForTask.html" name="monix.bio.instances.CatsBaseForTask" id="monix.bio.instances.CatsBaseForTask" class="extype">CatsBaseForTask</a>[<span name="monix.bio.TaskInstancesLevel2.monadError.E" class="extype">E</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskInstancesLevel2</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean" class="anchorToMember"></a><a id="ne(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.6/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="monix.bio.IO#never" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="never[A]:monix.bio.UIO[A]" class="anchorToMember"></a><a id="never[A]:UIO[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#never[A]:monix.bio.UIO[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">never</span><span class="tparams">[<span name="A">A</span>]</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="monix.bio.IO.never.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">A <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a> instance that upon evaluation will never complete.</p></li><li class="indented0 " name="monix.bio.IO#none" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="none[A]:monix.bio.UIO[Option[A]]" class="anchorToMember"></a><a id="none[A]:UIO[Option[A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#none[A]:monix.bio.UIO[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">none</span><span class="tparams">[<span name="A">A</span>]</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.6/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.bio.IO.none.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Returns an <code>IO</code> that on execution is always successful, emitting None.</p></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.IO#now" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="now[A](a:A):monix.bio.UIO[A]" class="anchorToMember"></a><a id="now[A](A):UIO[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#now[A](a:A):monix.bio.UIO[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">now</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: <span name="monix.bio.IO.now.A" class="extype">A</span></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="monix.bio.IO.now.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a <code>IO</code> that on execution is always successful, emitting
the given strict value.</p></li><li class="indented0 " name="monix.bio.IO#parMap2" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parMap2[E,A1,A2,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2])(f:(A1,A2)=&gt;R):monix.bio.IO[E,R]" class="anchorToMember"></a><a id="parMap2[E,A1,A2,R](IO[E,A1],IO[E,A2])((A1,A2)=&gt;R):IO[E,R]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parMap2[E,A1,A2,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2])(f:(A1,A2)=&gt;R):monix.bio.IO[E,R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parMap2</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap2.E" class="extype">E</span>, <span name="monix.bio.IO.parMap2.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap2.E" class="extype">E</span>, <span name="monix.bio.IO.parMap2.A2" class="extype">A2</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.parMap2.A1" class="extype">A1</span>, <span name="monix.bio.IO.parMap2.A2" class="extype">A2</span>) =&gt; <span name="monix.bio.IO.parMap2.R" class="extype">R</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap2.E" class="extype">E</span>, <span name="monix.bio.IO.parMap2.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Pairs 2 <code>IO</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 2 <code>IO</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel.</p><p>This is a specialized <a href="#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">IO.parSequence</a> operation and as such
the tasks are evaluated in parallel, ordering the results.
In case one of the tasks fails, then all other tasks get
cancelled and the final result will be a failure.</p><pre><span class="kw">val</span> fa1 = UIO(<span class="num">1</span>)
<span class="kw">val</span> fa2 = UIO(<span class="num">2</span>)

<span class="cmt">// Yields Success(3)</span>
IO.parMap2(fa1, fa2) { (a, b) <span class="kw">=&gt;</span>
  a + b
}

<span class="kw">val</span> ex: Task[<span class="std">Int</span>] = IO.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>))

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
IO.parMap2(fa1, ex) { (a, b) <span class="kw">=&gt;</span>
  a + b
}</pre><p>ADVICE: In a real life scenario the tasks should
                          be expensive in order to warrant parallel execution. Parallelism
                          doesn't magically speed up the code - it's usually fine for I/O-bound
                          tasks, however for CPU-bound tasks it can make things worse.
                          Performance improvements need to be verified.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.</p><p>See <a href="#map2[E,A1,A2,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2])(f:(A1,A2)=&gt;R):monix.bio.IO[E,R]" name="monix.bio.IO#map2" id="monix.bio.IO#map2" class="extmbr">IO.map2</a> for sequential processing.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#parMap3" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parMap3[E,A1,A2,A3,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3])(f:(A1,A2,A3)=&gt;R):monix.bio.IO[E,R]" class="anchorToMember"></a><a id="parMap3[E,A1,A2,A3,R](IO[E,A1],IO[E,A2],IO[E,A3])((A1,A2,A3)=&gt;R):IO[E,R]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parMap3[E,A1,A2,A3,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3])(f:(A1,A2,A3)=&gt;R):monix.bio.IO[E,R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parMap3</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap3.E" class="extype">E</span>, <span name="monix.bio.IO.parMap3.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap3.E" class="extype">E</span>, <span name="monix.bio.IO.parMap3.A2" class="extype">A2</span>]</span>, <span name="fa3">fa3: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap3.E" class="extype">E</span>, <span name="monix.bio.IO.parMap3.A3" class="extype">A3</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.parMap3.A1" class="extype">A1</span>, <span name="monix.bio.IO.parMap3.A2" class="extype">A2</span>, <span name="monix.bio.IO.parMap3.A3" class="extype">A3</span>) =&gt; <span name="monix.bio.IO.parMap3.R" class="extype">R</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap3.E" class="extype">E</span>, <span name="monix.bio.IO.parMap3.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Pairs 3 <code>IO</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 3 <code>IO</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel.</p><p>This is a specialized <a href="#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">IO.parSequence</a> operation and as such
the tasks are evaluated in parallel, ordering the results.
In case one of the tasks fails, then all other tasks get
cancelled and the final result will be a failure.</p><pre><span class="kw">val</span> fa1 = UIO(<span class="num">1</span>)
<span class="kw">val</span> fa2 = UIO(<span class="num">2</span>)
<span class="kw">val</span> fa3 = UIO(<span class="num">3</span>)

<span class="cmt">// Yields Success(6)</span>
IO.parMap3(fa1, fa2, fa3) { (a, b, c) <span class="kw">=&gt;</span>
  a + b + c
}

<span class="kw">val</span> ex: Task[<span class="std">Int</span>] = IO.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>))

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
IO.parMap3(fa1, ex, fa3) { (a, b, c) <span class="kw">=&gt;</span>
  a + b + c
}</pre><p>ADVICE: In a real life scenario the tasks should
                          be expensive in order to warrant parallel execution. Parallelism
                          doesn't magically speed up the code - it's usually fine for I/O-bound
                          tasks, however for CPU-bound tasks it can make things worse.
                          Performance improvements need to be verified.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.</p><p>See <a href="#map3[E,A1,A2,A3,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3])(f:(A1,A2,A3)=&gt;R):monix.bio.IO[E,R]" name="monix.bio.IO#map3" id="monix.bio.IO#map3" class="extmbr">IO.map3</a> for sequential processing.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#parMap4" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parMap4[E,A1,A2,A3,A4,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4])(f:(A1,A2,A3,A4)=&gt;R):monix.bio.IO[E,R]" class="anchorToMember"></a><a id="parMap4[E,A1,A2,A3,A4,R](IO[E,A1],IO[E,A2],IO[E,A3],IO[E,A4])((A1,A2,A3,A4)=&gt;R):IO[E,R]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parMap4[E,A1,A2,A3,A4,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4])(f:(A1,A2,A3,A4)=&gt;R):monix.bio.IO[E,R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parMap4</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap4.E" class="extype">E</span>, <span name="monix.bio.IO.parMap4.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap4.E" class="extype">E</span>, <span name="monix.bio.IO.parMap4.A2" class="extype">A2</span>]</span>, <span name="fa3">fa3: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap4.E" class="extype">E</span>, <span name="monix.bio.IO.parMap4.A3" class="extype">A3</span>]</span>, <span name="fa4">fa4: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap4.E" class="extype">E</span>, <span name="monix.bio.IO.parMap4.A4" class="extype">A4</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.parMap4.A1" class="extype">A1</span>, <span name="monix.bio.IO.parMap4.A2" class="extype">A2</span>, <span name="monix.bio.IO.parMap4.A3" class="extype">A3</span>, <span name="monix.bio.IO.parMap4.A4" class="extype">A4</span>) =&gt; <span name="monix.bio.IO.parMap4.R" class="extype">R</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap4.E" class="extype">E</span>, <span name="monix.bio.IO.parMap4.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Pairs 4 <code>IO</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 4 <code>IO</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><p>This is a specialized <a href="#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">IO.parSequence</a> operation and as such
the tasks are evaluated in parallel, ordering the results.
In case one of the tasks fails, then all other tasks get
cancelled and the final result will be a failure.</p><pre><span class="kw">val</span> fa1 = UIO(<span class="num">1</span>)
<span class="kw">val</span> fa2 = UIO(<span class="num">2</span>)
<span class="kw">val</span> fa3 = UIO(<span class="num">3</span>)
<span class="kw">val</span> fa4 = UIO(<span class="num">4</span>)

<span class="cmt">// Yields Success(10)</span>
IO.parMap4(fa1, fa2, fa3, fa4) { (a, b, c, d) <span class="kw">=&gt;</span>
  a + b + c + d
}

<span class="kw">val</span> ex: Task[<span class="std">Int</span>] = IO.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>))

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
IO.parMap4(fa1, ex, fa3, fa4) {
  (a, b, c, d) <span class="kw">=&gt;</span> a + b + c + d
}</pre><p>ADVICE: In a real life scenario the tasks should
                          be expensive in order to warrant parallel execution. Parallelism
                          doesn't magically speed up the code - it's usually fine for I/O-bound
                          tasks, however for CPU-bound tasks it can make things worse.
                          Performance improvements need to be verified.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.</p><p>See <a href="#map4[E,A1,A2,A3,A4,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4])(f:(A1,A2,A3,A4)=&gt;R):monix.bio.IO[E,R]" name="monix.bio.IO#map4" id="monix.bio.IO#map4" class="extmbr">IO.map4</a> for sequential processing.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#parMap5" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parMap5[E,A1,A2,A3,A4,A5,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.bio.IO[E,R]" class="anchorToMember"></a><a id="parMap5[E,A1,A2,A3,A4,A5,R](IO[E,A1],IO[E,A2],IO[E,A3],IO[E,A4],IO[E,A5])((A1,A2,A3,A4,A5)=&gt;R):IO[E,R]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parMap5[E,A1,A2,A3,A4,A5,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.bio.IO[E,R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parMap5</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="A5">A5</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap5.E" class="extype">E</span>, <span name="monix.bio.IO.parMap5.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap5.E" class="extype">E</span>, <span name="monix.bio.IO.parMap5.A2" class="extype">A2</span>]</span>, <span name="fa3">fa3: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap5.E" class="extype">E</span>, <span name="monix.bio.IO.parMap5.A3" class="extype">A3</span>]</span>, <span name="fa4">fa4: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap5.E" class="extype">E</span>, <span name="monix.bio.IO.parMap5.A4" class="extype">A4</span>]</span>, <span name="fa5">fa5: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap5.E" class="extype">E</span>, <span name="monix.bio.IO.parMap5.A5" class="extype">A5</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.parMap5.A1" class="extype">A1</span>, <span name="monix.bio.IO.parMap5.A2" class="extype">A2</span>, <span name="monix.bio.IO.parMap5.A3" class="extype">A3</span>, <span name="monix.bio.IO.parMap5.A4" class="extype">A4</span>, <span name="monix.bio.IO.parMap5.A5" class="extype">A5</span>) =&gt; <span name="monix.bio.IO.parMap5.R" class="extype">R</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap5.E" class="extype">E</span>, <span name="monix.bio.IO.parMap5.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Pairs 5 <code>IO</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 5 <code>IO</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><p>This is a specialized <a href="#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">IO.parSequence</a> operation and as such
the tasks are evaluated in parallel, ordering the results.
In case one of the tasks fails, then all other tasks get
cancelled and the final result will be a failure.</p><pre><span class="kw">val</span> fa1 = UIO(<span class="num">1</span>)
<span class="kw">val</span> fa2 = UIO(<span class="num">2</span>)
<span class="kw">val</span> fa3 = UIO(<span class="num">3</span>)
<span class="kw">val</span> fa4 = UIO(<span class="num">4</span>)
<span class="kw">val</span> fa5 = UIO(<span class="num">5</span>)

<span class="cmt">// Yields Success(15)</span>
IO.parMap5(fa1, fa2, fa3, fa4, fa5) { (a, b, c, d, e) <span class="kw">=&gt;</span>
  a + b + c + d + e
}

<span class="kw">val</span> ex: Task[<span class="std">Int</span>] = IO.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>))

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
IO.parMap5(fa1, ex, fa3, fa4, fa5) {
  (a, b, c, d, e) <span class="kw">=&gt;</span> a + b + c + d + e
}</pre><p>ADVICE: In a real life scenario the tasks should
                          be expensive in order to warrant parallel execution. Parallelism
                          doesn't magically speed up the code - it's usually fine for I/O-bound
                          tasks, however for CPU-bound tasks it can make things worse.
                          Performance improvements need to be verified.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.</p><p>See <a href="#map5[E,A1,A2,A3,A4,A5,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.bio.IO[E,R]" name="monix.bio.IO#map5" id="monix.bio.IO#map5" class="extmbr">IO.map5</a> for sequential processing.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#parMap6" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parMap6[E,A1,A2,A3,A4,A5,A6,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5],fa6:monix.bio.IO[E,A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.bio.IO[E,R]" class="anchorToMember"></a><a id="parMap6[E,A1,A2,A3,A4,A5,A6,R](IO[E,A1],IO[E,A2],IO[E,A3],IO[E,A4],IO[E,A5],IO[E,A6])((A1,A2,A3,A4,A5,A6)=&gt;R):IO[E,R]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parMap6[E,A1,A2,A3,A4,A5,A6,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5],fa6:monix.bio.IO[E,A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.bio.IO[E,R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parMap6</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="A5">A5</span>, <span name="A6">A6</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap6.E" class="extype">E</span>, <span name="monix.bio.IO.parMap6.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap6.E" class="extype">E</span>, <span name="monix.bio.IO.parMap6.A2" class="extype">A2</span>]</span>, <span name="fa3">fa3: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap6.E" class="extype">E</span>, <span name="monix.bio.IO.parMap6.A3" class="extype">A3</span>]</span>, <span name="fa4">fa4: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap6.E" class="extype">E</span>, <span name="monix.bio.IO.parMap6.A4" class="extype">A4</span>]</span>, <span name="fa5">fa5: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap6.E" class="extype">E</span>, <span name="monix.bio.IO.parMap6.A5" class="extype">A5</span>]</span>, <span name="fa6">fa6: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap6.E" class="extype">E</span>, <span name="monix.bio.IO.parMap6.A6" class="extype">A6</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.parMap6.A1" class="extype">A1</span>, <span name="monix.bio.IO.parMap6.A2" class="extype">A2</span>, <span name="monix.bio.IO.parMap6.A3" class="extype">A3</span>, <span name="monix.bio.IO.parMap6.A4" class="extype">A4</span>, <span name="monix.bio.IO.parMap6.A5" class="extype">A5</span>, <span name="monix.bio.IO.parMap6.A6" class="extype">A6</span>) =&gt; <span name="monix.bio.IO.parMap6.R" class="extype">R</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parMap6.E" class="extype">E</span>, <span name="monix.bio.IO.parMap6.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Pairs 6 <code>IO</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><div class="fullcomment"><div class="comment cmt"><p>Pairs 6 <code>IO</code> values, applying the given mapping function,
ordering the results, but not the side effects, the evaluation
being done in parallel if the tasks are async.</p><p>This is a specialized <a href="#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">IO.parSequence</a> operation and as such
the tasks are evaluated in parallel, ordering the results.
In case one of the tasks fails, then all other tasks get
cancelled and the final result will be a failure.</p><pre><span class="kw">val</span> fa1 = UIO(<span class="num">1</span>)
<span class="kw">val</span> fa2 = UIO(<span class="num">2</span>)
<span class="kw">val</span> fa3 = UIO(<span class="num">3</span>)
<span class="kw">val</span> fa4 = UIO(<span class="num">4</span>)
<span class="kw">val</span> fa5 = UIO(<span class="num">5</span>)
<span class="kw">val</span> fa6 = UIO(<span class="num">6</span>)

<span class="cmt">// Yields Success(21)</span>
IO.parMap6(fa1, fa2, fa3, fa4, fa5, fa6) { (a, b, c, d, e, f) <span class="kw">=&gt;</span>
  a + b + c + d + e + f
}

<span class="kw">val</span> ex: Task[<span class="std">Int</span>] = IO.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>))

<span class="cmt">// Yields Failure(e), because the second arg is a failure</span>
IO.parMap6(fa1, ex, fa3, fa4, fa5, fa6) {
  (a, b, c, d, e, f) <span class="kw">=&gt;</span> a + b + c + d + e + f
}</pre><p>ADVICE: In a real life scenario the tasks should
                          be expensive in order to warrant parallel execution. Parallelism
                          doesn't magically speed up the code - it's usually fine for I/O-bound
                          tasks, however for CPU-bound tasks it can make things worse.
                          Performance improvements need to be verified.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.</p><p>See <a href="#map6[E,A1,A2,A3,A4,A5,A6,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5],fa6:monix.bio.IO[E,A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.bio.IO[E,R]" name="monix.bio.IO#map6" id="monix.bio.IO#map6" class="extmbr">IO.map6</a> for sequential processing.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#parSequence" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" class="anchorToMember"></a><a id="parSequence[E,A](Iterable[IO[E,A]]):IO[E,List[A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parSequence</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parSequence.E" class="extype">E</span>, <span name="monix.bio.IO.parSequence.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parSequence.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.IO.parSequence.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Executes the given sequence of tasks in parallel, non-deterministically
gathering their results, returning a task that will signal the sequence
of results once all tasks are finished.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given sequence of tasks in parallel, non-deterministically
gathering their results, returning a task that will signal the sequence
of results once all tasks are finished.</p><p>This function is the nondeterministic analogue of <code>sequence</code> and should
behave identically to <code>sequence</code> so long as there is no interaction between
the effects being gathered. However, unlike <code>sequence</code>, which decides on
a total order of effects, the effects in a <code>parSequence</code> are unordered with
respect to each other, the tasks being execute in parallel, not in sequence.</p><p>Although the effects are unordered, we ensure the order of results
matches the order of the input sequence. Also see <a href="#parSequenceUnordered[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequenceUnordered" id="monix.bio.IO#parSequenceUnordered" class="extmbr">parSequenceUnordered</a>
for the more efficient alternative.</p><p>Example:</p><pre><span class="kw">val</span> tasks = <span class="std">List</span>(Task(<span class="num">1</span> + <span class="num">1</span>), Task(<span class="num">2</span> + <span class="num">2</span>), Task(<span class="num">3</span> + <span class="num">3</span>))

<span class="cmt">// Yields 2, 4, 6</span>
Task.parSequence(tasks)</pre><p>ADVICE: In a real life scenario the tasks should
                          be expensive in order to warrant parallel execution. Parallelism
                          doesn't magically speed up the code - it's usually fine for I/O-bound
                          tasks, however for CPU-bound tasks it can make things worse.
                          Performance improvements need to be verified.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#parSequenceN[E,A](parallelism:Int)(in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequenceN" id="monix.bio.IO#parSequenceN" class="extmbr">parSequenceN</a> for a version that limits parallelism.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#parSequenceN" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parSequenceN[E,A](parallelism:Int)(in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" class="anchorToMember"></a><a id="parSequenceN[E,A](Int)(Iterable[IO[E,A]]):IO[E,List[A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parSequenceN[E,A](parallelism:Int)(in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parSequenceN</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="parallelism">parallelism: <a href="https://www.scala-lang.org/api/2.13.6/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parSequenceN.E" class="extype">E</span>, <span name="monix.bio.IO.parSequenceN.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parSequenceN.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.IO.parSequenceN.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Executes the given sequence of tasks in parallel, non-deterministically
gathering their results, returning a task that will signal the sequence
of results once all tasks are finished.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given sequence of tasks in parallel, non-deterministically
gathering their results, returning a task that will signal the sequence
of results once all tasks are finished.</p><p>Implementation ensure there are at most <code>n</code> (= <code>parallelism</code> parameter) tasks
running concurrently and the results are returned in order.</p><p>Example:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="kw">val</span> tasks = <span class="std">List</span>(
  Task(<span class="num">1</span> + <span class="num">1</span>).delayExecution(<span class="num">1.</span>second),
  Task(<span class="num">2</span> + <span class="num">2</span>).delayExecution(<span class="num">2.</span>second),
  Task(<span class="num">3</span> + <span class="num">3</span>).delayExecution(<span class="num">3.</span>second),
  Task(<span class="num">4</span> + <span class="num">4</span>).delayExecution(<span class="num">4.</span>second)
 )

<span class="cmt">// Yields 2, 4, 6, 8 after around 6 seconds</span>
Task.parSequenceN(<span class="num">2</span>)(tasks)</pre><p>ADVICE: In a real life scenario the tasks should
                          be expensive in order to warrant parallel execution. Parallelism
                          doesn't magically speed up the code - it's usually fine for I/O-bound
                          tasks, however for CPU-bound tasks it can make things worse.
                          Performance improvements need to be verified.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">parSequence</a> for a version that does not limit parallelism.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#parSequenceUnordered" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parSequenceUnordered[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" class="anchorToMember"></a><a id="parSequenceUnordered[E,A](Iterable[IO[E,A]]):IO[E,List[A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parSequenceUnordered[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parSequenceUnordered</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parSequenceUnordered.E" class="extype">E</span>, <span name="monix.bio.IO.parSequenceUnordered.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parSequenceUnordered.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.IO.parSequenceUnordered.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Processes the given collection of tasks in parallel and
nondeterministically gather the results without keeping the original
ordering of the given tasks.</p><div class="fullcomment"><div class="comment cmt"><p>Processes the given collection of tasks in parallel and
nondeterministically gather the results without keeping the original
ordering of the given tasks.</p><p>This function is similar to <a href="#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">parSequence</a>, but neither the effects nor the
results will be ordered. Useful when you don't need ordering because:</p><ul><li>it has non-blocking behavior (but not wait-free)</li><li>it can be more efficient (compared with <a href="#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">parSequence</a>), but not
   necessarily (if you care about performance, then test)</li></ul><p>Example:</p><pre><span class="kw">val</span> tasks = <span class="std">List</span>(Task(<span class="num">1</span> + <span class="num">1</span>), Task(<span class="num">2</span> + <span class="num">2</span>), Task(<span class="num">3</span> + <span class="num">3</span>))

<span class="cmt">// Yields 2, 4, 6 (but order is NOT guaranteed)</span>
Task.parSequenceUnordered(tasks)</pre><p>ADVICE: In a real life scenario the tasks should
                          be expensive in order to warrant parallel execution. Parallelism
                          doesn't magically speed up the code - it's usually fine for I/O-bound
                          tasks, however for CPU-bound tasks it can make things worse.
                          Performance improvements need to be verified.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.
</p></div><dl class="paramcmts block"><dt class="param">in</dt><dd class="cmt"><p>is a list of tasks to execute</p></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#parTraverse" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parTraverse[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" class="anchorToMember"></a><a id="parTraverse[E,A,B](Iterable[A])((A)=&gt;IO[E,B]):IO[E,List[B]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parTraverse[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parTraverse</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<span name="monix.bio.IO.parTraverse.A" class="extype">A</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.parTraverse.A" class="extype">A</span>) =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parTraverse.E" class="extype">E</span>, <span name="monix.bio.IO.parTraverse.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parTraverse.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.IO.parTraverse.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">Given a <code>Iterable[A]</code> and a function <code>A =&gt; IO[E, B]</code>,
nondeterministically apply the function to each element of the collection
and return a task that will signal a collection of the results once all
tasks are finished.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <code>Iterable[A]</code> and a function <code>A =&gt; IO[E, B]</code>,
nondeterministically apply the function to each element of the collection
and return a task that will signal a collection of the results once all
tasks are finished.</p><p>This function is the nondeterministic analogue of <code>traverse</code> and should
behave identically to <code>traverse</code> so long as there is no interaction between
the effects being gathered. However, unlike <code>traverse</code>, which decides on
a total order of effects, the effects in a <code>parTraverse</code> are unordered with
respect to each other.</p><p>Although the effects are unordered, we ensure the order of results
matches the order of the input sequence. Also see <a href="#parTraverseUnordered[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" name="monix.bio.IO#parTraverseUnordered" id="monix.bio.IO#parTraverseUnordered" class="extmbr">parTraverseUnordered</a>
for the more efficient alternative.</p><p>It's a generalized version of <a href="#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">parSequence</a>.</p><p>ADVICE: In a real life scenario the tasks should
                          be expensive in order to warrant parallel execution. Parallelism
                          doesn't magically speed up the code - it's usually fine for I/O-bound
                          tasks, however for CPU-bound tasks it can make things worse.
                          Performance improvements need to be verified.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#parTraverseN[E,A,B](parallelism:Int)(in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" name="monix.bio.IO#parTraverseN" id="monix.bio.IO#parTraverseN" class="extmbr">parTraverseN</a> for a version that limits parallelism.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#parTraverseN" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parTraverseN[E,A,B](parallelism:Int)(in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" class="anchorToMember"></a><a id="parTraverseN[E,A,B](Int)(Iterable[A])((A)=&gt;IO[E,B]):IO[E,List[B]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parTraverseN[E,A,B](parallelism:Int)(in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parTraverseN</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="parallelism">parallelism: <a href="https://www.scala-lang.org/api/2.13.6/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<span name="monix.bio.IO.parTraverseN.A" class="extype">A</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.parTraverseN.A" class="extype">A</span>) =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parTraverseN.E" class="extype">E</span>, <span name="monix.bio.IO.parTraverseN.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parTraverseN.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.IO.parTraverseN.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">Applies the provided function in a non-deterministic way to each element
of the input collection.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the provided function in a non-deterministic way to each element
of the input collection. The result will be signalled once all tasks
are finished with a success, or as soon as some task finishes with a
typed or terminal error.</p><p>Note that his method has a fail-fast semantics: as soon as one of the tasks
fails (either in a typed or terminal manner), no subsequent tasks will be
executed and they will be cancelled.</p><p>The final result will be a collection of success values, or a typed/fatal
error if at least one of the tasks finished without a success.</p><p>This method allows specifying the parallelism level of the execution, i.e.
the maximum number of how many tasks should be running concurrently.</p><p>Although the execution of the effects is unordered and non-deterministic,
the collection of results will preserve the order of the input collection.</p><p>Example:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="kw">val</span> numbers = <span class="std">List</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)

<span class="cmt">// Yields 2, 4, 6, 8 after around 6 seconds</span>
IO.parTraverseN(<span class="num">2</span>)(numbers)(n <span class="kw">=&gt;</span> IO(n + n).delayExecution(n.second))</pre><p>ADVICE: In a real life scenario the tasks should
                          be expensive in order to warrant parallel execution. Parallelism
                          doesn't magically speed up the code - it's usually fine for I/O-bound
                          tasks, however for CPU-bound tasks it can make things worse.
                          Performance improvements need to be verified.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#parTraverse[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" name="monix.bio.IO#parTraverse" id="monix.bio.IO#parTraverse" class="extmbr">parTraverse</a> for a version that does not limit parallelism.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#parTraverseUnordered" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parTraverseUnordered[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" class="anchorToMember"></a><a id="parTraverseUnordered[E,A,B](Iterable[A])((A)=&gt;IO[E,B]):IO[E,List[B]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parTraverseUnordered[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parTraverseUnordered</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<span name="monix.bio.IO.parTraverseUnordered.A" class="extype">A</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.parTraverseUnordered.A" class="extype">A</span>) =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parTraverseUnordered.E" class="extype">E</span>, <span name="monix.bio.IO.parTraverseUnordered.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parTraverseUnordered.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.IO.parTraverseUnordered.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">Given a <code>Iterable[A]</code> and a function <code>A =&gt; IO[E, B]</code>,
nondeterministically apply the function to each element of the collection
without keeping the original ordering of the results.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <code>Iterable[A]</code> and a function <code>A =&gt; IO[E, B]</code>,
nondeterministically apply the function to each element of the collection
without keeping the original ordering of the results.</p><p>This function is similar to <a href="#parTraverse[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" name="monix.bio.IO#parTraverse" id="monix.bio.IO#parTraverse" class="extmbr">parTraverse</a>, but neither the effects nor the
results will be ordered. Useful when you don't need ordering because:</p><ul><li>it has non-blocking behavior (but not wait-free)</li><li>it can be more efficient (compared with <a href="#parTraverse[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" name="monix.bio.IO#parTraverse" id="monix.bio.IO#parTraverse" class="extmbr">parTraverse</a>), but not
   necessarily (if you care about performance, then test)</li></ul><p>It's a generalized version of <a href="#parSequenceUnordered[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequenceUnordered" id="monix.bio.IO#parSequenceUnordered" class="extmbr">parSequenceUnordered</a>.</p><p>ADVICE: In a real life scenario the tasks should
                          be expensive in order to warrant parallel execution. Parallelism
                          doesn't magically speed up the code - it's usually fine for I/O-bound
                          tasks, however for CPU-bound tasks it can make things worse.
                          Performance improvements need to be verified.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#parZip2" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="parZip2[E,A1,A2,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2]):monix.bio.IO[E,(A1,A2)]" class="anchorToMember"></a><a id="parZip2[E,A1,A2,R](IO[E,A1],IO[E,A2]):IO[E,(A1,A2)]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parZip2[E,A1,A2,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2]):monix.bio.IO[E,(A1,A2)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parZip2</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip2.E" class="extype">E</span>, <span name="monix.bio.IO.parZip2.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip2.E" class="extype">E</span>, <span name="monix.bio.IO.parZip2.A2" class="extype">A2</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip2.E" class="extype">E</span>, (<span name="monix.bio.IO.parZip2.A1" class="extype">A1</span>, <span name="monix.bio.IO.parZip2.A2" class="extype">A2</span>)]</span></span><p class="shortcomment cmt">Pairs two <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instances using <a href="#parMap2[E,A1,A2,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2])(f:(A1,A2)=&gt;R):monix.bio.IO[E,R]" name="monix.bio.IO#parMap2" id="monix.bio.IO#parMap2" class="extmbr">parMap2</a>.</p></li><li class="indented0 " name="monix.bio.IO#parZip3" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="parZip3[E,A1,A2,A3](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3]):monix.bio.IO[E,(A1,A2,A3)]" class="anchorToMember"></a><a id="parZip3[E,A1,A2,A3](IO[E,A1],IO[E,A2],IO[E,A3]):IO[E,(A1,A2,A3)]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parZip3[E,A1,A2,A3](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3]):monix.bio.IO[E,(A1,A2,A3)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parZip3</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip3.E" class="extype">E</span>, <span name="monix.bio.IO.parZip3.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip3.E" class="extype">E</span>, <span name="monix.bio.IO.parZip3.A2" class="extype">A2</span>]</span>, <span name="fa3">fa3: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip3.E" class="extype">E</span>, <span name="monix.bio.IO.parZip3.A3" class="extype">A3</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip3.E" class="extype">E</span>, (<span name="monix.bio.IO.parZip3.A1" class="extype">A1</span>, <span name="monix.bio.IO.parZip3.A2" class="extype">A2</span>, <span name="monix.bio.IO.parZip3.A3" class="extype">A3</span>)]</span></span><p class="shortcomment cmt">Pairs three <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instances using <a href="#parMap3[E,A1,A2,A3,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3])(f:(A1,A2,A3)=&gt;R):monix.bio.IO[E,R]" name="monix.bio.IO#parMap3" id="monix.bio.IO#parMap3" class="extmbr">parMap3</a>.</p></li><li class="indented0 " name="monix.bio.IO#parZip4" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="parZip4[E,A1,A2,A3,A4](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4]):monix.bio.IO[E,(A1,A2,A3,A4)]" class="anchorToMember"></a><a id="parZip4[E,A1,A2,A3,A4](IO[E,A1],IO[E,A2],IO[E,A3],IO[E,A4]):IO[E,(A1,A2,A3,A4)]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parZip4[E,A1,A2,A3,A4](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4]):monix.bio.IO[E,(A1,A2,A3,A4)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parZip4</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip4.E" class="extype">E</span>, <span name="monix.bio.IO.parZip4.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip4.E" class="extype">E</span>, <span name="monix.bio.IO.parZip4.A2" class="extype">A2</span>]</span>, <span name="fa3">fa3: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip4.E" class="extype">E</span>, <span name="monix.bio.IO.parZip4.A3" class="extype">A3</span>]</span>, <span name="fa4">fa4: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip4.E" class="extype">E</span>, <span name="monix.bio.IO.parZip4.A4" class="extype">A4</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip4.E" class="extype">E</span>, (<span name="monix.bio.IO.parZip4.A1" class="extype">A1</span>, <span name="monix.bio.IO.parZip4.A2" class="extype">A2</span>, <span name="monix.bio.IO.parZip4.A3" class="extype">A3</span>, <span name="monix.bio.IO.parZip4.A4" class="extype">A4</span>)]</span></span><p class="shortcomment cmt">Pairs four <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instances using <a href="#parMap4[E,A1,A2,A3,A4,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4])(f:(A1,A2,A3,A4)=&gt;R):monix.bio.IO[E,R]" name="monix.bio.IO#parMap4" id="monix.bio.IO#parMap4" class="extmbr">parMap4</a>.</p></li><li class="indented0 " name="monix.bio.IO#parZip5" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="parZip5[E,A1,A2,A3,A4,A5](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5]):monix.bio.IO[E,(A1,A2,A3,A4,A5)]" class="anchorToMember"></a><a id="parZip5[E,A1,A2,A3,A4,A5](IO[E,A1],IO[E,A2],IO[E,A3],IO[E,A4],IO[E,A5]):IO[E,(A1,A2,A3,A4,A5)]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parZip5[E,A1,A2,A3,A4,A5](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5]):monix.bio.IO[E,(A1,A2,A3,A4,A5)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parZip5</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="A5">A5</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip5.E" class="extype">E</span>, <span name="monix.bio.IO.parZip5.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip5.E" class="extype">E</span>, <span name="monix.bio.IO.parZip5.A2" class="extype">A2</span>]</span>, <span name="fa3">fa3: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip5.E" class="extype">E</span>, <span name="monix.bio.IO.parZip5.A3" class="extype">A3</span>]</span>, <span name="fa4">fa4: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip5.E" class="extype">E</span>, <span name="monix.bio.IO.parZip5.A4" class="extype">A4</span>]</span>, <span name="fa5">fa5: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip5.E" class="extype">E</span>, <span name="monix.bio.IO.parZip5.A5" class="extype">A5</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip5.E" class="extype">E</span>, (<span name="monix.bio.IO.parZip5.A1" class="extype">A1</span>, <span name="monix.bio.IO.parZip5.A2" class="extype">A2</span>, <span name="monix.bio.IO.parZip5.A3" class="extype">A3</span>, <span name="monix.bio.IO.parZip5.A4" class="extype">A4</span>, <span name="monix.bio.IO.parZip5.A5" class="extype">A5</span>)]</span></span><p class="shortcomment cmt">Pairs five <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instances using <a href="#parMap5[E,A1,A2,A3,A4,A5,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5])(f:(A1,A2,A3,A4,A5)=&gt;R):monix.bio.IO[E,R]" name="monix.bio.IO#parMap5" id="monix.bio.IO#parMap5" class="extmbr">parMap5</a>.</p></li><li class="indented0 " name="monix.bio.IO#parZip6" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="parZip6[E,A1,A2,A3,A4,A5,A6](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5],fa6:monix.bio.IO[E,A6]):monix.bio.IO[E,(A1,A2,A3,A4,A5,A6)]" class="anchorToMember"></a><a id="parZip6[E,A1,A2,A3,A4,A5,A6](IO[E,A1],IO[E,A2],IO[E,A3],IO[E,A4],IO[E,A5],IO[E,A6]):IO[E,(A1,A2,A3,A4,A5,A6)]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#parZip6[E,A1,A2,A3,A4,A5,A6](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5],fa6:monix.bio.IO[E,A6]):monix.bio.IO[E,(A1,A2,A3,A4,A5,A6)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parZip6</span><span class="tparams">[<span name="E">E</span>, <span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="A4">A4</span>, <span name="A5">A5</span>, <span name="A6">A6</span>]</span><span class="params">(<span name="fa1">fa1: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip6.E" class="extype">E</span>, <span name="monix.bio.IO.parZip6.A1" class="extype">A1</span>]</span>, <span name="fa2">fa2: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip6.E" class="extype">E</span>, <span name="monix.bio.IO.parZip6.A2" class="extype">A2</span>]</span>, <span name="fa3">fa3: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip6.E" class="extype">E</span>, <span name="monix.bio.IO.parZip6.A3" class="extype">A3</span>]</span>, <span name="fa4">fa4: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip6.E" class="extype">E</span>, <span name="monix.bio.IO.parZip6.A4" class="extype">A4</span>]</span>, <span name="fa5">fa5: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip6.E" class="extype">E</span>, <span name="monix.bio.IO.parZip6.A5" class="extype">A5</span>]</span>, <span name="fa6">fa6: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip6.E" class="extype">E</span>, <span name="monix.bio.IO.parZip6.A6" class="extype">A6</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.parZip6.E" class="extype">E</span>, (<span name="monix.bio.IO.parZip6.A1" class="extype">A1</span>, <span name="monix.bio.IO.parZip6.A2" class="extype">A2</span>, <span name="monix.bio.IO.parZip6.A3" class="extype">A3</span>, <span name="monix.bio.IO.parZip6.A4" class="extype">A4</span>, <span name="monix.bio.IO.parZip6.A5" class="extype">A5</span>, <span name="monix.bio.IO.parZip6.A6" class="extype">A6</span>)]</span></span><p class="shortcomment cmt">Pairs six <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> instances using <a href="#parMap6[E,A1,A2,A3,A4,A5,A6,R](fa1:monix.bio.IO[E,A1],fa2:monix.bio.IO[E,A2],fa3:monix.bio.IO[E,A3],fa4:monix.bio.IO[E,A4],fa5:monix.bio.IO[E,A5],fa6:monix.bio.IO[E,A6])(f:(A1,A2,A3,A4,A5,A6)=&gt;R):monix.bio.IO[E,R]" name="monix.bio.IO#parMap6" id="monix.bio.IO#parMap6" class="extmbr">parMap6</a>.</p></li><li class="indented0 " name="monix.bio.IO#pure" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pure[A](a:A):monix.bio.UIO[A]" class="anchorToMember"></a><a id="pure[A](A):UIO[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#pure[A](a:A):monix.bio.UIO[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pure</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: <span name="monix.bio.IO.pure.A" class="extype">A</span></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="monix.bio.IO.pure.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Lifts a value into the task context.</p><div class="fullcomment"><div class="comment cmt"><p>Lifts a value into the task context. Alias for <a href="#now[A](a:A):monix.bio.UIO[A]" name="monix.bio.IO#now" id="monix.bio.IO#now" class="extmbr">now</a>.</p></div></div></li><li class="indented0 " name="monix.bio.IO#race" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="race[E,A,B](fa:monix.bio.IO[E,A],fb:monix.bio.IO[E,B]):monix.bio.IO[E,Either[A,B]]" class="anchorToMember"></a><a id="race[E,A,B](IO[E,A],IO[E,B]):IO[E,Either[A,B]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#race[E,A,B](fa:monix.bio.IO[E,A],fb:monix.bio.IO[E,B]):monix.bio.IO[E,Either[A,B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">race</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="fa">fa: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.race.E" class="extype">E</span>, <span name="monix.bio.IO.race.A" class="extype">A</span>]</span>, <span name="fb">fb: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.race.E" class="extype">E</span>, <span name="monix.bio.IO.race.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.race.E" class="extype">E</span>, <span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.IO.race.A" class="extype">A</span>, <span name="monix.bio.IO.race.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">Run two <code>Task</code> actions concurrently, and return the first to
finish, either in success or error.</p><div class="fullcomment"><div class="comment cmt"><p>Run two <code>Task</code> actions concurrently, and return the first to
finish, either in success or error. The loser of the race is
cancelled.</p><p>The two tasks are executed in parallel, the winner being the
first that signals a result.</p><p>As an example, this would be equivalent with <a href="IO.html#timeout(after:scala.concurrent.duration.FiniteDuration):monix.bio.IO[E,Option[A]]" name="monix.bio.IO#timeout" id="monix.bio.IO#timeout" class="extmbr">IO.timeout</a>:</p><pre><span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> scala.concurrent.TimeoutException

<span class="cmt">// some long running task</span>
<span class="kw">val</span> myTask = Task(<span class="num">42</span>)

<span class="kw">val</span> timeoutError = Task
  .raiseError(<span class="kw">new</span> TimeoutException)
  .delayExecution(<span class="num">5.</span>seconds)

Task.race(myTask, timeoutError)</pre><p>Similarly <a href="IO.html#timeoutTo[E1&gt;:E,B&gt;:A](after:scala.concurrent.duration.FiniteDuration,backup:monix.bio.IO[E1,B]):monix.bio.IO[E1,B]" name="monix.bio.IO#timeoutTo" id="monix.bio.IO#timeoutTo" class="extmbr">IO.timeoutTo</a> is expressed in terms of <code>race</code>.</p><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#racePair[E,A,B](fa:monix.bio.IO[E,A],fb:monix.bio.IO[E,B]):monix.bio.IO[E,Either[(A,monix.bio.Fiber[E,B]),(monix.bio.Fiber[E,A],B)]]" name="monix.bio.IO#racePair" id="monix.bio.IO#racePair" class="extmbr">racePair</a> for a version that does not cancel
    the loser automatically on successful results and doctodo raceMany
    for a version that races a whole list of tasks.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#raceMany" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="raceMany[E,A](tasks:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="raceMany[E,A](Iterable[IO[E,A]]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#raceMany[E,A](tasks:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">raceMany</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="tasks">tasks: <span name="scala.Iterable" class="extype">Iterable</span>[<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.raceMany.E" class="extype">E</span>, <span name="monix.bio.IO.raceMany.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.raceMany.E" class="extype">E</span>, <span name="monix.bio.IO.raceMany.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Runs multiple tasks in a concurrent way and returns the fastest
of them, regardless whether it's a success, a typed error or a
terminal error.</p><div class="fullcomment"><div class="comment cmt"><p>Runs multiple tasks in a concurrent way and returns the fastest
of them, regardless whether it's a success, a typed error or a
terminal error. Every task losing the race gets cancelled.</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="kw">val</span> tasks: <span class="std">List</span>[UIO[<span class="std">Int</span>]] =
  <span class="std">List</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).map(i <span class="kw">=&gt;</span> IO.sleep(i.seconds).map(_ <span class="kw">=&gt;</span> i))

<span class="kw">val</span> winner: UIO[<span class="std">Int</span>] = IO.raceMany(tasks)</pre><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#race[E,A,B](fa:monix.bio.IO[E,A],fb:monix.bio.IO[E,B]):monix.bio.IO[E,Either[A,B]]" name="monix.bio.IO#race" id="monix.bio.IO#race" class="extmbr">race</a> or <a href="#racePair[E,A,B](fa:monix.bio.IO[E,A],fb:monix.bio.IO[E,B]):monix.bio.IO[E,Either[(A,monix.bio.Fiber[E,B]),(monix.bio.Fiber[E,A],B)]]" name="monix.bio.IO#racePair" id="monix.bio.IO#racePair" class="extmbr">racePair</a> for racing two tasks, which might
     give you more control over the execution.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#racePair" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="racePair[E,A,B](fa:monix.bio.IO[E,A],fb:monix.bio.IO[E,B]):monix.bio.IO[E,Either[(A,monix.bio.Fiber[E,B]),(monix.bio.Fiber[E,A],B)]]" class="anchorToMember"></a><a id="racePair[E,A,B](IO[E,A],IO[E,B]):IO[E,Either[(A,Fiber[E,B]),(Fiber[E,A],B)]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#racePair[E,A,B](fa:monix.bio.IO[E,A],fb:monix.bio.IO[E,B]):monix.bio.IO[E,Either[(A,monix.bio.Fiber[E,B]),(monix.bio.Fiber[E,A],B)]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">racePair</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="fa">fa: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.racePair.E" class="extype">E</span>, <span name="monix.bio.IO.racePair.A" class="extype">A</span>]</span>, <span name="fb">fb: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.racePair.E" class="extype">E</span>, <span name="monix.bio.IO.racePair.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.racePair.E" class="extype">E</span>, <span name="scala.Either" class="extype">Either</span>[(<span name="monix.bio.IO.racePair.A" class="extype">A</span>, <a href="Fiber.html" name="monix.bio.Fiber" id="monix.bio.Fiber" class="extype">Fiber</a>[<span name="monix.bio.IO.racePair.E" class="extype">E</span>, <span name="monix.bio.IO.racePair.B" class="extype">B</span>]), (<a href="Fiber.html" name="monix.bio.Fiber" id="monix.bio.Fiber" class="extype">Fiber</a>[<span name="monix.bio.IO.racePair.E" class="extype">E</span>, <span name="monix.bio.IO.racePair.A" class="extype">A</span>], <span name="monix.bio.IO.racePair.B" class="extype">B</span>)]]</span></span><p class="shortcomment cmt">Run two <code>Task</code> actions concurrently, and returns a pair
containing both the winner's successful value and the loser
represented as a still-unfinished task.</p><div class="fullcomment"><div class="comment cmt"><p>Run two <code>Task</code> actions concurrently, and returns a pair
containing both the winner's successful value and the loser
represented as a still-unfinished task.</p><p>If the first task completes in error, then the result will
complete in error, the other task being cancelled.</p><p>On usage the user has the option of cancelling the losing task,
this being equivalent with plain <a href="#race[E,A,B](fa:monix.bio.IO[E,A],fb:monix.bio.IO[E,B]):monix.bio.IO[E,Either[A,B]]" name="monix.bio.IO#race" id="monix.bio.IO#race" class="extmbr">race</a>:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="kw">val</span> ta = Task.sleep(<span class="num">2.</span>seconds).map(_ <span class="kw">=&gt;</span> <span class="lit">"a"</span>)
<span class="kw">val</span> tb = Task.sleep(<span class="num">3.</span>seconds).map(_ <span class="kw">=&gt;</span> <span class="lit">"b"</span>)

<span class="cmt">// `tb` is going to be cancelled as it returns 1 second after `ta`</span>
Task.racePair(ta, tb).flatMap {
  <span class="kw">case</span> Left((a, taskB)) <span class="kw">=&gt;</span>
    taskB.cancel.map(_ <span class="kw">=&gt;</span> a)
  <span class="kw">case</span> Right((taskA, b)) <span class="kw">=&gt;</span>
    taskA.cancel.map(_ <span class="kw">=&gt;</span> b)
}</pre><p>NOTE: the tasks get forked automatically so there's
                          no need to force asynchronous execution for immediate tasks,
                          parallelism being guaranteed when multi-threading is available!</p><p>                          All specified tasks get evaluated in parallel, regardless of their
                          execution model (<a href="#eval[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#eval" id="monix.bio.IO#eval" class="extmbr">IO.eval</a> vs <a href="#evalAsync[A](a:=&gt;A):monix.bio.Task[A]" name="monix.bio.IO#evalAsync" id="monix.bio.IO#evalAsync" class="extmbr">IO.evalAsync</a> doesn't matter).
                          Also the implementation tries to be smart about detecting forked
                          tasks so it can eliminate extraneous forks for the very obvious
                          cases.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#race[E,A,B](fa:monix.bio.IO[E,A],fb:monix.bio.IO[E,B]):monix.bio.IO[E,Either[A,B]]" name="monix.bio.IO#race" id="monix.bio.IO#race" class="extmbr">race</a> for a simpler version that cancels the loser
     immediately or doctodo raceMany that races collections of tasks.</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#raiseError" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="raiseError[E](ex:E):monix.bio.IO[E,Nothing]" class="anchorToMember"></a><a id="raiseError[E](E):IO[E,Nothing]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#raiseError[E](ex:E):monix.bio.IO[E,Nothing]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">raiseError</span><span class="tparams">[<span name="E">E</span>]</span><span class="params">(<span name="ex">ex: <span name="monix.bio.IO.raiseError.E" class="extype">E</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.raiseError.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.6/scala/Nothing.html#scala.Nothing" name="scala.Nothing" id="scala.Nothing" class="extype">Nothing</a>]</span></span><p class="shortcomment cmt">Returns a task that on execution is always finishing in error
emitting the specified value in a typed error channel.</p></li><li class="indented0 " name="monix.bio.IO#raiseUnless" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="raiseUnless[E](cond:Boolean)(e:=&gt;E):monix.bio.IO[E,Unit]" class="anchorToMember"></a><a id="raiseUnless[E](Boolean)(=&gt;E):IO[E,Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#raiseUnless[E](cond:Boolean)(e:=&gt;E):monix.bio.IO[E,Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">raiseUnless</span><span class="tparams">[<span name="E">E</span>]</span><span class="params">(<span name="cond">cond: <a href="https://www.scala-lang.org/api/2.13.6/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span name="e">e: =&gt; <span name="monix.bio.IO.raiseUnless.E" class="extype">E</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.raiseUnless.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Returns <code>raiseError</code> when <code>cond</code> is false, otherwise IO.unit
</p><div class="fullcomment"><div class="comment cmt"><p>Returns <code>raiseError</code> when <code>cond</code> is false, otherwise IO.unit
</p></div><dl class="attributes block"><div class="block">Example:<ol><li class="cmt"><p></p><pre><span class="kw">val</span> tooMany = <span class="num">5</span>
<span class="kw">val</span> x: <span class="std">Int</span> = ???
IO.raiseUnless(x &lt; tooMany)(<span class="kw">new</span> IllegalArgumentException(<span class="lit">"Too many"</span>))</pre></li></ol></div></dl></div></li><li class="indented0 " name="monix.bio.IO#raiseWhen" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="raiseWhen[E](cond:Boolean)(e:=&gt;E):monix.bio.IO[E,Unit]" class="anchorToMember"></a><a id="raiseWhen[E](Boolean)(=&gt;E):IO[E,Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#raiseWhen[E](cond:Boolean)(e:=&gt;E):monix.bio.IO[E,Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">raiseWhen</span><span class="tparams">[<span name="E">E</span>]</span><span class="params">(<span name="cond">cond: <a href="https://www.scala-lang.org/api/2.13.6/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span name="e">e: =&gt; <span name="monix.bio.IO.raiseWhen.E" class="extype">E</span></span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.raiseWhen.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Returns <code>raiseError</code> when the <code>cond</code> is true, otherwise <code>IO.unit</code>
</p><div class="fullcomment"><div class="comment cmt"><p>Returns <code>raiseError</code> when the <code>cond</code> is true, otherwise <code>IO.unit</code>
</p></div><dl class="attributes block"><div class="block">Example:<ol><li class="cmt"><p></p><pre><span class="kw">val</span> tooMany = <span class="num">5</span>
<span class="kw">val</span> x: <span class="std">Int</span> = ???
IO.raiseWhen(x &gt;= tooMany)(<span class="kw">new</span> IllegalArgumentException(<span class="lit">"Too many"</span>))</pre></li></ol></div></dl></div></li><li class="indented0 " name="monix.bio.IO#readOptions" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="readOptions:monix.bio.UIO[monix.bio.IO.Options]" class="anchorToMember"></a><a id="readOptions:UIO[Options]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#readOptions:monix.bio.UIO[monix.bio.IO.Options]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">readOptions</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="IO$$Options.html" name="monix.bio.IO.Options" id="monix.bio.IO.Options" class="extype">Options</a>]</span></span><p class="shortcomment cmt">Returns the current <a href="IO$$Options.html" name="monix.bio.IO.Options" id="monix.bio.IO.Options" class="extype">IO.Options</a> configuration, which determine the
task's run-loop behavior.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the current <a href="IO$$Options.html" name="monix.bio.IO.Options" id="monix.bio.IO.Options" class="extype">IO.Options</a> configuration, which determine the
task's run-loop behavior.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="IO.html#executeWithOptions(f:monix.bio.IO.Options=&gt;monix.bio.IO.Options):monix.bio.IO[E,A]" name="monix.bio.IO#executeWithOptions" id="monix.bio.IO#executeWithOptions" class="extmbr">IO.executeWithOptions</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#rethrow" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="rethrow[E,A](fa:monix.bio.IO[E,Either[E,A]]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="rethrow[E,A](IO[E,Either[E,A]]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#rethrow[E,A](fa:monix.bio.IO[E,Either[E,A]]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">rethrow</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="fa">fa: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.rethrow.E" class="extype">E</span>, <span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.IO.rethrow.E" class="extype">E</span>, <span name="monix.bio.IO.rethrow.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.rethrow.E" class="extype">E</span>, <span name="monix.bio.IO.rethrow.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Inverse of <code>attempt</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Inverse of <code>attempt</code>. Creates a new <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a> that absorbs <code>Either</code>.</p><p><code>IO.rethrow(IO.now(Right(42))) &lt;-&gt; IO.now(42)</code></p><p><code>IO.rethrow(IO.now(Left("error"))) &lt;-&gt; IO.raiseError("error")</code>
</p></div></div></li><li class="indented0 " name="monix.bio.IO#right" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="right[A,B](b:B):monix.bio.UIO[Either[A,B]]" class="anchorToMember"></a><a id="right[A,B](B):UIO[Either[A,B]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#right[A,B](b:B):monix.bio.UIO[Either[A,B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">right</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="b">b: <span name="monix.bio.IO.right.B" class="extype">B</span></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.IO.right.A" class="extype">A</span>, <span name="monix.bio.IO.right.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">Returns an <code>IO</code> that on execution is always successful, emitting right value.</p></li><li class="indented0 " name="monix.bio.IO#sequence" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" class="anchorToMember"></a><a id="sequence[E,A](Iterable[IO[E,A]]):IO[E,List[A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#sequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sequence</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.sequence.E" class="extype">E</span>, <span name="monix.bio.IO.sequence.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.sequence.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.IO.sequence.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Given a <code>Iterable</code> of tasks, transforms it to a task signaling
the collection, executing the tasks one by one and gathering their
results in the same collection.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <code>Iterable</code> of tasks, transforms it to a task signaling
the collection, executing the tasks one by one and gathering their
results in the same collection.</p><p>This operation will execute the tasks one by one, in order, which means that
both effects and results will be ordered. See <a href="#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">parSequence</a> and <a href="#parSequenceUnordered[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequenceUnordered" id="monix.bio.IO#parSequenceUnordered" class="extmbr">parSequenceUnordered</a>
for unordered results or effects, and thus potential of running in parallel.</p><p> It's a simple version of <a href="#traverse[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" name="monix.bio.IO#traverse" id="monix.bio.IO#traverse" class="extmbr">traverse</a>.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#shift" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="shift(ec:scala.concurrent.ExecutionContext):monix.bio.UIO[Unit]" class="anchorToMember"></a><a id="shift(ExecutionContext):UIO[Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#shift(ec:scala.concurrent.ExecutionContext):monix.bio.UIO[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">shift</span><span class="params">(<span name="ec">ec: <a href="https://www.scala-lang.org/api/2.13.6/scala/concurrent/ExecutionContext.html#scala.concurrent.ExecutionContext" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Asynchronous boundary described as an effectful <code>Task</code> that
can be used in <code>flatMap</code> chains to "shift" the continuation
of the run-loop to another call stack or thread, managed by
the given execution context.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous boundary described as an effectful <code>Task</code> that
can be used in <code>flatMap</code> chains to "shift" the continuation
of the run-loop to another call stack or thread, managed by
the given execution context.</p><p>This is the equivalent of <code>IO.shift</code>.</p><p>For example we can introduce an
        asynchronous boundary in the <code>flatMap</code> chain before a
        certain task, this being literally the implementation of
        <a href="IO.html#executeAsync:monix.bio.IO[E,A]" name="monix.bio.IO#executeAsync" id="monix.bio.IO#executeAsync" class="extmbr">executeAsync</a>:</p><pre><span class="kw">val</span> task = IO.eval(<span class="num">35</span>)

IO.shift.flatMap(_ <span class="kw">=&gt;</span> task)</pre><p>        And this can also be described with <code>&gt;&gt;</code> from Cats:</p><pre><span class="kw">import</span> cats.syntax.all._

IO.shift &gt;&gt; task</pre><p>                          Or we can specify an asynchronous boundary <i>after</i>
                          the evaluation of a certain task, this being literally
                          the implementation of
                          <a href="IO.html#asyncBoundary:monix.bio.IO[E,A]" name="monix.bio.IO#asyncBoundary" id="monix.bio.IO#asyncBoundary" class="extmbr">.asyncBoundary</a>:</p><pre>task.flatMap(a <span class="kw">=&gt;</span> IO.shift.map(_ <span class="kw">=&gt;</span> a))</pre><p>                          And again we can also describe this with <code>&lt;*</code>
                          from Cats:</p><pre>task &lt;* IO.shift</pre></div></div></li><li class="indented0 " name="monix.bio.IO#shift" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="shift:monix.bio.UIO[Unit]" class="anchorToMember"></a><a id="shift:UIO[Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#shift:monix.bio.UIO[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">shift</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Asynchronous boundary described as an effectful <code>Task</code> that
can be used in <code>flatMap</code> chains to "shift" the continuation
of the run-loop to another thread or call stack, managed by
the default <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous boundary described as an effectful <code>Task</code> that
can be used in <code>flatMap</code> chains to "shift" the continuation
of the run-loop to another thread or call stack, managed by
the default <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>.</p><p>This is the equivalent of <code>IO.shift</code>, except that Monix's <code>Task</code>
gets executed with an injected <code>Scheduler</code> in <a href="IO.html#runAsync(cb:Either[monix.bio.Cause[E],A]=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" name="monix.bio.IO#runAsync" id="monix.bio.IO#runAsync" class="extmbr">IO.runAsync</a> or
in <a href="IO.html#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.IO#runToFuture" id="monix.bio.IO#runToFuture" class="extmbr">IO.runToFuture</a> and that's going to be the <code>Scheduler</code>
responsible for the "shift".</p><p>For example we can introduce an
        asynchronous boundary in the <code>flatMap</code> chain before a
        certain task, this being literally the implementation of
        <a href="IO.html#executeAsync:monix.bio.IO[E,A]" name="monix.bio.IO#executeAsync" id="monix.bio.IO#executeAsync" class="extmbr">executeAsync</a>:</p><pre><span class="kw">val</span> task = IO.eval(<span class="num">35</span>)

IO.shift.flatMap(_ <span class="kw">=&gt;</span> task)</pre><p>        And this can also be described with <code>&gt;&gt;</code> from Cats:</p><pre><span class="kw">import</span> cats.syntax.all._

IO.shift &gt;&gt; task</pre><p>                          Or we can specify an asynchronous boundary <i>after</i>
                          the evaluation of a certain task, this being literally
                          the implementation of
                          <a href="IO.html#asyncBoundary:monix.bio.IO[E,A]" name="monix.bio.IO#asyncBoundary" id="monix.bio.IO#asyncBoundary" class="extmbr">.asyncBoundary</a>:</p><pre>task.flatMap(a <span class="kw">=&gt;</span> IO.shift.map(_ <span class="kw">=&gt;</span> a))</pre><p>                          And again we can also describe this with <code>&lt;*</code>
                          from Cats:</p><pre>task &lt;* IO.shift</pre></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="IO.html#executeOn(s:monix.execution.Scheduler,forceAsync:Boolean):monix.bio.IO[E,A]" name="monix.bio.IO#executeOn" id="monix.bio.IO#executeOn" class="extmbr">IO.executeOn</a> for a way to override the default <code>Scheduler</code></p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO#sleep" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sleep(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.UIO[Unit]" class="anchorToMember"></a><a id="sleep(FiniteDuration):UIO[Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#sleep(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.UIO[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sleep</span><span class="params">(<span name="timespan">timespan: <a href="https://www.scala-lang.org/api/2.13.6/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Creates a new <code>Task</code> that will sleep for the given duration,
emitting a tick when that time span is over.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <code>Task</code> that will sleep for the given duration,
emitting a tick when that time span is over.</p><p>As an example on evaluation this will print "Hello!" after
3 seconds:</p><pre><span class="kw">import</span> scala.concurrent.duration._

IO.sleep(<span class="num">3.</span>seconds).flatMap { _ <span class="kw">=&gt;</span>
  IO.eval(println(<span class="lit">"Hello!"</span>))
}</pre><p>See <a href="IO.html#delayExecution(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.IO[E,A]" name="monix.bio.IO#delayExecution" id="monix.bio.IO#delayExecution" class="extmbr">IO.delayExecution</a> for this operation described as
a method on <code>Task</code> references or <a href="IO.html#delayResult(timespan:scala.concurrent.duration.FiniteDuration):monix.bio.IO[E,A]" name="monix.bio.IO#delayResult" id="monix.bio.IO#delayResult" class="extmbr">IO.delayResult</a> for the
helper that triggers the evaluation of the source on time, but
then delays the result.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#some" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="some[A](a:A):monix.bio.UIO[Option[A]]" class="anchorToMember"></a><a id="some[A](A):UIO[Option[A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#some[A](a:A):monix.bio.UIO[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">some</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="a">a: <span name="monix.bio.IO.some.A" class="extype">A</span></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.6/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.bio.IO.some.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Returns an <code>IO</code> that on execution is always successful, emitting some value.</p></li><li class="indented0 " name="monix.bio.IO#suspend" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="suspend[A](fa:=&gt;monix.bio.Task[A]):monix.bio.Task[A]" class="anchorToMember"></a><a id="suspend[A](=&gt;Task[A]):Task[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#suspend[A](fa:=&gt;monix.bio.Task[A]):monix.bio.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">suspend</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="fa">fa: =&gt; <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.suspend.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="index.html#Task[+A]=monix.bio.IO[Throwable,A]" name="monix.bio.Task" id="monix.bio.Task" class="extmbr">Task</a>[<span name="monix.bio.IO.suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Alias for <a href="#defer[A](fa:=&gt;monix.bio.Task[A]):monix.bio.Task[A]" name="monix.bio.IO#defer" id="monix.bio.IO#defer" class="extmbr">defer</a>.</p></li><li class="indented0 " name="monix.bio.IO#suspendTotal" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="suspendTotal[E,A](fa:=&gt;monix.bio.IO[E,A]):monix.bio.IO[E,A]" class="anchorToMember"></a><a id="suspendTotal[E,A](=&gt;IO[E,A]):IO[E,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#suspendTotal[E,A](fa:=&gt;monix.bio.IO[E,A]):monix.bio.IO[E,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">suspendTotal</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="fa">fa: =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.suspendTotal.E" class="extype">E</span>, <span name="monix.bio.IO.suspendTotal.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.suspendTotal.E" class="extype">E</span>, <span name="monix.bio.IO.suspendTotal.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Alias for <a href="#deferTotal[E,A](fa:=&gt;monix.bio.IO[E,A]):monix.bio.IO[E,A]" name="monix.bio.IO#deferTotal" id="monix.bio.IO#deferTotal" class="extmbr">deferTotal</a>.</p></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0" class="anchorToMember"></a><a id="synchronized[T0](=&gt;T0):T0" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="monix.bio.IO#tailRecM" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="tailRecM[E,A,B](a:A)(f:A=&gt;monix.bio.IO[E,Either[A,B]]):monix.bio.IO[E,B]" class="anchorToMember"></a><a id="tailRecM[E,A,B](A)((A)=&gt;IO[E,Either[A,B]]):IO[E,B]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#tailRecM[E,A,B](a:A)(f:A=&gt;monix.bio.IO[E,Either[A,B]]):monix.bio.IO[E,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">tailRecM</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="a">a: <span name="monix.bio.IO.tailRecM.A" class="extype">A</span></span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.tailRecM.A" class="extype">A</span>) =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.tailRecM.E" class="extype">E</span>, <span name="scala.Either" class="extype">Either</span>[<span name="monix.bio.IO.tailRecM.A" class="extype">A</span>, <span name="monix.bio.IO.tailRecM.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.tailRecM.E" class="extype">E</span>, <span name="monix.bio.IO.tailRecM.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Keeps calling <code>f</code> until it returns a <code>Right</code> result.</p><div class="fullcomment"><div class="comment cmt"><p>Keeps calling <code>f</code> until it returns a <code>Right</code> result.</p><p>Based on Phil Freeman's
<a href="http://functorial.com/stack-safety-for-free/index.pdf" target="_blank">Stack Safety for Free</a>.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#terminate" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="terminate(ex:Throwable):monix.bio.UIO[Nothing]" class="anchorToMember"></a><a id="terminate(Throwable):UIO[Nothing]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#terminate(ex:Throwable):monix.bio.UIO[Nothing]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">terminate</span><span class="params">(<span name="ex">ex: <span name="scala.Throwable" class="extype">Throwable</span></span>)</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.6/scala/Nothing.html#scala.Nothing" name="scala.Nothing" id="scala.Nothing" class="extype">Nothing</a>]</span></span><p class="shortcomment cmt">Returns a task that on execution is always finishing in a fatal (unexpected) error
emitting the specified exception.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a task that on execution is always finishing in a fatal (unexpected) error
emitting the specified exception.</p><p>This type of errors is not reflected in the type signature and it skips all regular
error handlers, except for <a href="IO.html#redeemCause[B](recover:monix.bio.Cause[E]=&gt;B,map:A=&gt;B):monix.bio.UIO[B]" name="monix.bio.IO#redeemCause" id="monix.bio.IO#redeemCause" class="extmbr">IO.redeemCause</a> and <a href="IO.html#redeemCauseWith[E1,B](recover:monix.bio.Cause[E]=&gt;monix.bio.IO[E1,B],bind:A=&gt;monix.bio.IO[E1,B]):monix.bio.IO[E1,B]" name="monix.bio.IO#redeemCauseWith" id="monix.bio.IO#redeemCauseWith" class="extmbr">IO.redeemCauseWith</a>.
</p></div></div></li><li class="indented0 " name="monix.bio.TaskTimers#timer" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="timer[E](s:monix.execution.Scheduler):cats.effect.Timer[[β$23$]monix.bio.IO[E,β$23$]]" class="anchorToMember"></a><a id="timer[E](Scheduler):Timer[[β$23$]IO[E,β$23$]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#timer[E](s:monix.execution.Scheduler):cats.effect.Timer[[β$23$]monix.bio.IO[E,β$23$]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">timer</span><span class="tparams">[<span name="E">E</span>]</span><span class="params">(<span name="s">s: <a href="https://monix.io/api/3.1/monix/execution/Scheduler.html#monix.execution.Scheduler" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="https://typelevel.org/cats-effect/api/cats/effect/Timer.html#cats.effect.Timer" name="cats.effect.Timer" id="cats.effect.Timer" class="extype">Timer</a>[[β$23$]<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.TaskTimers.timer.E" class="extype">E</span>, <span name="monix.bio.TaskTimers.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.β$23$" class="extype">β$23$</span>]]</span></span><p class="shortcomment cmt">Builds a <code>cats.effect.Timer</code> instance, given a
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> reference.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a <code>cats.effect.Timer</code> instance, given a
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> reference.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskTimers</dd></dl></div></li><li class="indented0 " name="monix.bio.TaskTimers#timer" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="timer[E]:cats.effect.Timer[[β$18$]monix.bio.IO[E,β$18$]]" class="anchorToMember"></a><a id="timer[E]:Timer[[β$18$]IO[E,β$18$]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#timer[E]:cats.effect.Timer[[β$18$]monix.bio.IO[E,β$18$]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">timer</span><span class="tparams">[<span name="E">E</span>]</span><span class="result">: <a href="https://typelevel.org/cats-effect/api/cats/effect/Timer.html#cats.effect.Timer" name="cats.effect.Timer" id="cats.effect.Timer" class="extype">Timer</a>[[β$18$]<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.TaskTimers.timer.E" class="extype">E</span>, <span name="monix.bio.TaskTimers.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.β$18$" class="extype">β$18$</span>]]</span></span><p class="shortcomment cmt">Default, pure, globally visible <code>cats.effect.Timer</code>
implementation that defers the evaluation to <code>Task</code>'s default
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>
(that's being injected in <a href="IO.html#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.IO#runToFuture" id="monix.bio.IO#runToFuture" class="extmbr">IO.runToFuture</a>).</p><div class="fullcomment"><div class="comment cmt"><p>Default, pure, globally visible <code>cats.effect.Timer</code>
implementation that defers the evaluation to <code>Task</code>'s default
<a href="https://monix.io/api/3.1/monix/execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>
(that's being injected in <a href="IO.html#runToFuture(implicits:monix.execution.Scheduler,implicitev:E&lt;:&lt;Throwable):monix.execution.CancelableFuture[A]" name="monix.bio.IO#runToFuture" id="monix.bio.IO#runToFuture" class="extmbr">IO.runToFuture</a>).
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskTimers</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.bio.IO#trace" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="trace:monix.bio.UIO[monix.bio.tracing.IOTrace]" class="anchorToMember"></a><a id="trace:UIO[IOTrace]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#trace:monix.bio.UIO[monix.bio.tracing.IOTrace]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">trace</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="tracing/IOTrace.html" name="monix.bio.tracing.IOTrace" id="monix.bio.tracing.IOTrace" class="extype">IOTrace</a>]</span></span><p class="shortcomment cmt">Returns the accumulated trace of the currently active fiber.</p></li><li class="indented0 " name="monix.bio.IO#traverse" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="traverse[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" class="anchorToMember"></a><a id="traverse[E,A,B](Iterable[A])((A)=&gt;IO[E,B]):IO[E,List[B]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#traverse[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">traverse</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<span name="monix.bio.IO.traverse.A" class="extype">A</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.IO.traverse.A" class="extype">A</span>) =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.traverse.E" class="extype">E</span>, <span name="monix.bio.IO.traverse.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.traverse.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.IO.traverse.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">Given a <code>Iterable[A]</code> and a function <code>A =&gt; Task[B]</code>, sequentially
apply the function to each element of the collection and gather their
results in the same collection.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <code>Iterable[A]</code> and a function <code>A =&gt; Task[B]</code>, sequentially
apply the function to each element of the collection and gather their
results in the same collection.</p><p> It's a generalized version of <a href="#sequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#sequence" id="monix.bio.IO#sequence" class="extmbr">sequence</a>.
</p></div></div></li><li class="indented0 " name="monix.bio.IO#unit" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="unit:monix.bio.UIO[Unit]" class="anchorToMember"></a><a id="unit:UIO[Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#unit:monix.bio.UIO[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">unit</span><span class="result">: <a href="index.html#UIO[+A]=monix.bio.IO[Nothing,A]" name="monix.bio.UIO" id="monix.bio.UIO" class="extmbr">UIO</a>[<a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">A <code>Task[Unit]</code> provided for convenience.</p></li><li class="indented0 " name="monix.bio.IO#unless" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="unless[E](cond:Boolean)(action:=&gt;monix.bio.IO[E,Unit]):monix.bio.IO[E,Unit]" class="anchorToMember"></a><a id="unless[E](Boolean)(=&gt;IO[E,Unit]):IO[E,Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#unless[E](cond:Boolean)(action:=&gt;monix.bio.IO[E,Unit]):monix.bio.IO[E,Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">unless</span><span class="tparams">[<span name="E">E</span>]</span><span class="params">(<span name="cond">cond: <a href="https://www.scala-lang.org/api/2.13.6/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span name="action">action: =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.unless.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.unless.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Returns the given argument if <code>cond</code> is false, otherwise <code>IO.Unit</code>
</p><div class="fullcomment"><div class="comment cmt"><p>Returns the given argument if <code>cond</code> is false, otherwise <code>IO.Unit</code>
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#when[E](cond:Boolean)(action:=&gt;monix.bio.IO[E,Unit]):monix.bio.IO[E,Unit]" name="monix.bio.IO#when" id="monix.bio.IO#when" class="extmbr">IO.when</a> for the inverse</p></span><span class="cmt"><p><a href="#raiseWhen[E](cond:Boolean)(e:=&gt;E):monix.bio.IO[E,Unit]" name="monix.bio.IO#raiseWhen" id="monix.bio.IO#raiseWhen" class="extmbr">IO.raiseWhen</a> for conditionally raising an error</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit" class="anchorToMember"></a><a id="wait(Long,Int):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.6/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="arg1">arg1: <a href="https://www.scala-lang.org/api/2.13.6/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit" class="anchorToMember"></a><a id="wait(Long):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.6/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.bio.IO#when" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="when[E](cond:Boolean)(action:=&gt;monix.bio.IO[E,Unit]):monix.bio.IO[E,Unit]" class="anchorToMember"></a><a id="when[E](Boolean)(=&gt;IO[E,Unit]):IO[E,Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#when[E](cond:Boolean)(action:=&gt;monix.bio.IO[E,Unit]):monix.bio.IO[E,Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">when</span><span class="tparams">[<span name="E">E</span>]</span><span class="params">(<span name="cond">cond: <a href="https://www.scala-lang.org/api/2.13.6/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span name="action">action: =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.when.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.IO.when.E" class="extype">E</span>, <a href="https://www.scala-lang.org/api/2.13.6/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Returns the given argument if <code>cond</code> is true, otherwise <code>IO.Unit</code>
</p><div class="fullcomment"><div class="comment cmt"><p>Returns the given argument if <code>cond</code> is true, otherwise <code>IO.Unit</code>
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#unless[E](cond:Boolean)(action:=&gt;monix.bio.IO[E,Unit]):monix.bio.IO[E,Unit]" name="monix.bio.IO#unless" id="monix.bio.IO#unless" class="extmbr">IO.unless</a> for the inverse</p></span><span class="cmt"><p><a href="#raiseWhen[E](cond:Boolean)(e:=&gt;E):monix.bio.IO[E,Unit]" name="monix.bio.IO#raiseWhen" id="monix.bio.IO#raiseWhen" class="extmbr">IO.raiseWhen</a> for conditionally raising an error</p></span></dd></dl></div></li><li class="indented0 " name="monix.bio.IO.AsyncBuilder" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="AsyncBuilder" class="anchorToMember"></a><a id="AsyncBuilder:AsyncBuilder" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$$AsyncBuilder$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="IO$$AsyncBuilder$.html" title=""><span class="name">AsyncBuilder</span></a><span class="result"> extends <span name="monix.bio.IO.AsyncBuilder0" class="extype">AsyncBuilder0</span></span></span></li><li class="indented0 " name="monix.bio.TaskParallelNewtype.Par" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Par" class="anchorToMember"></a><a id="Par:Par" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#Par" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><span class="name">Par</span><span class="result"> extends <span name="monix.bio.instances.Newtype2" class="extype">Newtype2</span>[<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>]</span></span><p class="shortcomment cmt">Newtype encoding, see the <a href="#Par[+E,+A]=TaskParallelNewtype.this.Par.Type[E,A]" name="monix.bio.IO.Par" id="monix.bio.IO.Par" class="extmbr">IO.Par</a> type alias
for more details.</p><div class="fullcomment"><div class="comment cmt"><p>Newtype encoding, see the <a href="#Par[+E,+A]=TaskParallelNewtype.this.Par.Type[E,A]" name="monix.bio.IO.Par" id="monix.bio.IO.Par" class="extmbr">IO.Par</a> type alias
for more details.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>TaskParallelNewtype</dd></dl></div></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="monix.bio.internal.IODeprecated.Companion#gather" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="gather[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" class="anchorToMember"></a><a id="gather[E,A](Iterable[IO[E,A]]):IO[E,List[A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#gather[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 0.1.0) Use parSequence">gather</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.internal.IODeprecated.Companion.gather.E" class="extype">E</span>, <span name="monix.bio.internal.IODeprecated.Companion.gather.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.internal.IODeprecated.Companion.gather.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.internal.IODeprecated.Companion.gather.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">DEPRECATED — renamed to <a href="#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">IO.parSequence</a>.</p><div class="fullcomment"><div class="comment cmt"><p>DEPRECATED — renamed to <a href="#parSequence[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequence" id="monix.bio.IO#parSequence" class="extmbr">IO.parSequence</a>.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>Companion</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 0.1.0)</i> Use parSequence</p></dd></dl></div></li><li class="indented0 " name="monix.bio.internal.IODeprecated.Companion#gatherN" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="gatherN[E,A](parallelism:Int)(in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" class="anchorToMember"></a><a id="gatherN[E,A](Int)(Iterable[IO[E,A]]):IO[E,List[A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#gatherN[E,A](parallelism:Int)(in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 0.1.0) Use parSequenceN">gatherN</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="parallelism">parallelism: <a href="https://www.scala-lang.org/api/2.13.6/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.internal.IODeprecated.Companion.gatherN.E" class="extype">E</span>, <span name="monix.bio.internal.IODeprecated.Companion.gatherN.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.internal.IODeprecated.Companion.gatherN.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.internal.IODeprecated.Companion.gatherN.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">DEPRECATED — renamed to <a href="#parSequenceN[E,A](parallelism:Int)(in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequenceN" id="monix.bio.IO#parSequenceN" class="extmbr">IO.parSequenceN</a></p><div class="fullcomment"><div class="comment cmt"><p>DEPRECATED — renamed to <a href="#parSequenceN[E,A](parallelism:Int)(in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequenceN" id="monix.bio.IO#parSequenceN" class="extmbr">IO.parSequenceN</a></p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>Companion</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 0.1.0)</i> Use parSequenceN</p></dd></dl></div></li><li class="indented0 " name="monix.bio.internal.IODeprecated.Companion#gatherUnordered" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="gatherUnordered[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" class="anchorToMember"></a><a id="gatherUnordered[E,A](Iterable[IO[E,A]]):IO[E,List[A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#gatherUnordered[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 0.1.0) Use parSequenceUnordered">gatherUnordered</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>]</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.internal.IODeprecated.Companion.gatherUnordered.E" class="extype">E</span>, <span name="monix.bio.internal.IODeprecated.Companion.gatherUnordered.A" class="extype">A</span>]]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.internal.IODeprecated.Companion.gatherUnordered.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.internal.IODeprecated.Companion.gatherUnordered.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">DEPRECATED — renamed to <a href="#parSequenceUnordered[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequenceUnordered" id="monix.bio.IO#parSequenceUnordered" class="extmbr">IO.parSequenceUnordered</a></p><div class="fullcomment"><div class="comment cmt"><p>DEPRECATED — renamed to <a href="#parSequenceUnordered[E,A](in:Iterable[monix.bio.IO[E,A]]):monix.bio.IO[E,List[A]]" name="monix.bio.IO#parSequenceUnordered" id="monix.bio.IO#parSequenceUnordered" class="extmbr">IO.parSequenceUnordered</a></p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>Companion</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 0.1.0)</i> Use parSequenceUnordered</p></dd></dl></div></li><li class="indented0 " name="monix.bio.internal.IODeprecated.Companion#wander" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wander[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" class="anchorToMember"></a><a id="wander[E,A,B](Iterable[A])((A)=&gt;IO[E,B]):IO[E,List[B]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#wander[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 0.1.0) Use parTraverse">wander</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<span name="monix.bio.internal.IODeprecated.Companion.wander.A" class="extype">A</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.internal.IODeprecated.Companion.wander.A" class="extype">A</span>) =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.internal.IODeprecated.Companion.wander.E" class="extype">E</span>, <span name="monix.bio.internal.IODeprecated.Companion.wander.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.internal.IODeprecated.Companion.wander.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.internal.IODeprecated.Companion.wander.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">DEPRECATED — renamed to <a href="#parTraverse[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" name="monix.bio.IO#parTraverse" id="monix.bio.IO#parTraverse" class="extmbr">IO.parTraverse</a></p><div class="fullcomment"><div class="comment cmt"><p>DEPRECATED — renamed to <a href="#parTraverse[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" name="monix.bio.IO#parTraverse" id="monix.bio.IO#parTraverse" class="extmbr">IO.parTraverse</a></p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>Companion</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 0.1.0)</i> Use parTraverse</p></dd></dl></div></li><li class="indented0 " name="monix.bio.internal.IODeprecated.Companion#wanderN" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wanderN[E,A,B](parallelism:Int)(in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" class="anchorToMember"></a><a id="wanderN[E,A,B](Int)(Iterable[A])((A)=&gt;IO[E,B]):IO[E,List[B]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#wanderN[E,A,B](parallelism:Int)(in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 0.1.0) Use parTraverseN">wanderN</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="parallelism">parallelism: <a href="https://www.scala-lang.org/api/2.13.6/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="in">in: <span name="scala.Iterable" class="extype">Iterable</span>[<span name="monix.bio.internal.IODeprecated.Companion.wanderN.A" class="extype">A</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.internal.IODeprecated.Companion.wanderN.A" class="extype">A</span>) =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.internal.IODeprecated.Companion.wanderN.E" class="extype">E</span>, <span name="monix.bio.internal.IODeprecated.Companion.wanderN.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.internal.IODeprecated.Companion.wanderN.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.internal.IODeprecated.Companion.wanderN.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">DEPRECATED — renamed to <a href="#parTraverseN[E,A,B](parallelism:Int)(in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" name="monix.bio.IO#parTraverseN" id="monix.bio.IO#parTraverseN" class="extmbr">IO.parTraverseN</a></p><div class="fullcomment"><div class="comment cmt"><p>DEPRECATED — renamed to <a href="#parTraverseN[E,A,B](parallelism:Int)(in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" name="monix.bio.IO#parTraverseN" id="monix.bio.IO#parTraverseN" class="extmbr">IO.parTraverseN</a></p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>Companion</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 0.1.0)</i> Use parTraverseN</p></dd></dl></div></li><li class="indented0 " name="monix.bio.internal.IODeprecated.Companion#wanderUnordered" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wanderUnordered[E,A,B,M[X]&lt;:Iterable[X]](in:M[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" class="anchorToMember"></a><a id="wanderUnordered[E,A,B,M[X]&lt;:Iterable[X]](M[A])((A)=&gt;IO[E,B]):IO[E,List[B]]" class="anchorToMember"></a> <span class="permalink"><a href="../../monix/bio/IO$.html#wanderUnordered[E,A,B,M[X]&lt;:Iterable[X]](in:M[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 3.2.0) Use parTraverseUnordered">wanderUnordered</span><span class="tparams">[<span name="E">E</span>, <span name="A">A</span>, <span name="B">B</span>, <span name="M">M<span class="tparams">[<span name="X">X</span>]</span> &lt;: <span name="scala.Iterable" class="extype">Iterable</span>[<span name="monix.bio.internal.IODeprecated.Companion.wanderUnordered.M.X" class="extype">X</span>]</span>]</span><span class="params">(<span name="in">in: <span name="monix.bio.internal.IODeprecated.Companion.wanderUnordered.M" class="extype">M</span>[<span name="monix.bio.internal.IODeprecated.Companion.wanderUnordered.A" class="extype">A</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.bio.internal.IODeprecated.Companion.wanderUnordered.A" class="extype">A</span>) =&gt; <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.internal.IODeprecated.Companion.wanderUnordered.E" class="extype">E</span>, <span name="monix.bio.internal.IODeprecated.Companion.wanderUnordered.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="IO.html" name="monix.bio.IO" id="monix.bio.IO" class="extype">IO</a>[<span name="monix.bio.internal.IODeprecated.Companion.wanderUnordered.E" class="extype">E</span>, <span name="scala.List" class="extype">List</span>[<span name="monix.bio.internal.IODeprecated.Companion.wanderUnordered.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">DEPRECATED — renamed to <a href="#parTraverseUnordered[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" name="monix.bio.IO#parTraverseUnordered" id="monix.bio.IO#parTraverseUnordered" class="extmbr">IO.parTraverseUnordered</a></p><div class="fullcomment"><div class="comment cmt"><p>DEPRECATED — renamed to <a href="#parTraverseUnordered[E,A,B](in:Iterable[A])(f:A=&gt;monix.bio.IO[E,B]):monix.bio.IO[E,List[B]]" name="monix.bio.IO#parTraverseUnordered" id="monix.bio.IO#parTraverseUnordered" class="extmbr">IO.parTraverseUnordered</a></p></div><dl class="attributes block"><dt>Definition Classes</dt><dd>Companion</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 3.2.0)</i> Use parTraverseUnordered</p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="java.io.Serializable" class="parent"><h3>Inherited from <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></h3></div><div name="monix.bio.TaskInstancesLevel0" class="parent"><h3>Inherited from <span name="monix.bio.TaskInstancesLevel0" class="extype">TaskInstancesLevel0</span></h3></div><div name="monix.bio.TaskInstancesLevel1" class="parent"><h3>Inherited from <span name="monix.bio.TaskInstancesLevel1" class="extype">TaskInstancesLevel1</span></h3></div><div name="monix.bio.TaskInstancesLevel2" class="parent"><h3>Inherited from <span name="monix.bio.TaskInstancesLevel2" class="extype">TaskInstancesLevel2</span></h3></div><div name="monix.bio.TaskParallelNewtype" class="parent"><h3>Inherited from <span name="monix.bio.TaskParallelNewtype" class="extype">TaskParallelNewtype</span></h3></div><div name="monix.bio.TaskContextShift" class="parent"><h3>Inherited from <span name="monix.bio.TaskContextShift" class="extype">TaskContextShift</span></h3></div><div name="monix.bio.TaskTimers" class="parent"><h3>Inherited from <span name="monix.bio.TaskTimers" class="extype">TaskTimers</span></h3></div><div name="monix.bio.TaskClocks" class="parent"><h3>Inherited from <span name="monix.bio.TaskClocks" class="extype">TaskClocks</span></h3></div><div name="monix.bio.internal.IODeprecated.Companion" class="parent"><h3>Inherited from <span name="monix.bio.internal.IODeprecated.Companion" class="extype">Companion</span></h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.6/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.6/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
